<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Mobx]]></title>
    <url>%2F2020%2F08%2F17%2Fmobx%2F</url>
    <content type="text"><![CDATA[初体验 Mobx12npx create-react-app mobxyarn add mobx mobx-react 支持装饰器 1yarn run eject 123456789101112&#123; "name": "mobx", "babel": &#123; "presets": [ "react-app" ], "plugins": [ ["@babel/plugin-proposal-decorators", &#123; "legacy": true &#125;], ["@babel/plugin-proposal-class-properties", &#123; "loose": true &#125;] ] &#125;&#125; src/stores/FruitStore.js 12345678910111213141516171819import &#123; observable, autorun, toJS, isObservableObject, isObservableArray &#125; from 'mobx';class FruitStore &#123; // 定义一个可被观测的对象 // @observable fruits; // constructor() &#123; // this.fruits = ['apple'] // &#125; @observable fruits = ['apple', 'orange'];&#125;const store = window.store = new FruitStore();export default store;autorun(() =&gt; &#123; console.log(store.fruits); // Proxy &#123;0: "apple", 1: "orange", Symbol(mobx administration): ObservableArrayAdministration&#125; console.log(toJS(store.fruits)); // ["apple", "orange"] console.log(isObservableObject(store)); // 可被观测的对象 console.log(isObservableArray(store.fruits)); // 可被观测的数组&#125;); src/index.js 123456import React from 'react';import ReactDOM from 'react-dom';import App from './App';import FruitStore from './stores/FruitStore';ReactDOM.render(&lt;App FruitStore=&#123;FruitStore&#125;/&gt;, document.querySelector('#root')); src/App.jsx observer 是观测者，observable 是可被观测的 123456789101112131415import React, &#123; Component &#125; from "react";import &#123; observer &#125; from "mobx-react";@observerclass App extends Component &#123; render() &#123; return ( &lt;div&gt; &#123;this.props.FruitStore.fruits.join(",")&#125; &lt;/div&gt; ); &#125;&#125;export default App; 控制台修改 store.fruits = [&#39;banana&#39;, &#39;watermelon&#39;] 试试 如何修改数据不推荐在组件中直接对可观测的数据进行修改 src/App.jsx 123456789101112131415161718192021222324252627import React, &#123; Component &#125; from "react";import &#123; observer &#125; from "mobx-react";@observerclass App extends Component &#123; fruit = React.createRef(); handleSubmit = e =&gt; &#123; e.preventDefault(); const fruit = this.fruit.current.value; this.props.FruitStore.fruits.unshift(fruit); &#125;; render() &#123; return ( &lt;div&gt; &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;input type="text" placeholder="fruit" ref=&#123;this.fruit&#125; /&gt; &lt;button&gt;添加&lt;/button&gt; &lt;/form&gt; &lt;div&gt; &#123;this.props.FruitStore.fruits.join(",")&#125; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125;export default App; 可以在入口文件 src/index.js 中通过 configure 配置项阻止这种不推荐的写法 12import &#123; configure &#125; from 'mobx';configure(&#123; enforceActions: 'observed' &#125;); 优化，通过 action 来改变数据 src/App.jsx 123456789101112131415161718192021222324252627import React, &#123; Component &#125; from "react";import &#123; observer &#125; from "mobx-react";@observerclass App extends Component &#123; fruit = React.createRef(); handleSubmit = e =&gt; &#123; const fruit = this.fruit.current.value; this.props.FruitStore.addFruit(fruit); e.preventDefault(); &#125;; render() &#123; return ( &lt;div&gt; &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;input type="text" placeholder="fruit" ref=&#123;this.fruit&#125; /&gt; &lt;button&gt;添加&lt;/button&gt; &lt;/form&gt; &lt;div&gt; &#123;this.props.FruitStore.fruits.join(",")&#125; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125;export default App; src/stores/FruitStore.js 123456789import &#123; observable, action &#125; from 'mobx';class FruitStore &#123; @observable fruits = ['apple', 'orange']; @action addFruit = fruit =&gt; &#123; this.fruits.unshift(fruit); &#125;;&#125;const store = window.store = new FruitStore();export default store; action.bound 123456789101112import &#123; observable, action &#125; from 'mobx';class Test &#123; @observable num = 0 @action.bound increment() &#123; console.log(this.num); // When defining, we determined the direction of this, which is what we expected this.num++; &#125;&#125;const test = new Test();setInterval(test.increment, 1000);export default test; computed 获取计算数据src/stores/FruitStore.js 123456789101112131415161718import &#123; observable, action, computed &#125; from 'mobx';class FruitStore &#123; @observable fruits = ['apple', 'orange']; @action addFruit = fruit =&gt; &#123; this.fruits.unshift(fruit); &#125;; /* getFruits = () =&gt; &#123; return this.fruits.join(','); &#125;; */ @computed get getFruits() &#123; return this.fruits.join(','); &#125; @computed get getCount() &#123; return this.fruits.length; &#125;&#125;const store = window.store = new FruitStore();export default store; src/App.jsx 1234&lt;div&gt; &lt;p&gt;数据：&#123;this.props.FruitStore.getFruits&#125;&lt;/p&gt; &lt;p&gt;长度：&#123;this.props.FruitStore.getCount&#125;&lt;/p&gt;&lt;/div&gt; 如何组织多个 storesrc/stores/index.js 123456789101112131415import FruitStore from './FruitStore';import FriendStore from './FriendStore';/* class Store &#123; constructor() &#123; this.FruitStore = FruitStore; this.FriendStore = FriendStore; &#125;&#125;export default new Store(); */export default &#123; FruitStore, FriendStore&#125;; src/stores/FruitStore.js 123456789101112131415import &#123; observable, action, computed &#125; from 'mobx';class FruitStore &#123; @observable fruits = ['apple', 'orange']; @action addFruit = fruit =&gt; &#123; this.fruits.unshift(fruit); &#125;; @computed get getFruits() &#123; return this.fruits.join(','); &#125; @computed get getCount() &#123; return this.fruits.length; &#125;&#125;const store = new FruitStore();export default store; src/stores/FriendStore.js 123456789101112131415import &#123; observable, action, computed &#125; from 'mobx';class FriendStore &#123; @observable friends = ['ifer', 'elser']; @action addFriend = friend =&gt; &#123; this.friends.unshift(friend); &#125;; @computed get getFriends() &#123; return this.friends.join(','); &#125; @computed get getCount() &#123; return this.friends.length; &#125;&#125;const store = new FriendStore();export default store; src/index.js 1234567import React from 'react';import ReactDOM from 'react-dom';import App from './App';import stores from './stores';import &#123; configure &#125; from 'mobx';configure(&#123; enforceActions: 'observed' &#125;);ReactDOM.render(&lt;App &#123;...stores&#125;/&gt;, document.querySelector('#root')); Provider 和 injectsrc/components/Fruit.jsx 123456789101112131415161718192021222324252627282930313233import React, &#123; Component &#125; from "react";import &#123; observer, inject &#125; from "mobx-react";@inject('FruitStore')@observerclass Fruit extends Component &#123; fruit = React.createRef(); handleSubmit = e =&gt; &#123; e.preventDefault(); const fruit = this.fruit.current.value; this.props.FruitStore.addFruit(fruit); &#125;; render() &#123; return ( &lt;div&gt; &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;input type="text" placeholder="fruit" ref=&#123;this.fruit&#125; /&gt; &lt;button&gt;添加&lt;/button&gt; &lt;/form&gt; &lt;div&gt; &lt;p&gt; 数据：&#123;this.props.FruitStore.getFruits&#125; &lt;/p&gt; &lt;p&gt; 长度：&#123;this.props.FruitStore.getCount&#125; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125;export default Fruit; 上面导出的另一种写法 1export default inject('FruitStore')(observer(Fruit)); src/App.jsx 1234567891011121314import React, &#123; Component &#125; from 'react';import Fruit from './components/Fruit';class App extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;Fruit/&gt; &lt;/div&gt; ); &#125;&#125;export default App; src/index.js 1234567891011import React from 'react';import ReactDOM from 'react-dom';import App from './App';import stores from './stores';import &#123; configure &#125; from 'mobx';import &#123; Provider &#125; from 'mobx-react';configure(&#123; enforceActions: 'observed' &#125;);ReactDOM.render(&lt;Provider &#123;...stores&#125;&gt; &lt;App/&gt;&lt;/Provider&gt;, document.querySelector('#root')); 如何发起异步请求src/App.jsx 1234567891011121314import React, &#123; Component &#125; from 'react';import Joke from './components/Joke';class App extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;Joke/&gt; &lt;/div&gt; ); &#125;&#125;export default App; src/components/Joke.jsx 12345678910111213141516171819202122232425262728import React, &#123; Component &#125; from "react";import &#123; observer, inject &#125; from "mobx-react";@inject("JokeStore")@observerclass Joke extends Component &#123; renderJokes = () =&gt; &#123; return this.props.JokeStore.jokes.map((item, index) =&gt; &lt;li key=&#123;index&#125;&gt; &#123;item&#125; &lt;/li&gt; ); &#125;; render() &#123; return ( &lt;div&gt; &lt;button onClick=&#123;this.props.JokeStore.fetchJokes&#125;&gt; Get a joke &lt;/button&gt; &lt;ul&gt; &#123;this.renderJokes()&#125; &lt;/ul&gt; &lt;/div&gt; ); &#125;&#125;export default Joke; src/stores/index.js 123456789import FruitStore from './FruitStore';import FriendStore from './FriendStore';import JokeStore from './JokeStore';export default &#123; FruitStore, FriendStore, JokeStore&#125;; src/stores/JokeStore.js 123456789101112131415161718192021import &#123; observable, action, runInAction &#125; from 'mobx';class JokeStore &#123; @observable jokes = []; fetchJokes = () =&gt; &#123; fetch('https://autumnfish.cn/api/joke/list?num=3').then(res =&gt; res.json()).then(data =&gt; &#123; /* runInAction(() =&gt; &#123; this.jokes = data.jokes; &#125;); */ this.saveJokes(data.jokes); &#125;); &#125;; // Modifying the observed data needs to be decorated with action @action saveJokes = data =&gt; &#123; this.jokes = data; &#125;&#125;export default new JokeStore(); async/await 12345678910111213import &#123; observable, runInAction &#125; from 'mobx';class JokeStore &#123; @observable jokes = []; fetchJokes = async () =&gt; &#123; const response = await fetch('https://autumnfish.cn/api/joke/list?num=3'); const json = await response.json(); runInAction(() =&gt; &#123; this.jokes = json.jokes; &#125;); &#125;;&#125;export default new JokeStore(); Generator 1&lt;button onClick=&#123;() =&gt; this.props.JokeStore.fetchJokes()&#125;&gt;Get a joke&lt;/button&gt; 12345678910import &#123; observable, flow &#125; from 'mobx';class JokeStore &#123; @observable jokes = []; fetchJokes = flow(function* () &#123; const response = yield fetch("https://autumnfish.cn/api/joke/list?num=3") const json = yield response.json(); this.jokes = json.jokes; &#125;);&#125;export default new JokeStore(); loading 和 error 处理src/components/Joke.jsx 123456789101112131415161718192021222324252627282930313233343536373839404142import React, &#123; Component &#125; from "react";import &#123; observer, inject &#125; from "mobx-react";@inject("JokeStore")@observerclass Joke extends Component &#123; renderJokes = () =&gt; &#123; const jokes = this.props.JokeStore.jokes; if (!jokes.length) return null; return ( &lt;ul&gt; &#123;jokes.map((item, index) =&gt; &lt;li key=&#123;index&#125;&gt; &#123;item&#125; &lt;/li&gt; )&#125; &lt;/ul&gt; ); &#125;; render() &#123; const JokeStore = this.props.JokeStore; let data = null; if (JokeStore.error) &#123; data = (&lt;div&gt;&#123;JokeStore.error&#125;&lt;/div&gt;); &#125; else if (JokeStore.loading) &#123; data = &lt;div&gt;loading...&lt;/div&gt;; &#125; else &#123; data = this.renderJokes(); &#125; return ( &lt;div&gt; &lt;button onClick=&#123;() =&gt; JokeStore.fetchJokes()&#125;&gt; Get a joke &lt;/button&gt; &#123;data&#125; &lt;/div&gt; ); &#125;&#125;export default Joke; src/stores/JokeStore.js 1234567891011121314151617181920212223import &#123; observable, flow&#125; from 'mobx';class JokeStore &#123; @observable jokes = []; @observable loading = false; // #1 @observable error = null; fetchJokes = flow(function* () &#123; this.loading = true; // #2 this.error = null; try &#123; const response = yield fetch("https://autumnfish.cn/api/joke/list?num=3") const json = yield response.json(); this.jokes = json.jokes; &#125; catch (error) &#123; this.error = error.message; &#125; this.loading = false; // #3 &#125;);&#125;export default new JokeStore(); TodoList1yarn add mobx-react-lite shortid public/index.html 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link href="https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet"&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; src/App.jsx 1234567891011121314import React, &#123; Component &#125; from 'react';import TodoList from './components/TodoList';class App extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;TodoList/&gt; &lt;/div&gt; ); &#125;&#125;export default App; src/index.js 1import 'mobx-react-lite/batchingForReactDom' src/components/Todo.jsx 12345678910111213141516171819import React from "react";import &#123; action &#125; from "mobx";import &#123; observer &#125; from "mobx-react";const Todo = observer((&#123; item &#125;) =&gt; &#123; return ( &lt;li className="list-group-item"&gt; &#123;item.todo&#125; &lt;input className="float-right mt-2" type="checkbox" checked=&#123;item.completed&#125; onChange=&#123;action(() =&gt; (item.completed = !item.completed))&#125; /&gt; &lt;/li&gt; );&#125;);export default Todo; src/components/TodoList.jsx 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import React, &#123; Component &#125; from "react";import &#123; observer, inject &#125; from "mobx-react";import &#123; observable, action &#125; from "mobx";import Todo from "./Todo";@inject("TodoListStore")@observerclass TodoList extends Component &#123; // #1 @observable todo = ""; // #2 // Modify observation data @action handleChagne = e =&gt; &#123; this.todo = e.target.value; &#125;; @action handleKeyUp = e =&gt; &#123; if (e.keyCode === 13) &#123; this.props.TodoListStore.addTodo(this.todo); this.todo = ""; &#125; &#125;; render() &#123; const &#123; todos, getUnCompletedCount &#125; = this.props.TodoListStore; return ( &lt;div className="container"&gt; &lt;input type="text" className="form-control mt-3" placeholder="todo" value=&#123;this.todo&#125; onChange=&#123;this.handleChagne&#125; onKeyUp=&#123;this.handleKeyUp&#125; /&gt; &lt;ul className="list-group mt-3"&gt; &#123;todos.map(item =&gt; &lt;Todo key=&#123;item.id&#125; item=&#123;item&#125; /&gt;)&#125; &lt;/ul&gt; &lt;div&gt; &lt;span className="badge badge-primary"&gt; &#123;getUnCompletedCount&#125; &lt;/span&gt; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125;export default TodoList; 上面 #1、#2 处的代码可以改写如下 123456789constructor(props) &#123; super(props); extendObservable(this, &#123; todo: "", handleChagne: action(e =&gt; &#123; this.todo = e.target.value; &#125;), &#125;);&#125; src/stores/index.js 12import TodoListStore from './TodoListStore';export default &#123; TodoListStore &#125;; src/stores/TodoListStore.js 1234567891011121314151617181920212223import &#123; observable, action, computed &#125; from 'mobx';import shortid from 'shortid';class Todo &#123; id = shortid.generate(); @observable todo; @observable completed = false; constructor(todo) &#123; this.todo = todo; &#125;&#125;class TodoListStore &#123; @observable todos = [new Todo('吃饭')]; @action addTodo = todo =&gt; &#123; this.todos.unshift(new Todo(todo)); &#125;; @computed get getUnCompletedCount() &#123; return this.todos.filter(item =&gt; !item.completed).length; &#125;&#125;const store = new TodoListStore();export default store; 其实上面 TodoList.jsx 中可观测数据以及相关操作都可以提取到 TodoListStore.js 中比较好，可改写代码如下： src/components/TodoList.jsx 1234567891011121314151617181920212223242526272829303132333435363738import React, &#123; Component &#125; from "react";import &#123; observer, inject &#125; from "mobx-react";import Todo from "./Todo";@inject("TodoListStore")@observerclass TodoList extends Component &#123; render() &#123; const &#123; todos, getUnCompletedCount, todo, handleChange, handleKeyUp, &#125; = this.props.TodoListStore; return ( &lt;div className="container"&gt; &lt;input type="text" className="form-control mt-3" placeholder="todo" value=&#123;todo&#125; onChange=&#123;handleChange&#125; onKeyUp=&#123;handleKeyUp&#125; /&gt; &lt;ul className="list-group mt-3"&gt; &#123;todos.map(item =&gt; &lt;Todo key=&#123;item.id&#125; item=&#123;item&#125; /&gt;)&#125; &lt;/ul&gt; &lt;div&gt; &lt;span className="badge badge-primary"&gt; &#123;getUnCompletedCount&#125; &lt;/span&gt; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125;export default TodoList; src/stores/TodoListStore.js 12345678910111213141516171819202122232425262728293031323334353637import &#123; observable, action, computed&#125; from 'mobx';import shortid from 'shortid';class Todo &#123; id = shortid.generate(); @observable todo; @observable completed = false; constructor(todo) &#123; this.todo = todo; &#125;&#125;class TodoListStore &#123; @observable todos = [new Todo('吃饭')]; @observable todo = ""; @action handleChange = e =&gt; &#123; this.todo = e.target.value; &#125; @action handleKeyUp = e =&gt; &#123; if (e.keyCode === 13) &#123; this.todos.unshift(new Todo(this.todo)); this.todo = ""; &#125; &#125; @action addTodo = todo =&gt; &#123; this.todos.unshift(new Todo(todo)); &#125;; @computed get getUnCompletedCount() &#123; return this.todos.filter(item =&gt; !item.completed).length; &#125;&#125;const store = new TodoListStore();export default store;]]></content>
  </entry>
  <entry>
    <title><![CDATA[DvaJS]]></title>
    <url>%2F2020%2F08%2F15%2Fdva%2F</url>
    <content type="text"><![CDATA[快速上手，快速入门，案例代码 案例初探安装 dva 123// 安装 dva-clinpm install dva-cli -gdva -v 创建项目 1234// 创建项目dva new dva-quickstartcd dva-quickstartnpm start 一个警告 index.js:2177 Warning: Please use require(“history”).createHashHistory instead of require(“history/createHashHistory”). Support for the latter will be removed in the next major release. 其实不用管，纠结的话可以修改node_moduels/dva/lib/index.js var _createHashHistory = _interopRequireDefault(require(“history/createHashHistory”)); 1var _createHashHistory = _interopRequireDefault(require("history").createHashHistory); 使用 AntD 1npm install antd babel-plugin-import 123456// 编辑 .webpackrc，使 babel-plugin-import 插件生效&#123; "extraBabelPlugins": [ ["import", &#123; "libraryName": "antd", "libraryDirectory": "es", "style": "css" &#125;] ]&#125; 定义 Products 组件 src/routes/Products.jsx 12345678910111213141516171819202122232425262728293031323334import React, &#123; Component &#125; from "react";import PropTypes from "prop-types";import &#123; Table, Popconfirm, Button &#125; from "antd";class Products extends Component &#123; columns = [ &#123; title: "Name", dataIndex: "name", &#125;, &#123; title: "Actions", render: (text, record) =&gt; &#123; return ( &lt;Popconfirm title="Delete?" onConfirm=&#123;() =&gt; &#123;&#125;&#125; &gt; &lt;Button&gt;Delete&lt;/Button&gt; &lt;/Popconfirm&gt; ); &#125;, &#125;, ]; render() &#123; return &lt;Table dataSource=&#123;this.props.products&#125; columns=&#123;this.columns&#125; /&gt;; &#125;&#125;Products.propTypes = &#123; products: PropTypes.array.isRequired,&#125;;export default Products; 配置路由 src/router.js 123456789101112131415import React from "react";import &#123; Router, Route, Switch &#125; from "dva/router";import Products from "./routes/Products";function RouterConfig(&#123; history &#125;) &#123; return ( &lt;Router history=&#123;history&#125;&gt; &lt;Switch&gt; &lt;Route path="/products" exact component=&#123;Products&#125; /&gt; &lt;/Switch&gt; &lt;/Router&gt; );&#125;export default RouterConfig; 定义 Model src/models/products.js 123456789101112export default &#123; namespace: 'products', state: [ &#123; key: 1, name: '手机', id: 1 &#125;, &#123; key: 2, name: '电脑', id: 2 &#125;, ], reducers: &#123; 'delete'(state, &#123; payload: id &#125;) &#123; return state.filter(item =&gt; item.id !== id); &#125; &#125;&#125; 别忘了在 src/index.js 中载入 model 1app.model(require('./models/products').default); connect src/routes/Products.jsx 123456789101112131415161718192021222324252627282930313233343536373839404142434445import React, &#123; Component &#125; from "react";import PropTypes from "prop-types";import &#123; Table, Popconfirm, Button &#125; from "antd";import &#123; connect &#125; from "dva";class Products extends Component &#123; columns = [ &#123; title: "Name", dataIndex: "name", &#125;, &#123; title: "Actions", render: (text, record) =&gt; &#123; return ( &lt;Popconfirm title="Delete?" onConfirm=&#123;() =&gt; this.handleDelete(record.id)&#125; &gt; &lt;Button&gt;Delete&lt;/Button&gt; &lt;/Popconfirm&gt; ); &#125;, &#125;, ]; // 注意这里加了删除的功能 handleDelete = id =&gt; &#123; this.props.dispatch(&#123; type: "products/delete", payload: id, &#125;); &#125;; render() &#123; return ( &lt;Table dataSource=&#123;this.props.products&#125; columns=&#123;this.columns&#125; /&gt; ); &#125;&#125;Products.propTypes = &#123; products: PropTypes.array.isRequired,&#125;;// const mapStateToProps = state =&gt; (&#123; products: state.products &#125;);export default connect((&#123; products &#125;) =&gt; (&#123; products &#125;))(Products); 使用 BrowserHistory src/index.js 12import &#123; createBrowserHistory as createHistory &#125; from 'history';const app = dva(&#123; history: createHistory() &#125;); 路由跳转标签导航 12import &#123; Link &#125; from 'dva/router';&lt;Link to="/"&gt;Home&lt;/Link&gt; 编程式导航 12// 如果不是直接挂在到 Route 下面的组件，需要用到高阶组件 withRouter&lt;Button type="primary" onClick=&#123;() =&gt; this.props.history.push('/')&#125;&gt;Home&lt;/Button&gt; 12import &#123; routerRedux &#125; from 'dva/router';&lt;Button type="primary" onClick=&#123;() =&gt; this.props.dispatch(routerRedux.push('/'))&#125;&gt;Home&lt;/Button&gt; 数据模拟/mock/products.js 1234567891011const products = [ &#123; key: 1, name: '手机', id: 1 &#125;, &#123; key: 2, name: '电脑', id: 2 &#125;];// 以函数的形式进行，可以做一些更加灵活的处理（也可以直接写一个对象）module.exports = &#123; "GET /api/products": (req, res) =&gt; &#123; res.send(products); &#125;,&#125; /mock/users.js 123456module.exports = &#123; "GET /api/users": [ &#123; name: 'ifer' &#125;, &#123; name: 'elser' &#125;, ]&#125; /.roadhogrc.mock.js 1234export default &#123; ...require("./mock/products"), ...require("./mock/users")&#125;; 1234567891011// 优化import fs from "fs";import path from "path";const mock = &#123;&#125;;fs.readdirSync(path.join(__dirname, "/mock")).forEach(file =&gt; &#123; if (file.match(/\.js$/)) &#123; Object.assign(mock, require("./mock/" + file)); &#125;&#125;);export default mock; /src/services/products.js 123import request from "../utils/request";export const getProducts = () =&gt; request("/api/products"); /src/services/users.js 123import request from "../utils/request";export const getUsers = () =&gt; request("/api/users"); /src/services/index.js 12export * as users from './users';export * as products from './products'; /src/routes/Products.jsx 1234567import &#123; users, products &#125; from '../services';class Products extends Component &#123; componentDidMount() &#123; users.getUsers().then(console.log); products.getProducts().then(console.log); &#125;&#125; 数据交互实现数据的获取、删除 获取数据 src/models/products.js 1234567891011121314151617import &#123; products &#125; from '../services';export default &#123; namespace: 'products', state: [], reducers: &#123; 'init'(state, &#123; payload &#125;) &#123; return [...payload]; &#125; &#125;, effects: &#123; *getProducts(action,&#123; call, put &#125;) &#123; const &#123; data &#125; = yield call(products.getProducts); yield put(&#123; type: 'init', payload: data &#125; ); &#125; &#125;&#125; src/routes/Products.jsx 12345class Products extends Component &#123; componentDidMount() &#123; this.props.dispatch(&#123; type: 'products/getProducts' &#125;); &#125;&#125; 删除数据 src/routes/Products.jsx 123456handleDelete = id =&gt; &#123; this.props.dispatch(&#123; type: "products/deleteProduct", payload: id, &#125;);&#125;; src/models/products.js 1234567891011121314151617import &#123; products &#125; from '../services';export default &#123; namespace: 'products', state: [], reducers: &#123; 'init'(state, &#123; payload &#125;) &#123; return [...payload]; &#125; &#125;, effects: &#123; *deleteProduct(&#123; payload &#125;, &#123; call, put &#125;) &#123; const &#123; data &#125; = yield call(products.deleteProduct, payload); yield put(&#123; type: 'init', payload: data &#125; ); &#125; &#125;&#125; src/services/products.js 1export const deleteProduct = id =&gt; request(`/api/deleteProduct?id=$&#123;id&#125;`); mock/products.js 12345678// 以函数的形式进行，可以做一些更加灵活的处理（也可以直接写一个对象）module.exports = &#123; "GET /api/deleteProduct": (req, res) =&gt; &#123; const idx = products.findIndex(item =&gt; item.id === req.query.id); products.splice(idx, 1); res.send(products); &#125;,&#125; 优化引入 modelssrc/models/index.js 123const context = require.context('./', false, /\.js$/);export default context.keys().filter(item =&gt; item !== './index.js').map(key =&gt; context(key)); src/index.js 1require('./models').default.forEach(key =&gt; app.model(key.default)); redux-actions1yarn add redux-actions src/actions/index.js 1234import &#123; createAction &#125; from 'redux-actions';export const getProducts = createAction('products/getProducts');export const deleteProduct = createAction('products/deleteProduct'); src/routes/Products.jsx 1234567891011121314import &#123; deleteProduct, getProducts &#125; from '../actions';class Products extends Component &#123; handleDelete = id =&gt; &#123; // this.props.dispatch(&#123; // type: "products/deleteProduct", // payload: id, // &#125;); this.props.dispatch(deleteProduct(id)); &#125;; componentDidMount() &#123; // this.props.dispatch(&#123; type: 'products/getProducts' &#125;); this.props.dispatch(getProducts()); &#125;&#125;]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>DvaJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redux-saga]]></title>
    <url>%2F2020%2F08%2F12%2Fsaga%2F</url>
    <content type="text"><![CDATA[redux-saga 通过拦截 action 来执行有副作用的 task，以保持 action 的简洁！ redux-thunk 异步计数器12npx create-react-app sagayarn add redux react-redux redux-thunk src/index.js 123456789101112import React from "react";import ReactDOM from "react-dom";import &#123; Provider &#125; from "react-redux";import store from "./store";import App from "./App";ReactDOM.render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;, document.querySelector("#root")); src/App.jsx 1234567891011import React, &#123; Component &#125; from "react";import Counter from "./pages/counter";export default class App extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;Counter /&gt; &lt;/div&gt; ); &#125;&#125; src/store/reducers.js 12345import &#123; combineReducers &#125; from 'redux';import &#123; reducer as counterReducer &#125; from '../pages/counter/store';export default combineReducers(&#123; counter: counterReducer&#125;); src/store/index.js 1234567891011import &#123; createStore, compose, applyMiddleware &#125; from 'redux';import thunk from 'redux-thunk';import rootReducer from './reducers';const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;// 中间件、createStore、reducer// const store = composeEnhancers(applyMiddleware(thunk))(createStore)(rootReducer);const store = createStore( rootReducer, composeEnhancers(applyMiddleware(thunk)));export default store; src/pages/counter/index.jsx 12345678910111213141516171819202122import React, &#123; Component &#125; from 'react'import &#123; connect &#125; from "react-redux";import &#123; incrementAsync &#125; from './store/actionCreators';class Counter extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;p&gt; &#123;this.props.counter&#125; &lt;/p&gt; &lt;button onClick=&#123;this.props.incrementAsync&#125;&gt;click&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;const mapStateToProps = state =&gt; &#123; return &#123; counter: state.counter, &#125;;&#125;;export default connect(mapStateToProps, &#123; incrementAsync &#125;)(Counter); src/pages/counter/store/index.js 1234567import reducer from './reducer';import * as actionCreators from './actionCreators';export &#123; reducer, actionCreators&#125;; src/pages/counter/store/reducer.js 1234567891011121314import &#123; INCREMENT&#125; from './actionTypes';const counter = (state = 1, action = &#123;&#125;) =&gt; &#123; switch (action.type) &#123; case INCREMENT: return state + 1; default: return state; &#125;&#125;export default counter; src/pages/counter/store/actionCreators.js 12345678910111213import &#123; INCREMENT &#125; from './actionTypes';const increment = () =&gt; (&#123; type: INCREMENT&#125;);export const incrementAsync = () =&gt; &#123; return dispatch =&gt; &#123; setTimeout(() =&gt; &#123; dispatch(increment()); &#125;, 1000); &#125;&#125;; src/pages/counter/store/actionTypes.js 1export const INCREMENT = 'INCREMENT'; redux-thunk异步计数器代码 redux-saga 基础配置1yarn add redux-saga src/store/index.js 12345678910111213141516import &#123; createStore, compose, applyMiddleware &#125; from 'redux';// #1 引入import createSagaMiddleware from 'redux-saga';import rootReducer from './reducers';import &#123; helloSaga &#125; from '../sagas';// #2 创建const sagaMiddleware = createSagaMiddleware();const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;const store = createStore( rootReducer, // #3 应用 composeEnhancers(applyMiddleware(sagaMiddleware)));// #4 启用，相当于执行了 helloSaga 这个 generator 函数，原理 co 库sagaMiddleware.run(helloSaga);export default store; src/sagas/index.js 123export function* helloSaga() &#123; yield console.log('Hello Saga!');&#125; 异步计数器src/pages/counter/index.jsx 123456789101112131415161718192021222324import React, &#123; Component &#125; from 'react'import &#123; connect &#125; from "react-redux";import &#123; incrementAsync &#125; from './store/actionCreators';class Counter extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;p&gt; &#123;this.props.counter&#125; &lt;/p&gt; &#123;/* 这里直接执行的是一个 actionCreator，无需手动进行 dispatch 的操作 */&#125; &#123;/* 这里派发的 action 能被 saga 监听到，然后做对应的处理 */&#125; &lt;button onClick=&#123;this.props.incrementAsync&#125;&gt;click&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;const mapStateToProps = state =&gt; &#123; return &#123; counter: state.counter, &#125;;&#125;;export default connect(mapStateToProps, &#123; incrementAsync &#125;)(Counter); src/pages/counter/store/actionCreators.js 123456789import &#123; INCREMENT, INCREMENT_ASYNC &#125; from './actionTypes';export const increment = () =&gt; (&#123; type: INCREMENT&#125;);export const incrementAsync = () =&gt; (&#123; type: INCREMENT_ASYNC&#125;); src/sagas/index.js 12345678910111213141516171819import &#123; takeEvery, delay, put &#125; from 'redux-saga/effects';import &#123; increment &#125; from '../pages/counter/store/actionCreators';import &#123; INCREMENT_ASYNC &#125; from '../pages/counter/store/actionTypes';export function* helloSaga() &#123; yield console.log('Hello Saga!');&#125;// #2 异步代码function* incrementAsync() &#123; yield delay(2000); yield put(increment());&#125;// #3 注意不要忘了在外部 run watchIncrementAsyncexport function* watchIncrementAsync() &#123; // #1 监听 action，触发 incrementAsync 函数 yield takeEvery(INCREMENT_ASYNC, incrementAsync);&#125; 代码 如何组织 saga当有多个 Saga 时如何同时运行呢，下面为了演示又增加了 &lt;User/&gt; 组件 src/pages/user/index.jsx 123456789101112131415import React, &#123; Component &#125; from 'react'import &#123; connect &#125; from 'react-redux';import &#123; fetchUser &#125; from './store/actionCreators';class User extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;button onClick=&#123;this.props.fetchUser&#125;&gt;获取数据&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;export default connect(null, &#123; fetchUser &#125;)(User); src/App.jsx 12345678910111213import React, &#123; Component &#125; from "react";import Counter from "./pages/counter";import User from "./pages/user";export default class App extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;Counter /&gt; &lt;User /&gt; &lt;/div&gt; ); &#125;&#125; src/pages/user/store/actionCreators.js 123456import &#123; FETCH_USER &#125; from './actionTypes';export const fetchUser = () =&gt; &#123; return &#123; type: FETCH_USER &#125;;&#125; src/pages/user/store/actionTypes.js 1export const FETCH_USER = 'FETCH_USER'; src/sagas/index.js 123456789101112131415161718192021import &#123; takeEvery, delay, put, call &#125; from 'redux-saga/effects';import axios from 'axios';import &#123; increment &#125; from '../pages/counter/store/actionCreators';import &#123; INCREMENT_ASYNC &#125; from '../pages/counter/store/actionTypes';import &#123; FETCH_USER &#125; from "../pages/user/store/actionTypes";function* incrementAsync() &#123; yield delay(2000); yield put(increment());&#125;function* fetchUser() &#123; const user = yield call(axios.get, "https://api.github.com/users"); console.log(user);&#125;export default function* rootSaga() &#123; // 你会发现 10s 之内点击按钮或请求数据无效，因为这里是串行的 yield delay(10000); yield takeEvery(INCREMENT_ASYNC, incrementAsync); yield takeEvery(FETCH_USER, fetchUser);&#125; 利用 all123456789101112131415161718192021222324// #1 worker sagafunction* incrementAsync() &#123; yield delay(2000); yield put(increment());&#125;function* fetchUser() &#123; const user = yield call(axios.get, "https://api.github.com/users"); console.log(user);&#125;// #2 watcher sagafunction* watchIncrementAsync() &#123; yield takeEvery(INCREMENT_ASYNC, incrementAsync);&#125;function* watchFetchUser() &#123; yield takeEvery(FETCH_USER, fetchUser);&#125;// #3 root sagaexport default function* rootSaga() &#123; yield all([ watchIncrementAsync(), watchFetchUser() ]);&#125; 拆分不同的文件src/sagas/counter.js 1234567891011import &#123; takeEvery, delay, put &#125; from 'redux-saga/effects';import &#123; increment &#125; from '../pages/counter/store/actionCreators';import &#123; INCREMENT_ASYNC &#125; from '../pages/counter/store/actionTypes';function* incrementAsync() &#123; yield delay(2000); yield put(increment());&#125;export function* watchIncrementAsync() &#123; yield takeEvery(INCREMENT_ASYNC, incrementAsync);&#125; src/sagas/user.js 1234567891011import axios from 'axios';import &#123; takeEvery, call &#125; from 'redux-saga/effects';import &#123; FETCH_USER &#125; from "../pages/user/store/actionTypes";function* fetchUser() &#123; const user = yield call(axios.get, "https://autumnfish.cn/api/joke"); console.log(user);&#125;export function* watchFetchUser() &#123; yield takeEvery(FETCH_USER, fetchUser);&#125; src/sagas/index.js 123456789101112131415161718192021import &#123; all, fork &#125; from "redux-saga/effects";import * as counterSagas from './counter';import * as userSagas from './user';export default function* rootSaga() &#123; // #1 需要自己执行每一个 watch saga /* yield all([ counterSagas.watchIncrementAsync(), userSagas.watchFetchUser(), ]); */ // #2 可以利用 fork 帮我们执行 watch saga /* yield all([ fork(counterSagas.watchIncrementAsync), fork(userSagas.watchFetchUser), ]); */ // #3 优化优化 yield all([ ...Object.values(userSagas), ...Object.values(counterSagas) ].map(fork));&#125; 每个文件组织好后再导出src/sagas/counter.js 123456789101112131415import &#123; takeEvery, delay, put &#125; from 'redux-saga/effects';import &#123; increment &#125; from '../pages/counter/store/actionCreators';import &#123; INCREMENT_ASYNC &#125; from '../pages/counter/store/actionTypes';function* incrementAsync() &#123; yield delay(2000); yield put(increment());&#125;function* watchIncrementAsync() &#123; yield takeEvery(INCREMENT_ASYNC, incrementAsync);&#125;export const counterSagas = [ watchIncrementAsync();]; src/sagas/user.js 12345678910111213import &#123; takeEvery, call &#125; from 'redux-saga/effects';import axios from 'axios';import &#123; FETCH_USER &#125; from "../pages/user/store/actionTypes";function* fetchUser() &#123; const user = yield call(axios.get, "https://autumnfish.cn/api/joke"); console.log(user);&#125;function* watchFetchUser() &#123; yield takeEvery(FETCH_USER, fetchUser);&#125;export const userSagas = [ watchFetchUser();] src/sagas/index.js 12345678910import &#123; all &#125; from "redux-saga/effects";import &#123; counterSagas &#125; from './counter';import &#123; userSagas &#125; from './user';export default function* rootSaga() &#123; yield all([ ...counterSagas, ...userSagas ]);&#125; 单元测试1yarn add @babel/core @babel/node @babel/plugin-transform-modules-commonjs tape 12345&#123; "scripts": &#123; "test": "babel-node src/sagas/counter.test.js --plugins @babel/plugin-transform-modules-commonjs", &#125;,&#125; src/sagas/counter.js 12345// 这里需要导出，用于单元测试export function* incrementAsync() &#123; yield delay(2000); yield put(increment());&#125; src/sagas/sagas/counter.test.js 1234567891011121314151617181920import test from 'tape';import &#123; delay, put &#125; from 'redux-saga/effects';import &#123; incrementAsync &#125; from './counter';import &#123; increment &#125; from '../pages/counter/store/actionCreators';test('incrementAsync saga test', function(assert) &#123; const it = incrementAsync(); // yield 什么，这里的 it.next().value 就是什么 assert.deepEqual( it.next().value, delay(2000), "A promise with a delay of 2 s should be returned" ); assert.deepEqual( it.next().value, put(increment()), "An increase action should be initiated" ); assert.end();&#125;); 1npm test take 和 selecttake 1234567891011export function* incrementAsync() &#123; yield delay(2000); yield put(increment());&#125;function* watchIncrementAsync() &#123; // yield takeEvery(INCREMENT_ASYNC, incrementAsync); // 只会箭头触发的第一次 action const action = yield take(INCREMENT_ASYNC); console.log(action); // &#123;type: "INCREMENT_ASYNC"&#125; yield incrementAsync();&#125; 12345678910111213141516// 触发 2 次export function* incrementAsync() &#123; yield delay(2000); yield put(increment());&#125;function* watchIncrementAsync() &#123; // yield take(INCREMENT_ASYNC); // yield incrementAsync(); // yield take(INCREMENT_ASYNC); // yield incrementAsync(); for(let i = 0; i &lt; 2; i ++) &#123; yield take(INCREMENT_ASYNC); yield incrementAsync(); &#125; console.log('会执行 2 次');&#125; 1234567// 模拟 takeEveryfunction* watchIncrementAsync() &#123; while(true) &#123; yield take(INCREMENT_ASYNC); yield incrementAsync(); &#125;&#125; takeEvery 1234export function* watchIncrementAsync() &#123; // takeEvery 会监听每一次 action yield takeEvery(INCREMENT_ASYNC, incrementAsync);&#125; takeLatest 1234export function* watchIncrementAsync() &#123; // takeLatest 会以最后一次 action 为准 yield takeLatest(INCREMENT_ASYNC, incrementAsync);&#125; select 123456789function* watchAll() &#123; while(true) &#123; // 监听所有的 action，获取最新的状态树 console.log(yield take('*')); console.log(yield select()); // 也可以传递函数对状态进行过滤 // console.log(yield select(state =&gt; state.counter)); &#125;&#125; call/apply 和 cps都可以调用方法并传递参数，以及改变方法中的 this 指向 12345678export function* incrementAsync() &#123; // delay 函数中的 this 就是 o，注意 delay 不能是一个箭头函数 const o = &#123; name: 'ifer' &#125;; yield call([o, delay], 2000); // 同样 apply 也可以调用函数，参数分别是this、函数、参数 // yield apply(o, delay, [2000]); yield put(increment());&#125; 1234567// delay 是自己封装的，不是 saga 提供的，注意用到 this 的话这里的 delay 不能是一个箭头函数const delay = function (ms) &#123; return new Promise(resolve =&gt; &#123; console.log(this); setTimeout(resolve, ms); &#125;);&#125; cps 12345678910// Node style function的方式调用 fnconst getCon = function(type, callback) &#123; setTimeout(() =&gt; &#123; callback(null, type + ' hello world'); &#125;, 1000);&#125;;// call 只能用于调用返回 Promise 的方法，cps 可以等待回调的返回结果let con = yield cps(getCon, 'xxx');console.log(con) all 和 raceall 1234567// 可以并行执行任务function* incrementAsync() &#123; yield all([ delay(2000), put(increment()) ]);&#125; 一般用于组织多个 Saga，并行执行，作为 rootSaga 统一导出 123456export default function* rootSaga() &#123; yield all([ watchIncrementAsync(), watchFetchUser() ]);&#125; 12345678// 也可以这样使用function* fetchJoke() &#123; const [data1, data2] = yield all([ call(axios.get, "https://autumnfish.cn/api/joke"), call(axios.get, "https://autumnfish.cn/api/joke/list?num=3") ]); console.log(data1, data2);&#125; race 12345678// 期望同时启动多个任务，只希望拿到胜利者：第一个被 resolve（或 reject）的任务function* raceTask() &#123; const &#123;a, b&#125; = yield race(&#123; a: delay(1000), b: delay(500) &#125;); console.log(a, b); // undefined true&#125; loading 和错误处理src/pages/user/index.jsx 123456789101112131415161718192021222324252627282930313233import React, &#123; Component &#125; from 'react'import &#123; connect &#125; from 'react-redux';import &#123; fetchUser &#125; from './store/actionCreators';class User extends Component &#123; render() &#123; const &#123; isFetching, error, user &#125; = this.props.user; let data = null; if(error) &#123; data = error; &#125; else if(isFetching) &#123; data = "Loading..."; &#125; else &#123; data = user &amp;&amp; &lt;ul&gt;&#123; user.jokes.map((item,index) =&gt; &lt;li key=&#123;index&#125;&gt;&#123;item&#125;&lt;/li&gt;) &#125;&lt;/ul&gt;; &#125; return ( &lt;div&gt; &lt;div&gt;&#123;data&#125;&lt;/div&gt; &lt;button onClick=&#123;this.props.fetchUser&#125;&gt;获取数据&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;const mapStateToProps = state =&gt; &#123; return &#123; user: state.user &#125;;&#125;;export default connect(mapStateToProps, &#123; fetchUser &#125;)(User); src/pages/user/store/index.js 12import reducer from './reducer';export &#123; reducer &#125;; src/pages/user/store/reducer.js 123456789101112131415161718192021222324252627282930import &#123; FETCH_USER, FETCH_USER_SUCCESS, FETCH_USER_FAILURE &#125; from './actionTypes';const initialState = &#123; isFetching: false, error: null, user: null&#125;;export default function(state=initialState, action) &#123; switch(action.type) &#123; case FETCH_USER: return &#123; isFetching: true, error: null, user: null &#125;; case FETCH_USER_SUCCESS: return &#123; isFetching: false, error: null, user: action.payload &#125;; case FETCH_USER_FAILURE: return &#123; isFetching: false, error: action.error, user: null &#125;; default: return state; &#125;&#125; src/pages/user/store/actionTypes.js 123export const FETCH_USER = 'FETCH_USER';export const FETCH_USER_SUCCESS = 'FETCH_USER_SUCCESS';export const FETCH_USER_FAILURE = 'FETCH_USER_FAILURE'; src/sagas/user.js 12345678910111213141516171819import &#123; takeEvery, call, put &#125; from 'redux-saga/effects';import axios from 'axios';import &#123; FETCH_USER, FETCH_USER_SUCCESS, FETCH_USER_FAILURE &#125; from "../pages/user/store/actionTypes";// #1 失败了，后台返回对应的 HTTP Code，前端针对状态码处理// #2 无论成功或失败，后端 HTTP Code 都响应 200，然后提供不同的 status 标识符，前端据此进行判断function* fetchUser() &#123; try &#123; const &#123; data &#125; = yield call(axios.get, "https://autumnfish.cn/api/joke/list?num=3"); yield put(&#123; type: FETCH_USER_SUCCESS, payload: data &#125;); &#125; catch(e) &#123; yield put(&#123; type: FETCH_USER_FAILURE, error: e.message &#125;); &#125;&#125;function* watchFetchUser() &#123; yield takeEvery(FETCH_USER, fetchUser);&#125;export const userSagas = [ watchFetchUser()]; src/store/reducers.js 1234567import &#123; combineReducers &#125; from 'redux';import &#123; reducer as counterReducer &#125; from '../pages/counter/store';import &#123; reducer as userReducer &#125; from '../pages/user/store';export default combineReducers(&#123; counter: counterReducer, user: userReducer&#125;); 代码 登录流程redux-saga 配置和登录界面1npx create-react-app saga-login 1yarn add redux react-redux redux-saga src/index.js 1234567import React from 'react';import ReactDOM from 'react-dom';import &#123; Provider &#125; from 'react-redux';import App from './App';import store from './store';ReactDOM.render(&lt;Provider store=&#123;store&#125;&gt;&lt;App/&gt;&lt;/Provider&gt;, document.querySelector('#root')); src/App.jsx 123456789101112import React, &#123; Component &#125; from 'react'import Login from './pages/login';export default class App extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;Login/&gt; &lt;/div&gt; ) &#125;&#125; src/store/index.js 123456789101112import &#123; createStore, compose, applyMiddleware &#125; from 'redux';import createSagaMiddleware from 'redux-saga'; // #1import rootReducer from './reducers';import rootSaga from '../sagas';const sagaMiddleware = createSagaMiddleware(); // #2const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;const store = createStore( rootReducer, composeEnhancers(applyMiddleware(sagaMiddleware)) // #3);sagaMiddleware.run(rootSaga); // #4export default store; src/store/reducers/index.js 123456import &#123; combineReducers &#125; from 'redux';import loginReducer from './login';export default combineReducers(&#123; login: loginReducer&#125;); src/store/reducers/login.js 1234const initState = &#123;&#125;;export default function(state=initState, action) &#123; return state;&#125; src/sagas/index.js 12345678import &#123; all &#125; from "redux-saga/effects";import loginSagas from './login';export default function* rootSaga() &#123; yield all([ ...loginSagas, ]);&#125; src/sagas/login.js 1234567export function* login() &#123; yield console.log('hello saga');&#125;export default [ login()]; src/pages/login/index.jsx 12345678910111213141516171819202122232425262728293031323334import React, &#123; Component &#125; from 'react'import &#123; connect &#125; from 'react-redux';class Login extends Component &#123; renderLogin = () =&gt; &#123; return &lt;&gt; &lt;input type="text" placeholder="输入用户名"/&gt; &lt;input type="text" placeholder="输入密码"/&gt; &lt;button&gt;登录&lt;/button&gt; &lt;/&gt;; &#125; renderLogout = () =&gt; &#123; return &lt;button&gt;退出&lt;/button&gt;; &#125; render() &#123; const &#123; token &#125; = this.props.loginData; return ( &lt;div&gt; &#123; token ? this.renderLogout() : this.renderLogin() &#125; &lt;/div&gt; ) &#125;&#125;const mapStateToProps = state =&gt; (&#123; loginData: state.login&#125;);export default connect(mapStateToProps, null)(Login); 登录功能src/pages/login/index.jsx 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import React, &#123; Component &#125; from 'react'import &#123; connect &#125; from 'react-redux';import * as loginAction from '../../store/action/login';class Login extends Component &#123; state = &#123; userInfo: &#123; username: "", password: "" &#125; &#125; handleChange = e =&gt; &#123; this.setState(&#123; userInfo: &#123; ...this.state.userInfo, [e.target.name]: e.target.value &#125; &#125;); &#125; renderLogin = () =&gt; &#123; const &#123; username, password &#125; = this.state.userInfo; return &lt;&gt; &lt;input type="text" name="username" value=&#123;username&#125; placeholder="输入用户名" onChange=&#123;this.handleChange&#125;/&gt; &lt;input type="text" name="password" value=&#123;password&#125; placeholder="输入密码" onChange=&#123;this.handleChange&#125;/&gt; &lt;button onClick=&#123;() =&gt; this.props.login(this.state.userInfo)&#125;&gt;登录&lt;/button&gt; &lt;/&gt;; &#125; renderLogout = () =&gt; &#123; return &lt;button onClick=&#123;this.props.logout&#125;&gt;退出&lt;/button&gt;; &#125; render() &#123; const &#123; token, isFetching, error &#125; = this.props.loginData; let data = null; if(error) &#123; data = error; &#125; else if(isFetching) &#123; data = 'loading...'; &#125; else &#123; data = token; &#125; return ( &lt;div&gt; &lt;p&gt;&#123;data&#125;&lt;/p&gt; &#123; token ? this.renderLogout() : this.renderLogin() &#125; &lt;/div&gt; ) &#125;&#125;const mapStateToProps = state =&gt; (&#123; loginData: state.login&#125;);export default connect(mapStateToProps, loginAction)(Login); src/sagas/login.js 1234567891011121314151617181920212223import &#123; takeEvery, call, put &#125; from 'redux-saga/effects';import * as loginAT from '../store/constant/login';import API from '../utils/api';// #2 worker sagafunction* login(action) &#123; try &#123; const &#123; username, password &#125; = action.payload; const res = yield call(API.login, username, password); yield put(&#123; type: loginAT.LOGIN_SUCCESS, payload: res&#125;); &#125; catch(error) &#123; yield put(&#123; type: loginAT.LOGIN_FAILED, error&#125;); &#125;&#125;// #1 watcher sagafunction* watchLogin() &#123; yield takeEvery(loginAT.LOGIN, login);&#125;export default [ watchLogin()]; src/store/action/login.js 1234567891011121314import * as loginAT from '../constant/login';export const login = payload =&gt; &#123; return &#123; type: loginAT.LOGIN, payload &#125;;&#125;;export const logout = () =&gt; &#123; return &#123; type: loginAT.LOGOUT &#125;&#125;; src/store/constant/login.js 1234export const LOGIN = 'LOGIN';export const LOGOUT = 'LOGOUT';export const LOGIN_SUCCESS = 'LOGIN_SUCCESS';export const LOGIN_FAILED = 'LOGIN_FAILED'; src/store/reducers/login.js 1234567891011121314151617181920212223242526import * as loginAT from '../constant/login';const initState = &#123; // isFetching: false, // error: null, // token: null&#125;;export default function(state=initState, action) &#123; switch(action.type) &#123; case loginAT.LOGIN: return &#123; isFetching: true, &#125;; case loginAT.LOGIN_SUCCESS: return &#123; token: action.payload, isFetching: false &#125;; case loginAT.LOGIN_FAILED: return &#123; error: action.error, isFetching: false &#125;; default: return state; &#125;&#125; src/utils/api.js 12345678910111213const login = (username, password) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; if (username === 'ifer' &amp;&amp; password === '123') &#123; resolve('login success'); &#125; else &#123; reject('login error'); &#125; &#125;, 1000); &#125;);&#125;export default &#123; login &#125;; 退出功能src/sagas/login.js 12345678910function *logout() &#123; yield put(&#123; type: loginAT.LOGOUT_SUCCESS &#125;);&#125;function* watchLogout() &#123; yield takeEvery(loginAT.LOGOUT, logout);&#125;export default [ watchLogin(), watchLogout()]; src/store/constant/login.js 1export const LOGOUT_SUCCESS = 'LOGOUT_SUCCESS'; src/store/reducers/login.js 12345678export default function(state=initState, action) &#123; switch(action.type) &#123; case loginAT.LOGOUT_SUCCESS: return &#123;&#125;; default: return state; &#125;&#125; 如何取消登录src/pages/login/index.jsx 1&lt;button onClick=&#123;this.props.cancelLogin&#125;&gt;取消登录&lt;/button&gt; src/sagas/login.js 123456789101112131415161718192021222324252627282930313233343536373839404142import &#123; takeEvery, call, put, cancel, fork &#125; from 'redux-saga/effects';import * as loginAT from '../store/constant/login';import API from '../utils/api';// #2 worker sagafunction* login(action) &#123; try &#123; const &#123; username, password &#125; = action.payload; const res = yield call(API.login, username, password); yield put(&#123; type: loginAT.LOGIN_SUCCESS, payload: res&#125;); &#125; catch(error) &#123; yield put(&#123; type: loginAT.LOGIN_FAILED, error&#125;); &#125; finally &#123; // 解决取消登录时一直显示 loading... yield put(&#123; type: loginAT.FETCH_DONE &#125;); &#125;&#125;// #1 watcher sagafunction* watchLogin() &#123; yield takeEvery(loginAT.LOGIN, function*(action) &#123; // fork 也能执行 login，返回一个任务对象 const task = yield fork(login, action); yield takeEvery(loginAT.LOGIN_CANCEL, function*() &#123; // LOGIN_CANCEL 时 reducer 不需要执行退出操作，这里只是取消登录 yield cancel(task); &#125;); &#125;);&#125;function *logout() &#123; yield put(&#123; type: loginAT.LOGOUT_SUCCESS &#125;);&#125;function* watchLogout() &#123; yield takeEvery(loginAT.LOGOUT, logout);&#125;export default [ watchLogin(), watchLogout()]; src/store/action/login.js 123export const cancelLogin = () =&gt; (&#123; type: loginAT.LOGIN_CANCEL&#125;); src/store/constant/login.js 123456789export const LOGIN = 'LOGIN';export const LOGIN_SUCCESS = 'LOGIN_SUCCESS';export const LOGIN_FAILED = 'LOGIN_FAILED';export const LOGIN_CANCEL = 'LOGIN_CANCEL';export const LOGOUT = 'LOGOUT';export const LOGOUT_SUCCESS = 'LOGOUT_SUCCESS';export const FETCH_DONE = 'FETCH_DONE'; src/store/reducers/login.js 12345678910export default function(state=initState, action) &#123; switch(action.type) &#123; case loginAT.FETCH_DONE: // 把之前登录成功的数据收集下 return &#123; ...state, isFetching: false &#125;; &#125;&#125;]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>redux-saga</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据处理]]></title>
    <url>%2F2020%2F07%2F31%2Fdata-handling%2F</url>
    <content type="text"><![CDATA[后端响应的数据多数情况下是需要处理成符合自己需要的格式才能使用，这就是新手面临的第一个问题，数据处理！ Array.prototype.reduce 原理及应用基本语法_.add(array) 12const arr = [1, 2, 3];const result = arr.reduce((acc, cur, curIdx, arr) =&gt; acc + cur, init); 注意：acc 初始累积值，要么是 init，要么是数组中索引为 0 的那一项，cur 同理！详见 MDN 原理分析123456789101112Array.prototype.reduce = Array.prototype.reduce || function (cb, init) &#123; let startIdx = 0; if (typeof init === 'undefined') &#123; // 没提供初始值，就把 0 个当做初始值，从第 1 个开始循环 init = this[0]; startIdx = 1; &#125; for (startIdx; startIdx &lt; this.length; startIdx++) &#123; init = cb(init, this[startIdx], startIdx, this); &#125; return init;&#125;; Array.prototype.reduce 举例数组转对象1把 [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] 转成 { a: { b: { c: {} } } } 的形式 12const arr = ['a', 'b', 'c'];const format = arr.reverse().reduce((accVal, curVal) =&gt; (&#123;[curVal]: accVal&#125;), &#123;&#125;); 123456789101112Array.prototype.reduceRight2 = function (cb, init) &#123; let startIdx = this.length - 1; if (typeof init === 'undefined') &#123; // 没提供初始值，就把 【最后一项】 个当做初始值，从 【倒数第二项】 开始循环 init = this[startIdx]; startIdx = this.length - 2; &#125; for (startIdx; startIdx &gt;= 0; startIdx--) &#123; init = cb(init, this[startIdx], startIdx, this); &#125; return init;&#125;; 1const format = arr.reduceRight((accVal, curVal) =&gt; (&#123;[curVal]: accVal&#125;), &#123;&#125;); 数组转对象2数组转对象，把 id 当做 key，使用 lodash 的 _.keyBy() 12345const userList = [ &#123; id: 1, username: 'ifer', email: 'ifer@gmail.com' &#125;, &#123; id: 2, username: 'elser', email: 'elser@gmail.com' &#125;, &#123; id: 3, username: 'for', email: 'for@gmail.com' &#125;]; 1234567891011// 分析错误写法const r = userList.reduce((acc, cur, curIndex, arr) =&gt; &#123; return &#123; [acc.id]: acc &#125;;&#125;);const r = &#123; 'undefined': &#123; 1: &#123; id: 1, username: 'ifer', email: 'ifer@gmail.com' &#125; &#125;&#125;; 123// 每次的 return 值也会累计到 acc 上面，每次的累计值是一个对象，需要解构// acc 是一个对象，一般情况下，不会让它作为一个 key 存在userList.reduce((acc, cur, curIndex, origin) =&gt; (&#123; ...acc, [cur['id']]: cur &#125;), &#123;&#125;); 12345// 思路：实际上咱们知道最终的计算结果都会累计到 acc 上面userList.reduce((acc, cur, curIndex) =&gt; &#123; acc[cur['id']] = cur; return acc;&#125;, &#123;&#125;); 拆分大数组123456const arr = [ '留蕴，犁白萱，之怜翠，张莹莹，杭专，势飞语，碧鲁彗', '崔宏，旷候，涵宗玛，丽恭义，郁畅畅，欧阳姣丽，晁天青', '果芷容，左丘山雁，乘雨文，佟梦菲，叶建华，源逸馨，鲁才', '滕思，於晴雪，厍涵衍，贝勇毅，南宫格，管诗珊，郯姝美']; 1arr.reduce((acc, cur, curIndex, origin) =&gt; acc.concat(cur.split('，')), []); Polyfill需求：实现 forEach、filter、map、some、every 的 Polyfill 123456// forEachArray.prototype.forEach = Array.prototype.forEach || function (fn, _this) &#123; for (let i = 0; i &lt; this.length; i++) &#123; fn.call(_this, this[i], i, this); &#125;&#125; 树形菜单数据 基本操作1234567891011// 基本操作const render = (datas) =&gt; &#123; let str = ''; datas.forEach(item =&gt; &#123; str += `&lt;li&gt;&lt;span&gt;$&#123;item.name&#125;&lt;/span&gt;`; if (Array.isArray(item.children)) &#123; str += `&lt;ul&gt;$&#123;render(item.children)&#125;&lt;/ul&gt;&lt;/li&gt;`; &#125; &#125;); return str;&#125; 12345678// 优雅优雅const render = (datas) =&gt; datas.map(item =&gt; &#123; let str = `&lt;li&gt;&lt;span&gt;$&#123;item.name&#125;&lt;/span&gt;`; if (Array.isArray(item.children)) &#123; str += `&lt;ul&gt;$&#123;render(item.children)&#125;&lt;/ul&gt;&lt;/li&gt;`; &#125; return str;&#125;).join(''); 查找数据1234567891011// 基本操作let r = null;const findItem = (datas, id) =&gt; &#123; datas.forEach(item =&gt; &#123; if (item.id === id) &#123; r = item; &#125; else if (Array.isArray(item.children)) &#123; findItem(item.children, id); &#125; &#125;);&#125;; 123456789101112// 优化优化let r = null;const findItem = (datas, id) =&gt; &#123; datas.some(item =&gt; &#123; if (item.id === id) &#123; return r = item; &#125; else if (Array.isArray(item.children)) &#123; return findItem(item.children, id); &#125; &#125;); return r;&#125;; 扁平化当数组中的对象的 value 也是数组的时候，原生的 flat 并不起作用 12345678910let arr = [];function flat(datas) &#123; datas.forEach(item =&gt; &#123; arr.push(item); if (Array.isArray(item.children)) &#123; flat(item.children); &#125; &#125;); return arr;&#125; 1234567891011function flat(datas) &#123; let arr = []; datas.forEach(item =&gt; &#123; arr.push(item); if (Array.isArray(item.children)) &#123; // arr.push(...flat(item.children)); arr = arr.concat(flat(item.children)); &#125; &#125;); return arr;&#125; 123456// 递归 + reducefunction flat(datas) &#123; return datas.reduce((acc, cur, curIndex) =&gt; &#123; return acc.concat(cur, Array.isArray(cur.children) ? flat(cur.children) : []); &#125;, []);&#125; 12345678910// 精简演示const datas = [&#123; id: 1, children: [&#123; id: 2, children: [&#123; id: 3 &#125;] &#125;]&#125;]; 思考？？ 数据关联123456789101112131415161718192021// 原始数据const arr = [ &#123; id: 1, category: '英语学习', parentId: null &#125;, &#123; id: 11, category: '实用英语', parentId: 1 &#125;, &#123; id: 12, category: '英语基础', parentId: 1 &#125;, &#123; id: 2, category: '职业考试', parentId: null &#125;, &#123; id: 21, category: '小学', parentId: 2 &#125;, &#123; id: 22, category: '初中', parentId: 2 &#125;]; 123456789101112131415161718192021// 需要结果let r = [ &#123; "id": 1, "category": "英语学习", "parentId": null, "subCategories": [ &#123; "id": 12, "category": "英语基础", "parentId": 1 &#125;, &#123; "id": 11, "category": "实用英语", "parentId": 1 &#125; ] &#125;, &#123; "id": 2, "category": "职业考试", "parentId": null, "subCategories": [ &#123; "id": 22, "category": "初中", "parentId": 2 &#125;, &#123; "id": 21, "category": "小学", "parentId": 2 &#125; ] &#125;]; 12345678910111213// 先用当前父 id 逐项往后比较 parentIdfor (let i = 0; i &lt; arr.length; i++) &#123; for (let j = i + 1; j &lt; arr.length; j++) &#123; if (arr[j].parentId &amp;&amp; arr[i].id === arr[j].parentId) &#123; if (arr[i].sub) &#123; arr[i].sub.push(arr.splice(j, 1)[0]) &#125; else &#123; arr[i].sub = [arr.splice(j, 1)[0]]; &#125; j--; &#125; &#125;&#125; 1234567891011121314// 确定父亲找儿子~~~for (let i = 0; i &lt; arr.length; i++) &#123; if (!arr[i].parentId) &#123; let idx = arr.findIndex(item =&gt; arr[i].id === item.parentId); if (idx !== -1) &#123; if (arr[i].sub) &#123; arr[i].sub.push(arr.splice(idx, 1)[0]); &#125; else &#123; arr[i].sub = arr.splice(idx, 1); &#125; i--; &#125; &#125;&#125; 12345678910111213// 确定儿子找父亲for (let i = arr.length - 1; i &gt;= 0; i--) &#123; if (arr[i].parentId) &#123; let idx = arr.findIndex(item =&gt; item.id === arr[i].parentId); if (idx) &#123; if (arr[idx]['subCategories']) &#123; arr[idx]['subCategories'].push(...arr.splice(i, 1)); &#125; else &#123; arr[idx]['subCategories'] = arr.splice(i, 1); &#125; &#125; &#125;&#125; 数据筛选需求：取出相同 rate 的 key 作为数组放进一个大数组中；输出结果为：[[&quot;a&quot;, &quot;c&quot;], [&quot;d&quot;, &quot;e&quot;, &quot;f&quot;]] 123456789const r = [ &#123; key: "a", rate: 0.1 &#125;, &#123; key: "b", rate: 0.2 &#125;, &#123; key: "c", rate: 0.1 &#125;, &#123; key: "d", rate: 0.3 &#125;, &#123; key: "e", rate: 0.3 &#125;, &#123; key: "f", rate: 0.3 &#125;, &#123; key: "g", rate: 0.4 &#125;,]; 1234567891011121314// 错误写法let arr = [];for (let i = 0; i &lt; r.length; i++) &#123; let temp = []; for (let j = i + 1; j &lt; r.length; j++) &#123; if (r[i].rate === r[j].rate) &#123; // 会有重复的，因为没有删除 temp.push(r[j].key); &#125; &#125; temp.unshift(r[i].key); arr.push(temp);&#125;console.log(arr); 123456789101112131415161718// 逐个比较，结合 spliceconst all = [];for (let i = 0; i &lt; r.length; i++) &#123; const arr = []; let bBar = false; for (let j = i + 1; j &lt; r.length; j++) &#123; if (r[i].rate === r[j].rate) &#123; bBar = true; arr.push(r.splice(j, 1)[0]['key']); j--; &#125; &#125; if (bBar) &#123; arr.unshift(r[i]['key']); all.push(arr); &#125;&#125;console.log(all); 12345678910let json = &#123;&#125;;for (let i = 0; i &lt; arr.length; i++) &#123; if (!json[arr[i]['rate']]) &#123; json[arr[i]['rate']] = [arr[i]['key']]; &#125; else &#123; json[arr[i]['rate']].push(arr[i]['key']); &#125;&#125;let r = Object.values(json).filter(item =&gt; item.length &gt; 1);console.log(r); 类似技巧举例 1// 找出字符串 &apos;85872637471533203552943982&apos; 中出现次数最多的数字及次数]]></content>
      <categories>
        <category>JS 高级</category>
      </categories>
      <tags>
        <tag>数据处理</tag>
        <tag>Array.prototype.reduce</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gulp]]></title>
    <url>%2F2020%2F04%2F24%2Fgulp%2F</url>
    <content type="text"><![CDATA[基本使用12npm init -ynpm i gulp -D 123456789// 创建入口文件：code gulpfile.jsexports.foo = done =&gt; &#123; console.log('hello world'); done(); // 标记当前任务已完成&#125;;exports.default = done =&gt; &#123; console.log('hello default'); done();&#125;; 12npx gulp foonpx gulp // 会自动运行 default 任务 组合任务串行任务：一个接一个执行 12345678910111213141516171819202122const &#123; series, parallel &#125; = require('gulp');const task1 = done =&gt; &#123; setTimeout(() =&gt; &#123; console.log('task1~'); done(); &#125;, 1000);&#125;;const task2 = done =&gt; &#123; setTimeout(() =&gt; &#123; console.log('task2~'); done(); &#125;, 1000);&#125;;const task3 = done =&gt; &#123; setTimeout(() =&gt; &#123; console.log('task3~'); done(); &#125;, 1000);&#125;;exports.foo = series(task1, task2, task3); 1npx gulp foo // 会依次打印 task1、task2、task3 并行任务：一起执行 1npx gulp foo // 会同时打印 task1、task2、task3 异步任务Gulp 是如何处理异步任务的呢？即如何通知 Gulp 异步任务的完成了 回调函数 1234exports.callback = done =&gt; &#123; console.log('callback task~'); done();&#125;; 12345// 报出错误exports.callback_error = done =&gt; &#123; console.log('callback task~'); done(new Error('task failed!'));&#125;; Promise 123456789exports.promise = () =&gt; &#123; console.log('promise task~'); return Promise.resolve();&#125;;exports.promise_error = () =&gt; &#123; console.log('promise task~'); return Promise.reject(new Error('task failed!'));&#125;; async 12345678910const timeout = time =&gt; &#123; return new Promise(resolve =&gt; &#123; setTimeout(resolve, time); &#125;);&#125;;exports.async = async () =&gt; &#123; await timeout(1000); console.log('async task~');&#125;; stream 12345678const fs = require('fs');exports.stream = () =&gt; &#123; const readStream = fs.createReadStream('package.json'); const writeStream = fs.createWriteStream('temp.txt'); readStream.pipe(writeStream); return readStream;&#125;; 上面 return readStream; 的操作，类似于： 123readStream.on('end', () =&gt; &#123; done();&#125;); 构建原理输入（读取文件） =&gt; 加工（压缩文件） =&gt; 输出（写入文件） 123456789101112131415161718192021222324const fs = require('fs');const &#123; Transform &#125; = require('stream');exports.default = () =&gt; &#123; // 读取流 const read = fs.createReadStream('normalize.css'); // 写入流 const write = fs.createWriteStream('normalize.min.css'); // 转换流 const transform = new Transform(&#123; transform: (chunk, encoding, callback) =&gt; &#123; // chunk =&gt; 读取流读取到的内容（Buffer） const input = chunk.toString(); const output = input.replace(/\s+/g, '').replace(/\/\*.+?\*\//g, ''); // callback is a error first function callback(null, output); &#125; &#125;); // 读取流转换后再导入到写入流 read.pipe(transform).pipe(write); // 需要返回读取流，Gulp 能根据流的状态来判断此任务是否完成 return read;&#125;; 常规操作Gulp 大多数时候就是对文件的处理，Gulp 提供 src 方法充当读取流，各种各样的插件充当转换流，dest 方法充当写入流 12345678910const &#123; src, dest &#125; = require('gulp');const cleanCss = require('gulp-clean-css');const rename = require('gulp-rename');exports.default = () =&gt; &#123; return src('src/*.css') // 读取流 .pipe(cleanCss()) // 转换流 .pipe(rename(&#123; extname: '.min.css' &#125;)) // 转换流 .pipe(dest('dist')); // 写入流&#125;; 样式处理12345678910const &#123; src, dest &#125; = require('gulp');const sass = require('gulp-sass');const style = () =&gt; &#123; return src('src/assets/styles/*.scss', &#123; base: 'src' &#125;) // 基准路径，即保留 src 后面的路径 .pipe(sass(&#123; outputStyle: 'expanded' &#125;)) // expanded 代表完全展开 .pipe(dest('dist'));&#125;;module.exports = &#123; style &#125;; 脚本处理1npm i gulp-babel @babel/core @babel/preset-env -D 123456const babel = require('gulp-babel');const script = () =&gt; &#123; return src('src/assets/scripts/*.js', &#123; base: 'src' &#125;) .pipe(babel(&#123; presets: ['@babel/preset-env'] &#125;)) .pipe(dest('dist'));&#125;; 模板编译1npm i gulp-swig -D 12345678910// 可以传递一些静态的数据，可以单独配置成一个文件const data = &#123; age: 18 &#125;;const page = () =&gt; &#123; return src('src/*.html', &#123; base: 'src' &#125;) .pipe(plugins.swig(&#123; data, defaults: &#123; cache: false &#125; // 为了后面 browser-sync 的热更新 &#125;)) .pipe(dest('dist'));&#125;; 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &#123;% include 'partials/header.html' %&#125; &#123;&#123; age &#125;&#125;&lt;/body&gt;&lt;/html&gt; 图片处理1npm i gulp-imagemin -D 123456// 图片处理const image = () =&gt; &#123; return src('src/assets/images/**', &#123; base: 'src' &#125;) .pipe(imagemin()) .pipe(dest('dist'));&#125;; 123456// 字体处理const font = () =&gt; &#123; return src('src/assets/fonts/**', &#123; base: 'src' &#125;) .pipe(imagemin()) .pipe(dest('dist'));&#125;; 其他操作拷贝 public 下的文件 1234const extra = () =&gt; &#123; return src('public/**', &#123; base: 'public' &#125;) .pipe(dest('dist'));&#125;; 清除文件 12// npm i del -Dconst clean = () =&gt; del(['dist']); // del 返回的是一个 Promise，可以标记任务完成 组合任务12345// 并行任务const compile = parallel(style, script, page, image, font);// 清除文件的操作要是串行的const build = series(clean, parallel(compile, extra));module.exports = &#123; build &#125;; 自动加载插件123// npm i gulp-load-plugins -Dconst loadPlugins = require('gulp-load-plugins');const plugins = loadPlugins(); 123// 把之前如下引入插件的方式都删了const sass = require('gulp-sass');const babel = require('gulp-babel'); 123// 后续再使用 sass、babel 插件的时候只需要，替换成如下的形式plugins.sass();plugins.babel(); 配置服务器1npm i browser-sync -D 123456789101112131415161718const browserSync = require('browser-sync');const bs = browserSync.create();const serve = () =&gt; &#123; bs.init(&#123; // notify: false, // 去掉连接小提示 // port: 3000, // 默认 // open: false, // 是否自动打开浏览器 files: 'dist/**', // dist 下的所有文件发生变化就热更新 server: &#123; baseDir: 'dist', routes: &#123; // 先走这里，匹配的话就使用这里的配置，以 '/node_modules' 开头的都去 node_modules 文件夹去找资源 '/node_modules': 'node_modules' &#125; &#125; &#125;);&#125;; 监视 src 变化1234567891011121314151617181920212223const serve = () =&gt; &#123; // 服务开始的时候监视文件变化并构建 watch('src/assets/styles/*.scss', style); watch('src/assets/scripts/*.js', script); watch('src/*.html', page); // 图片、字体的处理只是压缩，不影响页面效果的呈现，在开发阶段不需要构建，会降低开发阶段构建的效率，但同样需要监听变化并热更新！ watch(['src/assets/images/**', 'src/assets/fonts/**', 'public/**'], bs.reload); bs.init(&#123; files: 'dist/**', server: &#123; baseDir: ['dist', 'src', 'public'], // 会依次去每个文件夹里面去找需要的资源 routes: &#123; '/node_modules': 'node_modules' &#125; &#125; &#125;);&#125;;const compile = parallel(style, script, page);const build = series(clean, parallel(compile, extra, image, font));const develop = series(compile, serve); // 先编译有内容后才能托管服务module.exports = &#123; build, develop &#125;; 其他写法，也可以不配置 { files: &#39;dist/**&#39; }，在 style、script、page 任务的最后加上 .pipe(bs.reload({ stream: true })) 12345const style = () =&gt; &#123; return src('src/assets/styles/*.scss', &#123; base: 'src' &#125;) .pipe(dest('dist')) .pipe(bs.reload(&#123; stream: true &#125;));&#125;; 处理资源引用功效：提取、合并，也可以配合其他插件进行压缩 12npm i gulp-useref -Dnpm i gulp-htmlmin gulp-uglify gulp-clean-css gulp-if -D 12345678910111213const useref = () =&gt; &#123; return src('dist/*.html', &#123; base: 'dist' &#125;) .pipe(plugins.useref(&#123; searchPath: ['dist', '.'] &#125;)) // 读取流中有 3 种类型的文件：HTML、CSS、JS .pipe(plugins.if(/\.js$/, plugins.uglify())) .pipe(plugins.if(/\.css$/, plugins.cleanCss())) .pipe(plugins.if(/\.html$/, plugins.htmlmin(&#123; collapseWhitespace: true, minifyCSS: true, minifyJS: true &#125;))) .pipe(dest('release')); // 这里不再是 dist 了，边读边写同一个文件会冲突&#125;; 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- build:css assets/styles/vendor.css --&gt; &lt;link rel="stylesheet" href="/node_modules/bootstrap/dist/css/bootstrap.min.css"&gt; &lt;!-- endbuild --&gt; &lt;!-- build:css assets/styles/main.css --&gt; &lt;link rel="stylesheet" href="assets/styles/main.css"&gt; &lt;!-- endbuild --&gt;&lt;/head&gt;&lt;body&gt; &lt;button type="button" class="btn btn-primary"&gt;Pri&lt;/button&gt; &#123;% include 'partials/header.html' %&#125; &#123;&#123; age &#125;&#125; &lt;!-- build:js assets/scripts/main.js --&gt; &lt;script type="text/javascript" src="assets/scripts/main.js"&gt;&lt;/script&gt; &lt;!-- endbuild --&gt;&lt;/body&gt;&lt;/html&gt; 规划构建过程12// 生成的临时文件放到了 tempconst clean = () =&gt; del(['dist', 'temp']); 12345678910const style = () =&gt; &#123; return src('src/assets/styles/*.scss', &#123; base: 'src' &#125;) // 基准路径，即保留 src 后面的路径 .pipe(dest('temp'));&#125;;const script = () =&gt; &#123;&#125;;const page = () =&gt; &#123;&#125;;// image、font、extra 只是 build 的时候才需要处理的，开发阶段不需要放到临时目录 temp// 只有被 useref 影响的操作才需要放到临时目录 temp 12345bs.init(&#123; server: &#123; baseDir: ['temp', 'src', 'public'] &#125;&#125;); 12345const useref = () =&gt; &#123; return src('temp/*.html', &#123; base: 'temp' &#125;) .pipe(plugins.useref(&#123; searchPath: ['temp', '.'] &#125;)) .pipe(dest('dist'))&#125;; 1const build = series(clean, parallel(series(compile, useref), extra, image, font));]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>自动化构建</tag>
        <tag>Gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Hooks]]></title>
    <url>%2F2020%2F04%2F01%2Freact-hooks%2F</url>
    <content type="text"><![CDATA[相关 API 的使用及注意！ useState基本使用1234567891011121314151617181920import React, &#123; useState &#125; from 'react';function Example() &#123; // 声明一个叫 "count" 的 state 变量 const [count, setCount] = useState(0); return ( &lt;div&gt; &lt;p&gt; You clicked &#123;count&#125; times &lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;Click me&lt;/button&gt; &lt;/div&gt; );&#125;function App() &#123; return &lt;Example /&gt;;&#125;export default App; 和下面的 class 写法等价！ 123456789101112131415161718class Example extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; count: 0 &#125;; &#125; render() &#123; return ( &lt;div&gt; &lt;p&gt; You clicked &#123;this.state.count&#125; times &lt;/p&gt; &lt;button onClick=&#123;() =&gt; this.setState(&#123; count: this.state.count + 1 &#125;)&#125;&gt;Click me&lt;/button&gt; &lt;/div&gt; ); &#125;&#125; 一个问题123456789101112131415161718192021import React, &#123; useState &#125; from 'react';function Example(props) &#123; console.log('每次点击按钮渲染这里都会执行，其实 defaultCount 的赋值没必要每次都进行'); const defaultCount = props.defaultCount || 0; const [count, setCount] = useState(defaultCount); return ( &lt;div&gt; &lt;p&gt; You clicked &#123;count&#125; times &lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;Click me&lt;/button&gt; &lt;/div&gt; );&#125;function App() &#123; return &lt;Example defaultCount=&#123;3&#125; /&gt;;&#125;export default App; 解决方案1234567891011121314151617import React, &#123; useState &#125; from 'react';function Example(props) &#123; // useState 参数可以是一个回调函数，可以把初始值当做此函数的返回值 const [count, setCount] = useState(() =&gt; &#123; console.log('这里只是初始化时执行一次！'); return props.defaultCount || 0; &#125;); return ( &lt;div&gt; &lt;p&gt; You clicked &#123;count&#125; times &lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;Click me&lt;/button&gt; &lt;/div&gt; );&#125; useEffect可以在函数组件中执行副作用操作 基本使用12345678910111213141516171819import React, &#123; useState, useEffect &#125; from 'react';function Example() &#123; const [count, setCount] = useState(0); // 模拟 componentDidMount 和 componentDidUpdate useEffect(() =&gt; &#123; // 初始化和任何状态发生变化的时触发 document.title = `You clicked $&#123;count&#125; times`; &#125;); return ( &lt;div&gt; &lt;p&gt; You clicked &#123;count&#125; times &lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;Click me&lt;/button&gt; &lt;/div&gt; );&#125; 清除 Effect有些副作用可能需要清除，需要返回一个函数！ 123456789101112131415161718192021222324252627function Example() &#123; const [size, setSize] = useState(&#123; width: document.documentElement.clientWidth, height: document.documentElement.clientHeight &#125;); const onResize = () =&gt; &#123; setSize(&#123; width: document.documentElement.clientWidth, height: document.documentElement.clientHeight &#125;); &#125;; useEffect(() =&gt; &#123; // useEffect 第二个参数传递空数组，初始化时才会执行，而绑定事件的操作也只需要执行这一次！ window.addEventListener('resize', onResize); return () =&gt; &#123; // useEffect 第一个参数中返回的函数，在组件卸载时会触发 window.removeEventListener('resize', onResize); &#125;; &#125;, []); return ( &lt;div&gt; &lt;p id="size"&gt; width: &#123;size.width&#125;, height: &#123;size.height&#125; &lt;/p&gt; &lt;/div&gt; );&#125; 一个问题由于选择元素绑定事件的操作只是初始化的时候对当前的 DOM 元素执行了一次 一旦 count 变化（DOM 元素被替换/其实是销毁了，下次加载的又是全新的），点击事件的效果就“失效”了。DOM 元素在相同标签下替换无此问题，因为 DOM Diff 时会被复用！ 1234567891011121314151617181920212223242526272829import React, &#123; useState, useEffect &#125; from 'react';function Example() &#123; const [count, setCount] = useState(0); const onClick = () =&gt; &#123; console.log('一旦绑定事件的元素被替换过了，此元素就不再具备事件效果了，因为新替换的元素并没有进行事件绑定'); &#125;; useEffect(() =&gt; &#123; document.querySelector('#size').addEventListener('click', onClick); return () =&gt; &#123; document.querySelector('#size').removeEventListener('click', onClick); &#125;; &#125;, []); return ( &lt;div&gt; &lt;p&gt; &#123;count&#125; &lt;/p&gt; &lt;button onClick=&#123;() =&gt; &#123; setCount(count + 1); &#125;&#125; &gt; click &lt;/button&gt; &#123;count % 2 ? &lt;div id="size"&gt;hello world2&lt;/div&gt; : &lt;p id="size"&gt;hello world1&lt;/p&gt;&#125; &lt;/div&gt; );&#125; 解决方案有涉及到【根据状态】来进行元素切换（此元素绑定的有事件），每次状态变化时都进行重新绑定！ 123456useEffect(() =&gt; &#123; document.querySelector('#size').addEventListener('click', onClick); return () =&gt; &#123; document.querySelector('#size').removeEventListener('click', onClick); &#125;;&#125;, [count]); useLayoutEffect用法和 useEffect 一致，与 useEffect 的差别是执行时机，useLayoutEffect 是在浏览器绘制节点之前执行（和 componentDidMount 以及 componentDidUpdate 执行时机相同） useCallback问题重现App 组件的 props 或者状态发生变化就会触发重渲染，即使跟 Foo 组件不相关，倘若 Foo 组件是一个大型的组件树，Virtual DOM Diff 的浪费是巨大的！ 123456789101112131415161718192021222324252627282930313233import React, &#123; Component, PureComponent &#125; from 'react';class Foo extends PureComponent &#123; render() &#123; console.log('Foo render'); return &lt;div&gt;hello world&lt;/div&gt;; &#125;&#125;class App extends Component &#123; state = &#123; count: 0 &#125;; handleClick = () =&gt; &#123; this.setState(&#123; count: this.state.count + 1 &#125;); &#125;; render() &#123; const &#123; count &#125; = this.state; return ( &lt;div&gt; &#123;count&#125; &lt;button onClick=&#123;this.handleClick&#125;&gt;add&lt;/button&gt; &lt;Foo doSomething=&#123;() =&gt; &#123; console.log('do something'); &#125;&#125; /&gt; &lt;/div&gt; ); &#125;&#125; 常规解决可以把 doSomething 抽离出去 1234567891011121314151617181920212223242526272829303132import React, &#123; Component, PureComponent &#125; from 'react';class Foo extends PureComponent &#123; render() &#123; console.log('Foo render'); return &lt;div&gt;hello world&lt;/div&gt;; &#125;&#125;class App extends Component &#123; state = &#123; count: 0 &#125;; handleClick = () =&gt; &#123; this.setState(&#123; count: this.state.count + 1 &#125;); &#125;; doSomething = () =&gt; &#123; console.log('do something'); &#125;; render() &#123; const &#123; count &#125; = this.state; return ( &lt;div&gt; &#123;count&#125; &lt;button onClick=&#123;this.handleClick&#125;&gt;add&lt;/button&gt; &lt;Foo doSomething=&#123;this.doSomething&#125; /&gt; &lt;/div&gt; ); &#125;&#125; Hooks 实现类组件可以通过 this 挂载函数，但函数组件就没有这么轻松了！ 12345678910111213141516171819202122import React, &#123; useState, memo, useCallback &#125; from 'react';const Foo = memo(function Foo() &#123; console.log('Foo render'); return &lt;div&gt;hello world&lt;/div&gt;;&#125;);function App() &#123; const [count, setCount] = useState(0); // 第二个参数为空数组代表无论什么情况下该函数都不会发生改变 // 非空数组，数组中的任一项一旦值或者引用发生改变，useCallback 就会重新返回一个新的记忆函数提供给后面进行渲染 const doSomething = useCallback(() =&gt; &#123; console.log('do something'); &#125;, []); return ( &lt;div&gt; &#123;count&#125; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;add&lt;/button&gt; &lt;Foo doSomething=&#123;doSomething&#125; /&gt; &lt;/div&gt; );&#125; useMemouseCallback 的功能完全可以由 useMemo 所取代，如果你想通过使用 useMemo 返回一个记忆函数也是完全可以的。 1useCallback(fn, inputs) is equivalent to useMemo(() =&gt; fn, inputs) 上面的例子可以用 useMemo 改写如下 123456const doSomething = useMemo(() =&gt; &#123; console.log('初始化的时候会执行一次！'); return () =&gt; &#123; console.log('do something'); &#125;;&#125;, []); 区别：useCallback 不会执行第一个参数函数，而是将它返回给你；useMemo 会执行第一个函数并且将函数执行结果返回给你。所以 useCallback 常用记忆函数，生成记忆后的函数并传递给子组件使用，而 useMemo 更适合经过函数计算得到一个确定的值，比如记忆组件。 12345678910111213141516171819202122232425262728293031323334353637import React, &#123; useState, useMemo &#125; from 'react';function Child(props) &#123; return ( &lt;div&gt; child: &#123;props.num&#125; &lt;/div&gt; );&#125;function Parent(&#123; num &#125;) &#123; // 只有在第二个参数 num 的值发生变化时，才会触发子组件的更新 const child = useMemo(() =&gt; &#123; console.log(233); return &lt;Child num=&#123;num&#125; /&gt;; &#125;, [num]); return ( &lt;div&gt; &#123;child&#125; &lt;/div&gt; );&#125;function App() &#123; const [count, setCount] = useState(0); // 初始化时执行或 count === 3 整体的状态（true or false）发生变化时才会触发函数的执行 const num = useMemo( () =&gt; count * 2, [count === 3] ); return ( &lt;div&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;click me&lt;/button&gt; &lt;Parent num=&#123;num&#125; /&gt; &lt;/div&gt; );&#125; useRefuseRef 跟 createRef 类似，都可以用来生成对 DOM 或组件的引用 对 DOM 元素的引用12345678910111213141516171819202122232425import React, &#123; useState, useRef &#125; from 'react';function App() &#123; let [name, setName] = useState('Ifer'); let nameRef = useRef(); const handleClick = () =&gt; &#123; // nameRef 是 input dom 元素的引用 setName(nameRef.current.value); &#125;; return ( &lt;div className="App"&gt; &lt;p&gt; &#123;name&#125; &lt;/p&gt; &lt;div&gt; &lt;input ref=&#123;nameRef&#125; type="text" defaultValue=&#123;name&#125; /&gt; &lt;button type="button" onClick=&#123;handleClick&#125;&gt; Submit &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; );&#125; 对类组件的引用1234567891011121314151617181920212223import React, &#123; useCallback, useRef, Component &#125; from 'react';// 函数组件不能被 Ref 获取，所以函数组件有时候并不能完全替代类组件class Counter extends Component &#123; speak() &#123; console.log('牛逼'); &#125; render() &#123; return &lt;h1 onClick=&#123;this.props.onClick&#125;&gt;点我输出&lt;/h1&gt;; &#125;&#125;function App() &#123; const counterRef = useRef(); const onClick = useCallback( () =&gt; &#123; // counterRef 是 Counter 组件的引用 counterRef.current.speak(); &#125;, [counterRef] ); return &lt;Counter ref=&#123;counterRef&#125; onClick=&#123;onClick&#125; /&gt;;&#125; 问题重现12345678910111213141516171819202122232425import React, &#123; useEffect, useState &#125; from 'react';function App() &#123; const [count, setCount] = useState(0); let it; useEffect(() =&gt; &#123; it = setInterval(() =&gt; &#123; setCount(count =&gt; count + 1); &#125;, 1000); &#125;, []); useEffect(() =&gt; &#123; if (count &gt;= 5) &#123; // 这样并不能停止定时器，每次 setCount 都会重新渲染整个 App // 后续的 it 句柄已经不是第一次的 setInterval 的返回值了 clearInterval(it); &#125; &#125;); return ( &lt;div&gt; &#123;count&#125; &lt;/div&gt; );&#125; 解决方案当然可以把 let it; 的声明提取到函数外面，也可以利用 useRef 绕过 Capture Value 的特性，可以认为 ref 在所有 Render 过程中保持着唯一引用！ 1234567891011121314151617181920212223242526import React, &#123; useEffect, useState, useRef &#125; from 'react';function App() &#123; const [count, setCount] = useState(0); let it = useRef(); useEffect(() =&gt; &#123; // 这一这里挂载到的是 it.current it.current = setInterval(() =&gt; &#123; setCount(count =&gt; count + 1); &#125;, 1000); &#125;, []); useEffect(() =&gt; &#123; if (count &gt;= 5) &#123; // 清除的也是 it.current clearInterval(it.current); &#125; &#125;); return ( &lt;div&gt; &#123;count&#125; &lt;/div&gt; );&#125; useImperativeHandle通过 useImperativeHandle 配合 forwardRef，可以让父组件获取子组件内的 DOM 引用 123456789101112131415161718192021222324import React, &#123; useRef, useEffect, useImperativeHandle, forwardRef &#125; from 'react';function ChildInputComponent(props, ref) &#123; const inputRef = useRef(null); // Step1 useImperativeHandle(ref, () =&gt; inputRef.current); return &lt;input type="text" name="child input" ref=&#123;inputRef&#125; /&gt;;&#125;// Step2const ChildInput = forwardRef(ChildInputComponent);function App() &#123; const inputRef = useRef(null); useEffect(() =&gt; &#123; // Step3 inputRef.current.focus(); &#125;, []); return ( &lt;div&gt; &lt;ChildInput ref=&#123;inputRef&#125; /&gt; &lt;/div&gt; );&#125; useContext基本使用父组件 123456789101112131415161718import React, &#123; Component, useState, createContext, useContext &#125; from 'react';const CountContext = createContext();function App() &#123; const [count, setCount] = useState(0); return ( &lt;div&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; click &#123;count&#125; &lt;/button&gt; &lt;CountContext.Provider value=&#123;count&#125;&gt; &lt;Foo /&gt; &lt;Bar /&gt; &lt;Counter /&gt; &lt;/CountContext.Provider&gt; &lt;/div&gt; );&#125; 基础写法 123456789101112class Foo extends Component &#123; render() &#123; return ( &lt;CountContext.Consumer&gt; &#123;count =&gt; &lt;h1&gt; &#123;count&#125; &lt;/h1&gt;&#125; &lt;/CountContext.Consumer&gt; ); &#125;&#125; 优雅写法 1234567891011class Bar extends Component &#123; static contextType = CountContext; render() &#123; const count = this.context; return ( &lt;h1&gt; &#123;count&#125; &lt;/h1&gt; ); &#125;&#125; Hooks 写法 12345678function Counter() &#123; const count = useContext(CountContext); return ( &lt;h1&gt; &#123;count&#125; &lt;/h1&gt; );&#125; 优化多状态嵌套12345678910111213141516171819202122import React, &#123; createContext, Component &#125; from 'react';const BatteryContext = createContext();const OnlineContext = createContext();class App extends Component &#123; state = &#123; battery: 60, online: false &#125;; render() &#123; const &#123; battery, online &#125; = this.state; return ( &lt;BatteryContext.Provider value=&#123;battery&#125;&gt; &lt;OnlineContext.Provider value=&#123;online&#125;&gt; &lt;button onClick=&#123;() =&gt; this.setState(&#123; battery: battery - 1 &#125;)&#125;&gt;Battery&lt;/button&gt; &lt;button onClick=&#123;() =&gt; this.setState(&#123; online: !online &#125;)&#125;&gt;Online&lt;/button&gt; &lt;Middle /&gt; &lt;/OnlineContext.Provider&gt; &lt;/BatteryContext.Provider&gt; ); &#125;&#125; 123456// Middle 组件class Middle extends Component &#123; render() &#123; return &lt;Leaf /&gt;; &#125;&#125; 12345678910111213141516// 之前写法：Leaf 组件class Leaf extends Component &#123; render() &#123; return ( &lt;BatteryContext.Consumer&gt; &#123;battery =&gt; &lt;OnlineContext.Consumer&gt; &#123;online =&gt; &lt;h1&gt; Battery: &#123;battery&#125;, Online: &#123;String(online)&#125; &lt;/h1&gt;&#125; &lt;/OnlineContext.Consumer&gt;&#125; &lt;/BatteryContext.Consumer&gt; ); &#125;&#125; Hooks 改写 Leaf 组件 123456789function Leaf() &#123; const battery = useContext(BatteryContext); const online = useContext(OnlineContext); return ( &lt;h1&gt; Battery: &#123;battery&#125;, Online: &#123;String(online)&#125; &lt;/h1&gt; );&#125; useReduceruseReducer 在使用上几乎跟 Redux/React-Redux 一模一样，唯一缺少的就是无法使用 redux 提供的中间件 123456789101112131415161718192021222324252627import React, &#123; useReducer &#125; from 'react';const initialState = &#123; count: 0&#125;;function reducer(state, action) &#123; switch (action.type) &#123; case 'increment': return &#123; count: state.count + action.payload &#125;; case 'decrement': return &#123; count: state.count - action.payload &#125;; default: throw new Error(); &#125;&#125;function App() &#123; const [state, dispatch] = useReducer(reducer, initialState); return ( &lt;div&gt; Count: &#123;state.count&#125; &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: 'increment', payload: 5 &#125;)&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: 'decrement', payload: 5 &#125;)&#125;&gt;-&lt;/button&gt; &lt;/div&gt; );&#125; Custom Hooks自定义 Hooks 其实就可以理解为对函数的封装！ 功能型封装12345678910111213141516171819202122232425262728293031323334353637import React, &#123; useEffect, useState, useRef &#125; from 'react';function useCount(defaultCount) &#123; const [count, setCount] = useState(defaultCount); const it = useRef(); useEffect(() =&gt; &#123; it.current = setInterval(() =&gt; &#123; setCount(count =&gt; count + 1); &#125;, 1000); &#125;, []); useEffect(() =&gt; &#123; if (count &gt;= 5) &#123; clearInterval(it.current); &#125; &#125;); return [count, setCount];&#125;function App() &#123; // 会自动变化的 count const [count, setCount] = useCount(0); return ( &lt;div&gt; &lt;p&gt; &#123;count&#125; &lt;/p&gt; &lt;button onClick=&#123;() =&gt; &#123; setCount(count + 1); &#125;&#125; &gt; click &lt;/button&gt; &lt;/div&gt; );&#125; 组件型封装1234567891011121314151617181920import React from 'react';function useCounter(count) &#123; return ( &lt;span&gt; &#123;count&#125; &lt;/span&gt; );&#125;function App() &#123; // Counter 得到的是一个组件 const Counter = useCounter(0); return ( &lt;div&gt; &lt;p&gt; &#123;Counter&#125; &lt;/p&gt; &lt;/div&gt; );&#125; 计算结果型封装123456789101112131415161718192021222324252627282930313233343536373839import React, &#123; useEffect, useState, useCallback &#125; from 'react';function useSize() &#123; const [size, setSize] = useState(&#123; width: document.documentElement.clientWidth, height: document.documentElement.clientHeight &#125;); const onResize = useCallback(() =&gt; &#123; // 主动触发时才会执行 setSize(&#123; width: document.documentElement.clientWidth, height: document.documentElement.clientHeight &#125;); &#125;, []); useEffect( () =&gt; &#123; // 初始化和 onResize 变化时执行，不错这里的 onResize 也不会变化，所以也是只执行了一次 window.addEventListener('resize', onResize); return () =&gt; &#123; window.removeEventListener('resize', onResize); &#125;; &#125;, [onResize] ); return size;&#125;function App() &#123; // size 是一个对象 const size = useSize(); return ( &lt;div&gt; &lt;p&gt; width: &#123;size.width&#125; height: &#123;size.height&#125; &lt;/p&gt; &lt;/div&gt; );&#125; TodoList版本 1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117import React, &#123; useState, useCallback, useRef, useEffect, memo &#125; from 'react';const TODO_KEY = 'TODO';function App() &#123; const [todos, setTodos] = useState([]); // useCallback 目的是优化 const addTodo = useCallback(todo =&gt; &#123; // setTodos([...todos, todo]); // 这种写法能避免对 todos 的依赖 setTodos(todos =&gt; [...todos, todo]); &#125;, []); const removeTodo = useCallback(id =&gt; &#123; setTodos(todos =&gt; todos.filter(todo =&gt; todo.id !== id)); &#125;, []); const toggleTodo = useCallback(id =&gt; &#123; setTodos(todos =&gt; todos.map(todo =&gt; &#123; return todo.id === id ? &#123; ...todo, completed: !todo.completed &#125; : todo; &#125;) ); &#125;, []); useEffect(() =&gt; &#123; // 只初始化时执行一次 const todos = JSON.parse(localStorage.getItem(TODO_KEY) || '[]'); setTodos(todos); &#125;, []); useEffect( () =&gt; &#123; // 初始化时和 todos 发生变化就存储到本地 localStorage.setItem(TODO_KEY, JSON.stringify(todos)); &#125;, [todos] ); return ( &lt;section className="todoapp"&gt; &#123;/* 头部 */&#125; &lt;Header addTodo=&#123;addTodo&#125; /&gt; &#123;/* 主体 */&#125; &lt;Content removeTodo=&#123;removeTodo&#125; todos=&#123;todos&#125; toggleTodo=&#123;toggleTodo&#125; /&gt; &lt;/section&gt; );&#125;const Header = memo(function Header(props) &#123; const &#123; addTodo &#125; = props; const inputRef = useRef(); const handleKeyUp = e =&gt; &#123; if (e.keyCode === 13) &#123; const title = inputRef.current.value.trim(); if (!title) return; addTodo(&#123; id: Date.now() + '', title: title, completed: false &#125;); inputRef.current.value = ''; &#125; &#125;; return ( &lt;header className="header"&gt; &lt;h1&gt;todos&lt;/h1&gt; &lt;input ref=&#123;inputRef&#125; className="new-todo" placeholder="What needs to be done?" id="task" onKeyUp=&#123;handleKeyUp&#125; autoFocus /&gt; &lt;/header&gt; );&#125;);const Content = memo(function Content(props) &#123; const &#123; todos, toggleTodo, removeTodo &#125; = props; return ( &lt;section className="main"&gt; &lt;input className="toggle-all" type="checkbox" /&gt; &lt;ul className="todo-list" id="todo-list"&gt; &#123;todos.map(todo =&gt; &lt;Item key=&#123;todo.id&#125; todo=&#123;todo&#125; toggleTodo=&#123;toggleTodo&#125; removeTodo=&#123;removeTodo&#125; /&gt;)&#125; &lt;/ul&gt; &lt;/section&gt; );&#125;);const Item = memo(function Item(props) &#123; const &#123; todo: &#123; id, title, completed &#125;, toggleTodo, removeTodo &#125; = props; const handleChange = () =&gt; &#123; // 每一个 Item 都绑定了自己的事件，可以直接获取到自己的 ID，无需自定义属性 toggleTodo(id); &#125;; const handleClick = () =&gt; &#123; removeTodo(id); &#125;; return ( &lt;li className=&#123;completed ? 'completed' : ''&#125;&gt; &lt;div className="view"&gt; &lt;input className="toggle" type="checkbox" checked=&#123;completed&#125; onChange=&#123;handleChange&#125; /&gt; &lt;label&gt; &#123;title&#125; &lt;/label&gt; &lt;button className="destroy" onClick=&#123;handleClick&#125; /&gt; &lt;/div&gt; &lt;input className="edit" placeholder="Rule the web" /&gt; &lt;/li&gt; );&#125;);export default App; 版本 2把 addTodo、removeTodo、toggleTodo 都封装到了 dispatch 中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125import React, &#123; useState, useCallback, useRef, useEffect, memo &#125; from 'react';import &#123; createSet, createAdd, createRemove, createToggle &#125; from './actions';const TODO_KEY = 'TODO';function App() &#123; const [todos, setTodos] = useState([]); const dispatch = useCallback(action =&gt; &#123; const &#123; type, payload &#125; = action; switch (type) &#123; case 'SET': setTodos(payload); break; case 'ADD': setTodos(todos =&gt; [...todos, payload]); break; case 'REMOVE': setTodos(todos =&gt; todos.filter(todo =&gt; todo.id !== payload)); break; case 'TOGGLE': setTodos(todos =&gt; todos.map(todo =&gt; &#123; return todo.id === payload ? &#123; ...todo, completed: !todo.completed &#125; : todo; &#125;) ); break; default: &#125; &#125;, []); useEffect(() =&gt; &#123; // 只初始化时执行一次 const todos = JSON.parse(localStorage.getItem(TODO_KEY) || '[]'); // Step2: 每次都需要传递 action，所以封装了 actionCreator dispatch(createSet(todos)); &#125;, []); useEffect( () =&gt; &#123; // 初始化时和 todos 发生变化就存储到本地 localStorage.setItem(TODO_KEY, JSON.stringify(todos)); &#125;, [todos] ); return ( &lt;section className="todoapp"&gt; &#123;/* 头部 */&#125; &lt;Header dispatch=&#123;dispatch&#125; /&gt; &#123;/* 主体 */&#125; &lt;Content dispatch=&#123;dispatch&#125; todos=&#123;todos&#125; /&gt; &lt;/section&gt; );&#125;const Header = memo(function Header(props) &#123; const &#123; dispatch &#125; = props; const inputRef = useRef(); const handleKeyUp = e =&gt; &#123; if (e.keyCode === 13) &#123; const title = inputRef.current.value.trim(); if (!title) return; dispatch( createAdd(&#123; id: Date.now() + '', title: title, completed: false &#125;) ); inputRef.current.value = ''; &#125; &#125;; return ( &lt;header className="header"&gt; &lt;h1&gt;todos&lt;/h1&gt; &lt;input ref=&#123;inputRef&#125; className="new-todo" placeholder="What needs to be done?" id="task" onKeyUp=&#123;handleKeyUp&#125; autoFocus /&gt; &lt;/header&gt; );&#125;);const Content = memo(function Content(props) &#123; const &#123; todos, dispatch &#125; = props; return ( &lt;section className="main"&gt; &lt;input className="toggle-all" type="checkbox" /&gt; &lt;ul className="todo-list" id="todo-list"&gt; &#123;todos.map(todo =&gt; &lt;Item key=&#123;todo.id&#125; todo=&#123;todo&#125; dispatch=&#123;dispatch&#125; /&gt;)&#125; &lt;/ul&gt; &lt;/section&gt; );&#125;);const Item = memo(function Item(props) &#123; const &#123; todo: &#123; id, title, completed &#125;, dispatch &#125; = props; const handleChange = () =&gt; &#123; // 每一个 Item 都绑定了自己的事件，可以直接获取到自己的 ID，无需自定义属性 dispatch(createToggle(id)); &#125;; const handleClick = () =&gt; &#123; dispatch(createRemove(id)); &#125;; return ( &lt;li className=&#123;completed ? 'completed' : ''&#125;&gt; &lt;div className="view"&gt; &lt;input className="toggle" type="checkbox" checked=&#123;completed&#125; onChange=&#123;handleChange&#125; /&gt; &lt;label&gt; &#123;title&#125; &lt;/label&gt; &lt;button className="destroy" onClick=&#123;handleClick&#125; /&gt; &lt;/div&gt; &lt;input className="edit" placeholder="Rule the web" /&gt; &lt;/li&gt; );&#125;); 版本 3把 actionCreator 和 dispatch 打包到一起给组件调用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151import React, &#123; useState, useCallback, useRef, useEffect, memo &#125; from 'react';import &#123; createSet, createAdd, createRemove, createToggle &#125; from './actions';const TODO_KEY = 'TODO';// Step3: actionCreator 都要给 dispatch 用，封装了 bindActionCreators// 把 actionCreator 和 dispatch 打包到一起给组件调用// bindActionCreators(&#123; addTodo: createAdd, removeTodo: createRemove &#125;, dispatch)const bindActionCreators = (actionCreators, dispatch) =&gt; &#123; const ret = &#123;&#125;; for (let key in actionCreators) &#123; ret[key] = function(...args) &#123; const actionCreator = actionCreators[key]; const action = actionCreator(...args); dispatch(action); &#125;; &#125; /* &#123; addTodo: function(...args) &#123; dispatch(createAdd(...args)) &#125;, removeTodo: function(...args)&#123; dispatch(createRemove(...args)) &#125; &#125; */ return ret;&#125;;function App() &#123; const [todos, setTodos] = useState([]); // Step1: 把 addTodo、removeTodo、toggleTodo 都封装到了 dispatch 中 const dispatch = useCallback(action =&gt; &#123; const &#123; type, payload &#125; = action; switch (type) &#123; case 'SET': setTodos(payload); break; case 'ADD': setTodos(todos =&gt; [...todos, payload]); break; case 'REMOVE': setTodos(todos =&gt; todos.filter(todo =&gt; todo.id !== payload)); break; case 'TOGGLE': setTodos(todos =&gt; todos.map(todo =&gt; &#123; return todo.id === payload ? &#123; ...todo, completed: !todo.completed &#125; : todo; &#125;) ); break; default: &#125; &#125;, []); useEffect(() =&gt; &#123; // 只初始化时执行一次 const todos = JSON.parse(localStorage.getItem(TODO_KEY) || '[]'); // Step2: 每次都需要传递 action，所以封装了 actionCreator dispatch(createSet(todos)); &#125;, []); useEffect( () =&gt; &#123; // 初始化时和 todos 发生变化就存储到本地 localStorage.setItem(TODO_KEY, JSON.stringify(todos)); &#125;, [todos] ); return ( &lt;section className="todoapp"&gt; &#123;/* 头部 */&#125; &lt;Header &#123;...bindActionCreators(&#123; addTodo: createAdd &#125;, dispatch)&#125; /&gt; &#123;/* 主体 */&#125; &lt;Content &#123;...bindActionCreators(&#123; removeTodo: createRemove, toggleTodo: createToggle &#125;, dispatch)&#125; todos=&#123;todos&#125; /&gt; &lt;/section&gt; );&#125;const Header = memo(function Header(props) &#123; const &#123; addTodo &#125; = props; const inputRef = useRef(); const handleKeyUp = e =&gt; &#123; if (e.keyCode === 13) &#123; const title = inputRef.current.value.trim(); if (!title) return; // addTodo 已经具备了 dispatch 和 createAdd 的双重功能 addTodo(&#123; id: Date.now() + '', title: title, completed: false &#125;); inputRef.current.value = ''; &#125; &#125;; return ( &lt;header className="header"&gt; &lt;h1&gt;todos&lt;/h1&gt; &lt;input ref=&#123;inputRef&#125; className="new-todo" placeholder="What needs to be done?" id="task" onKeyUp=&#123;handleKeyUp&#125; autoFocus /&gt; &lt;/header&gt; );&#125;);const Content = memo(function Content(props) &#123; const &#123; todos, removeTodo, toggleTodo &#125; = props; return ( &lt;section className="main"&gt; &lt;input className="toggle-all" type="checkbox" /&gt; &lt;ul className="todo-list" id="todo-list"&gt; &#123;todos.map(todo =&gt; &lt;Item key=&#123;todo.id&#125; todo=&#123;todo&#125; removeTodo=&#123;removeTodo&#125; toggleTodo=&#123;toggleTodo&#125; /&gt;)&#125; &lt;/ul&gt; &lt;/section&gt; );&#125;);const Item = memo(function Item(props) &#123; const &#123; todo: &#123; id, title, completed &#125;, removeTodo, toggleTodo &#125; = props; const handleChange = () =&gt; &#123; // 每一个 Item 都绑定了自己的事件，可以直接获取到自己的 ID，无需自定义属性 toggleTodo(id); &#125;; const handleClick = () =&gt; &#123; removeTodo(id); &#125;; return ( &lt;li className=&#123;completed ? 'completed' : ''&#125;&gt; &lt;div className="view"&gt; &lt;input className="toggle" type="checkbox" checked=&#123;completed&#125; onChange=&#123;handleChange&#125; /&gt; &lt;label&gt; &#123;title&#125; &lt;/label&gt; &lt;button className="destroy" onClick=&#123;handleClick&#125; /&gt; &lt;/div&gt; &lt;input className="edit" placeholder="Rule the web" /&gt; &lt;/li&gt; );&#125;); 版本 4123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167import React, &#123; useState, useCallback, useRef, useEffect, memo &#125; from 'react';import &#123; createSet, createAdd, createRemove, createToggle &#125; from './actions';import reducer from './reducers';const TODO_KEY = 'TODO';const bindActionCreators = (actionCreators, dispatch) =&gt; &#123; const ret = &#123;&#125;; for (let key in actionCreators) &#123; ret[key] = function(...args) &#123; const actionCreator = actionCreators[key]; const action = actionCreator(...args); dispatch(action); &#125;; &#125; return ret;&#125;;function App() &#123; const [todos, setTodos] = useState([]); const [incrementCount, setIncrementCount] = useState(0); /* const reducer = (state, action) =&gt; &#123; const &#123; type, payload &#125; = action; const &#123; todos, incrementCount &#125; = state; switch (type) &#123; case 'SET': return &#123; ...state, todos: payload, incrementCount: incrementCount + 1 &#125;; case 'ADD': return &#123; ...state, todos: [...todos, payload], incrementCount: incrementCount + 1 &#125;; case 'REMOVE': return &#123; ...state, todos: todos.filter(todo =&gt; todo.id !== payload) &#125;; case 'TOGGLE': return &#123; ...state, todos: todos.map(todo =&gt; &#123; return todo.id === payload ? &#123; ...todo, completed: !todo.completed &#125; : todo; &#125;) &#125;; default: return state; &#125; &#125;; */ const dispatch = useCallback( action =&gt; &#123; const state = &#123; todos, incrementCount &#125;; const setters = &#123; todos: setTodos, incrementCount: setIncrementCount &#125;; const newState = reducer(state, action); for (let key in newState) &#123; setters[key](newState[key]); &#125; &#125;, [todos, incrementCount] ); useEffect(() =&gt; &#123; // 只初始化时执行一次 const todos = JSON.parse(localStorage.getItem(TODO_KEY) || '[]'); // Step2: 每次都需要传递 action，所以封装了 actionCreator dispatch(createSet(todos)); &#125;, []); // 这里不要 [dispatch] useEffect( () =&gt; &#123; // 初始化时和 todos 发生变化就存储到本地 localStorage.setItem(TODO_KEY, JSON.stringify(todos)); &#125;, [todos] ); return ( &lt;section className="todoapp"&gt; &#123;/* 头部 */&#125; &lt;Header &#123;...bindActionCreators(&#123; addTodo: createAdd &#125;, dispatch)&#125; /&gt; &#123;/* 主体 */&#125; &lt;Content &#123;...bindActionCreators(&#123; removeTodo: createRemove, toggleTodo: createToggle &#125;, dispatch)&#125; todos=&#123;todos&#125; /&gt; &lt;/section&gt; );&#125;const Header = memo(function Header(props) &#123; const &#123; addTodo &#125; = props; const inputRef = useRef(); const handleKeyUp = e =&gt; &#123; if (e.keyCode === 13) &#123; const title = inputRef.current.value.trim(); if (!title) return; addTodo(&#123; id: Date.now() + '', title: title, completed: false &#125;); inputRef.current.value = ''; &#125; &#125;; return ( &lt;header className="header"&gt; &lt;h1&gt;todos&lt;/h1&gt; &lt;input ref=&#123;inputRef&#125; className="new-todo" placeholder="What needs to be done?" id="task" onKeyUp=&#123;handleKeyUp&#125; autoFocus /&gt; &lt;/header&gt; );&#125;);const Content = memo(function Content(props) &#123; const &#123; todos, removeTodo, toggleTodo &#125; = props; return ( &lt;section className="main"&gt; &lt;input className="toggle-all" type="checkbox" /&gt; &lt;ul className="todo-list" id="todo-list"&gt; &#123;todos.map(todo =&gt; &lt;Item key=&#123;todo.id&#125; todo=&#123;todo&#125; removeTodo=&#123;removeTodo&#125; toggleTodo=&#123;toggleTodo&#125; /&gt;)&#125; &lt;/ul&gt; &lt;/section&gt; );&#125;);const Item = memo(function Item(props) &#123; const &#123; todo: &#123; id, title, completed &#125;, toggleTodo, removeTodo &#125; = props; const handleChange = () =&gt; &#123; // 每一个 Item 都绑定了自己的事件，可以直接获取到自己的 ID，无需自定义属性 toggleTodo(id); &#125;; const handleClick = () =&gt; &#123; removeTodo(id); &#125;; return ( &lt;li className=&#123;completed ? 'completed' : ''&#125;&gt; &lt;div className="view"&gt; &lt;input className="toggle" type="checkbox" checked=&#123;completed&#125; onChange=&#123;handleChange&#125; /&gt; &lt;label&gt; &#123;title&#125; &lt;/label&gt; &lt;button className="destroy" onClick=&#123;handleClick&#125; /&gt; &lt;/div&gt; &lt;input className="edit" placeholder="Rule the web" /&gt; &lt;/li&gt; );&#125;); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// reducers.jsfunction combineReducers(reducers) &#123; return function reducer(state, action) &#123; const changed = &#123;&#125;; for (let key in reducers) &#123; changed[key] = reducers[key](state[key], action); &#125; return &#123; ...state, ...changed &#125;; &#125;;&#125;const reducers = &#123; todos(state, action) &#123; const &#123; type, payload &#125; = action; switch (type) &#123; case 'SET': return payload; case 'ADD': return [...state, payload]; case 'REMOVE': return state.filter(todo =&gt; todo.id !== payload); case 'TOGGLE': return state.map(todo =&gt; &#123; return todo.id === payload ? &#123; ...todo, completed: !todo.completed &#125; : todo; &#125;); default: return state; &#125; &#125;, incrementCount(state, action) &#123; const &#123; type &#125; = action; switch (type) &#123; case 'SET': case 'ADD': return state + 1; default: return state; &#125; &#125;&#125;;export default combineReducers(reducers); 1234567891011121314151617181920// actions.jsexport const createSet = (payload) =&gt; (&#123; type: 'SET', payload&#125;);export const createAdd = (payload) =&gt; (&#123; type: 'ADD', payload&#125;);export const createRemove = (payload) =&gt; (&#123; type: 'REMOVE', payload&#125;);export const createToggle = (payload) =&gt; (&#123; type: 'TOGGLE', payload&#125;);]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React Hooks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redux]]></title>
    <url>%2F2020%2F02%2F13%2Fredux-course%2F</url>
    <content type="text"><![CDATA[Redux 是用来处理复杂数据交互的，例如一个组件需要改变全局状态，或者改变另一个组件的状态。 createStore代码 创建对应组件的 reducer src/pages/moneyCounter/store/reducer.js 12345678910111213141516171819import * as actionTypes from './actionTypes';const defaultState = &#123; moneyNum: 0&#125;;export default (state = defaultState, action) =&gt; &#123; const newState = JSON.parse(JSON.stringify(state)); switch (action.type) &#123; case actionTypes.ADD: newState.moneyNum += 1; return newState; case actionTypes.SUB: newState.moneyNum -= 1; return newState; default: return newState; &#125;&#125;; 通过 createStore 来创建 store，需要传递上面的 reducer 作为参数 src/store/index.js 123456import &#123; createStore &#125; from 'redux';import &#123; reducer &#125; from '../pages/moneyCounter/store';const store = createStore(reducer, window.__REDUX_DEVTOOLS_EXTENSION__ &amp;&amp; window.__REDUX_DEVTOOLS_EXTENSION__());export default store; 通过 store.getState() 获取数据 src/pages/moneyCounter/index.js 123456789101112131415161718192021222324import React, &#123; Component &#125; from 'react';import store from '../../store';import &#123; add &#125; from './store/actionCreators';class MoneyCounter extends Component &#123; state = store.getState(); handleClick = () =&gt; &#123; store.dispatch(add()); &#125;; render() &#123; const &#123; moneyNum &#125; = this.state; return ( &lt;div&gt; &lt;p&gt; &#123;moneyNum&#125; &lt;/p&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;add&lt;/button&gt; &lt;/div&gt; ); &#125;&#125;export default MoneyCounter; store.subscribe代码 上面点击按钮，store 中的数据确实可以更新，但是界面却没有任何变化。store.dispatch 会触发 store.subscribe 订阅的函数，根据这一特点，可以在订阅函数中通过 store.getState() 获取最新数据并 setState。 src/pages/moneyCounter/index.js 123456789101112131415161718192021222324252627282930import React, &#123; Component &#125; from 'react';import store from '../../store';import &#123; add &#125; from './store/actionCreators';class MoneyCounter extends Component &#123; state = store.getState() componentDidMount() &#123; this.unsubscribe = store.subscribe(() =&gt; &#123; this.setState(store.getState()); &#125;); &#125; componentWillUnmount() &#123; // 记得在组件卸载时取消订阅 store.unsubscribe(this.unsubscribe); &#125; render() &#123; const &#123; moneyNum &#125; = this.state; return ( &lt;div&gt; &lt;p&gt; &#123;moneyNum&#125; &lt;/p&gt; &lt;button onClick=&#123;() =&gt; store.dispatch(add())&#125;&gt;add&lt;/button&gt; &lt;/div&gt; ); &#125;&#125;export default MoneyCounter; bindActionCreators代码 bindActionCreators 也是 Redux 的一个方法，它接收一个 actionCreator 和 dispatch，并返回一系列方法，调用对应的方法能帮我们自动 dispatch 对应的 action，代替上面直接 store.dispatch 的写法，使代码看起来更加简洁。 src/pages/moneyCounter/index.js 12345678910111213141516171819202122232425262728293031import React, &#123; Component &#125; from 'react';import &#123; bindActionCreators &#125; from 'redux';import store from '../../store';import * as actionCreators from './store/actionCreators';const &#123; add, sub &#125; = bindActionCreators(actionCreators, store.dispatch);class MoneyCounter extends Component &#123; state = store.getState(); componentDidMount() &#123; this.unsubscribe = store.subscribe(() =&gt; &#123; this.setState(store.getState()); &#125;); &#125; componentWillUnmount() &#123; store.unsubscribe(this.unsubscribe); &#125; render() &#123; const &#123; moneyNum &#125; = this.state; return ( &lt;div&gt; &lt;p&gt; &#123;moneyNum&#125; &lt;/p&gt; &lt;button onClick=&#123;add&#125;&gt;add&lt;/button&gt; &lt;button onClick=&#123;sub&#125;&gt;sub&lt;/button&gt; &lt;/div&gt; ); &#125;&#125;export default MoneyCounter; combineReducers代码 实际项目中会有很多很多的组件，我们不可能把所有数据的处理都放到一个 reducer 里，通常我们会把不同组件或者不同类别的数据处理放到不同的（对应的）reducer 里，以方便更加清晰的管理。 Redux 中有个 combineReducers 方法，它接收一组 reducer ，并返回合并后的 reducer。 src/store/reducers.js 12345678910import &#123; combineReducers &#125; from 'redux';import &#123; reducer as moneyCounterReducer &#125; from '../pages/moneyCounter/store';import &#123; reducer as ageCounterReducer &#125; from '../pages/ageCounter/store';const reducers = combineReducers(&#123; ageCounter: ageCounterReducer, moneyCouter: moneyCounterReducer&#125;);export default reducers; src/store/index.js 123456import &#123; createStore &#125; from 'redux';import reducers from './reducers';const store = createStore(reducers, window.__REDUX_DEVTOOLS_EXTENSION__ &amp;&amp; window.__REDUX_DEVTOOLS_EXTENSION__());export default store; 注意这里获取数据的时候，应该和 combineReducers 中的 key 对应起来。 src/pages/moneyCounter/index.js 12345678910111213141516171819202122232425262728293031import React, &#123; Component &#125; from 'react';import &#123; bindActionCreators &#125; from 'redux';import store from '../../store';import * as actionCreators from './store/actionCreators';const &#123; add, sub &#125; = bindActionCreators(actionCreators, store.dispatch);class MoneyCounter extends Component &#123; state = store.getState().moneyCouter; componentDidMount() &#123; this.unsubscribe = store.subscribe(() =&gt; &#123; this.setState(store.getState().moneyCouter); &#125;); &#125; componentWillUnmount() &#123; store.unsubscribe(this.unsubscribe); &#125; render() &#123; const &#123; moneyNum &#125; = this.state; return ( &lt;div&gt; &lt;p&gt; &#123;moneyNum&#125; &lt;/p&gt; &lt;button onClick=&#123;add&#125;&gt;add&lt;/button&gt; &lt;button onClick=&#123;sub&#125;&gt;sub&lt;/button&gt; &lt;/div&gt; ); &#125;&#125;export default MoneyCounter; 注意这里各个组件的 actionType 不要重复了，为了避免混淆采用前缀为组件名称进行区分。 src/pages/moneyCounter/store/actionTypes.js 12export const MONEYCOUNTER_ADD = 'moneyCounterAdd';export const MONEYCOUNTER_SUB = 'moneyCounterSub'; redux-thunk代码 使用 redux-thunk 这个第三方中间件，需要配合 applyMiddleware（Redux自带的）来开启这个中间件，具体使用套路如下。 src/store/index.js 12345678910import &#123; createStore, applyMiddleware, compose &#125; from 'redux';import thunk from 'redux-thunk';import reducers from './reducers';const store = createStore( reducers, compose(applyMiddleware(thunk), window.__REDUX_DEVTOOLS_EXTENSION__ &amp;&amp; window.__REDUX_DEVTOOLS_EXTENSION__()));export default store; src/pages/moneyCounter/store/actionCreators.js 1234567export const addAsync = () =&gt; &#123; return dispatch =&gt; &#123; setTimeout(() =&gt; &#123; dispatch(add()); &#125;, 1000); &#125;;&#125;; react-redux代码 可以使用 react-redux 这个第三方包来优雅的链接 react 和 redux。 src/index.js 123456789101112import React from 'react';import ReactDOM from 'react-dom';import &#123; Provider &#125; from 'react-redux';import store from './store';import App from './App';ReactDOM.render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;, document.querySelector('#root')); src/pages/moneyCounter/index.js 12345678910111213141516171819202122232425import React, &#123; Component &#125; from 'react';import &#123; connect &#125; from 'react-redux';import * as actionCreators from './store/actionCreators';class MoneyCounter extends Component &#123; render() &#123; const &#123; moneyCouter: &#123; moneyNum &#125;, add, sub, addAsync &#125; = this.props; return ( &lt;div&gt; &lt;p&gt; &#123;moneyNum&#125; &lt;/p&gt; &lt;button onClick=&#123;add&#125;&gt;add&lt;/button&gt; &lt;button onClick=&#123;sub&#125;&gt;sub&lt;/button&gt; &lt;button onClick=&#123;addAsync&#125;&gt;addAsync&lt;/button&gt; &lt;/div&gt; ); &#125;&#125;const mapStateToProps = state =&gt; (&#123; moneyCouter: state.moneyCouter&#125;);export default connect(mapStateToProps, actionCreators)(MoneyCounter); decorator代码 connect 可以使用装饰器的方式来编写。安装： 12yarn eject // 弹出自定义配置yarn add @babel/plugin-proposal-decorators --dev 配置 package.json 12345"babel": &#123; "plugins": [ ["@babel/plugin-proposal-decorators", &#123; "legacy": true &#125;] ]&#125; src/pages/moneyCounter/index.js 1234567891011121314151617181920212223import React, &#123; Component &#125; from 'react';import &#123; connect &#125; from 'react-redux';import * as actionCreators from './store/actionCreators';@connect(state =&gt; (&#123;moneyCouter: state.moneyCouter&#125;), actionCreators)class MoneyCounter extends Component &#123; render() &#123; const &#123; moneyCouter: &#123; moneyNum &#125;, add, sub, addAsync &#125; = this.props; return ( &lt;div&gt; &lt;p&gt; &#123;moneyNum&#125; &lt;/p&gt; &lt;button onClick=&#123;add&#125;&gt;add&lt;/button&gt; &lt;button onClick=&#123;sub&#125;&gt;sub&lt;/button&gt; &lt;button onClick=&#123;addAsync&#125;&gt;addAsync&lt;/button&gt; &lt;/div&gt; ); &#125;&#125;export default MoneyCounter; todolist本地数据，线上数据]]></content>
      <tags>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[表单处理]]></title>
    <url>%2F2020%2F02%2F06%2Fformik%2F</url>
    <content type="text"><![CDATA[表单处理代码 简单登录功能React 中简单的表单处理我们一般会如下写法，依靠 React 自身的机制来完成 12345678910111213141516171819202122232425262728293031export default class Login extends React.Component &#123; state = &#123; username: '', &#125;; handleChange = e =&gt; &#123; this.setState(&#123; [e.target.name]: e.target.value &#125;); &#125;; handleSubmit = e =&gt; &#123; e.preventDefault(); // 这里可以进行数据校验后提交... &#125;; render() &#123; const &#123; username, password &#125; = this.state; return ( &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;div className=&#123;styles.formItem&#125;&gt; &lt;input className=&#123;styles.input&#125; onChange=&#123;this.handleChange&#125; name="username" value=&#123;username&#125; placeholder="请输入账号" /&gt; &lt;/div&gt; &lt;button className=&#123;styles.submit&#125; type="submit"&gt;登 录&lt;/button&gt; &lt;/form&gt; ); &#125;&#125; formik 重构涉及到复杂表单数据时，可以使用 formik 这个库来解决表单处理的痛点（获取值、表单校验、表单提交等），把上面代码先改写如下 123456789101112131415161718192021222324// #step1: 导入import &#123; withFormik &#125; from 'formik';class Login extends React.Component &#123; render() &#123; // #step5: 通过 props 获取高阶组件提供的状态（属性和方法），handleChange 是高阶组件自带的，可以打印 this.props 查看 const &#123; values, handleSubmit, handleChange &#125; = this.props; // #step6: 替换 state 中的 username 为 values.username，自身的 this.handleSubmit、this.handleChange 都替换成高阶组件提供的 return ( &lt;form onSubmit=&#123;handleSubmit&#125;&gt; &lt;div className=&#123;styles.formItem&#125;&gt; &lt;input className=&#123;styles.input&#125; onChange=&#123;handleChange&#125; name="username" value=&#123;values.username&#125; placeholder="请输入账号" /&gt; &lt;/div&gt; &lt;button className=&#123;styles.submit&#125; type="submit"&gt;登 录&lt;/button&gt; &lt;/form&gt; ); &#125;&#125; 123456789101112// #step2: withFormik 调用返回的是一个高阶组件，这种写法方便传值，然后再包装 Login，并为 Login 提供相关状态（属性和方法）Login = withFormik(&#123; // #step3: 为组件提供状态 mapPropsToValues: () =&gt; (&#123; username: '', password: '' &#125;), // #step4: 监听表单的提交事件 handleSubmit: (values, &#123; props &#125;) =&gt; &#123; // 内部已经阻止了默认行为（跳转），props 中可以获取路由相关的信息 // #step7: 获取表单中的数据 const &#123; username, password &#125; = values; console.log(username, password, props); &#125;&#125;)(Login); validate 校验通过 formik 提供的 validate 配置项可以实现表单校验 123456789101112131415161718192021222324252627const REG_USER = /^\w&#123;5,8&#125;$/;const REG_PWD = /^\w&#123;5,12&#125;$/;class Login extends React.Component &#123; render() &#123; // 注意：必须给 input 框绑定 handleBlur 才能正确的获取 touched // #step2: 接受错误信息 errors，获取 touched 用来查看是否已访问过 input，访问过的才进行错误提示，不然一个触发时其他没有访问过的也会触发 const &#123; values, handleSubmit, handleChange, errors, touched, handleBlur &#125; = this.props; return ( &lt;form onSubmit=&#123;handleSubmit&#125;&gt; &lt;div className=&#123;styles.formItem&#125;&gt; &lt;input className=&#123;styles.input&#125; onChange=&#123;handleChange&#125; onBlur=&#123;handleBlur&#125; name="username" value=&#123;values.username&#125; placeholder="请输入账号" /&gt; &lt;/div&gt; &#123;/* validate3 展示错误信息 */&#125; &#123;errors.username &amp;&amp; touched.username &amp;&amp; &lt;div className=&#123;styles.error&#125;&gt;&#123;errors.username&#125;&lt;/div&gt;&#125; &lt;button className=&#123;styles.submit&#125; type="submit"&gt;登 录&lt;/button&gt; &lt;/form&gt; ); &#125;&#125; 123456789101112131415161718192021222324Login = withFormik(&#123; mapPropsToValues: () =&gt; (&#123; username: '', password: '' &#125;), // #step1: 添加 validate 字段进行错误信息的收集 validate: values =&gt; &#123; const errors = &#123;&#125;; if (!values.username) &#123; errors.username = '必须填写用户名'; &#125; else if (!REG_USER.test(values.username)) &#123; errors.username = '用户名必须为5到8位的数字、字母、下划线'; &#125; if (!values.password) &#123; errors.password = '必须填写密码'; &#125; else if (!REG_PWD.test(values.password)) &#123; errors.password = '密码必须为5到12位的数字、字母、下划线'; &#125; return errors; &#125;, handleSubmit: (values, &#123; props &#125;) =&gt; &#123; const &#123; username, password &#125; = values; console.log(username, password, props); &#125;&#125;)(Login); validationSchema 配合 Yup 校验官方推荐使用更加友好的方式来进行校验，即 formik 提供的 validationSchema 配置和第三方库 Yup 来完成 123456789101112131415161718192021222324252627// #step1: 导入import * as Yup from 'yup';class Login extends React.Component &#123; render() &#123; const &#123; values, handleSubmit, handleChange &#125; = this.props; // #step3: 接收错误提示信息和是否 touched 信息，touched 用于记录这个框是否被访问过（失去焦点肯定能证明访问过） const &#123; errors, touched, handleBlur &#125; = this.props; // #step4: 想要获取到 touched 需要给表单元素添加 handleBlur 事件 return ( &lt;form onSubmit=&#123;handleSubmit&#125;&gt; &lt;div className=&#123;styles.formItem&#125;&gt; &lt;input className=&#123;styles.input&#125; onChange=&#123;handleChange&#125; onBlur=&#123;handleBlur&#125; name="username" value=&#123;values.username&#125; placeholder="请输入账号" /&gt; &lt;/div&gt; &#123;/* #step5: 进行错误信息提示 */&#125; &#123;errors.username &amp;&amp; touched.username &amp;&amp; &lt;div className=&#123;styles.error&#125;&gt;&#123;errors.username&#125;&lt;/div&gt;&#125; &lt;button className=&#123;styles.submit&#125; type="submit"&gt;登 录&lt;/button&gt; &lt;/form&gt; ); &#125;&#125; 123456789101112Login = withFormik(&#123; mapPropsToValues: () =&gt; (&#123; username: '', password: '' &#125;), // #step2: 添加表单校验规则 validationSchema: Yup.object().shape(&#123; username: Yup.string().required('账号为必填项').matches(REG_UNAME, '长度为5到8位，只能出现数字、字母、下划线'), password: Yup.string().required('密码为必填项').matches(REG_PWD, '长度为5到12位，只能出现数字、字母、下划线') &#125;), handleSubmit: (values, &#123; props &#125;) =&gt; &#123; const &#123; username, password &#125; = values; console.log(username, password, props); &#125;&#125;)(Login); 简化表单处理formik 还提供了 Form、Field、ErrorMessage 等组件来简化表单的处理 12345678910111213141516171819import &#123; withFormik, Form, Field, ErrorMessage &#125; from 'formik';class Login extends React.Component &#123; render() &#123; // #step4: 去掉所有 props return ( &#123;/* #step1: 导入 Form 组件，替换 form 元素，去掉 onSubmit */&#125; &lt;Form&gt; &lt;div className=&#123;styles.formItem&#125;&gt; &#123;/* #step2: 导入 Field 组件，替换 input 表单元素，去掉 onChange，onBlur，value */&#125; &lt;Field className=&#123;styles.input&#125; name="username" placeholder="请输入账号" /&gt; &lt;/div&gt; &#123;/* #step3: 导入 ErrorMessage 组件，替换原来的错误消息逻辑代码 */&#125; &lt;ErrorMessage className=&#123;styles.error&#125; name="username" component="div" /&gt; &lt;button className=&#123;styles.submit&#125; type="submit"&gt;登 录&lt;/button&gt; &lt;/Form&gt; ); &#125;&#125;]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>Formik</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-virtualized]]></title>
    <url>%2F2020%2F02%2F06%2Freact-virtualized%2F</url>
    <content type="text"><![CDATA[react-virtualized 是一个优化长列表的插件，下面使用 List 基础组件，配合 AutoSizer、CellMeasurer、InfiniteLoader 等高阶组件，来做一个案例！ lorem-ipsum使用 lorem-ipsum 先来生成 3000 个列表 12345678910// 生成 3000 个列表const rowCount = 3000;const list = Array(rowCount).fill().map(() =&gt; &#123; return loremIpsum(&#123; count: 1, // 单词、句子或段落的数量 units: 'sentences', // word(单词)、sentence(段落)、paragraph(句子) sentenceLowerBound: 3, // 每句话的最小字数 sentenceUpperBound: 3 // 每句话的最大字数 &#125;);&#125;); List使用 List 组件渲染，把上面 3000 条数据渲染到页面中 123456789101112131415function rowRenderer(&#123; index, // 数组的索引 isScrolling, // 列表是否正在滚动中 isVisible, // 当前行在列表中是否是可见的 key, // 唯一 key parent, // 对父列表实例的引用 style // 应用到行列表的样式，用于定位&#125;) &#123; const item = list[index]; return ( &lt;div key=&#123;key&#125; style=&#123;style&#125;&gt; &#123;item&#125; &lt;/div&gt; );&#125; 12345export default class NewsList extends React.Component &#123; render() &#123; return &lt;List width=&#123;300&#125; height=&#123;300&#125; rowCount=&#123;list.length&#125; rowHeight=&#123;20&#125; rowRenderer=&#123;rowRenderer&#125; /&gt;; &#125;&#125; AutoSizerList 组件必须指定具体大小，使用 AutoSizer 可以使其动态适配父元素高度 12345678910&lt;AutoSizer&gt; &#123;(&#123; height, width &#125;) =&gt; &lt;List width=&#123;width&#125; height=&#123;height&#125; rowCount=&#123;list.length&#125; rowHeight=&#123;20&#125; rowRenderer=&#123;rowRenderer&#125; /&gt;&#125;&lt;/AutoSizer&gt; CellMeasurer子元素太长时，使用 CellMeasurer 组件自适应高度。注意实现的效果是页面加载时的自适应，window.onresize 并不会自适应 1234567891011// #1 修改了 List 组件的 rowHeight=&#123;cache.rowHeight&#125;// #2 修改了 List 组件的 rowRenderer// #3 新增了 List 组件 deferredMeasurementCache 属性&lt;List width=&#123;width&#125; height=&#123;height&#125; rowCount=&#123;list.length&#125; rowHeight=&#123;cache.rowHeight&#125; rowRenderer=&#123;rowRenderer&#125; deferredMeasurementCache=&#123;cache&#125;/&gt; 关于 rowRenderer 函数的解释 1234567891011121314151617181920// defaultHeight: 行最初的高度// fixedWidth: 行的宽度是否是动态的const cache = new CellMeasurerCache(&#123; defaultHeight: 30, fixedWidth: true &#125;);// cache: Cache to be shared between CellMeasurer and its parent Grid// columnIndex: 列的索引，渲染的只有行没有列，写 0 即可// rowIndex: 行的索引function rowRenderer(&#123; index, // 数组的索引 key, // 唯一 key parent, // 对父列表实例的引用 style // 应用到行列表的样式，用于定位&#125;) &#123; return ( &lt;CellMeasurer cache=&#123;cache&#125; columnIndex=&#123;0&#125; key=&#123;key&#125; parent=&#123;parent&#125; rowIndex=&#123;index&#125;&gt; &lt;div style=&#123;style&#125;&gt; &#123;list[index]&#125; &lt;/div&gt; &lt;/CellMeasurer&gt; );&#125; InfiniteLoader使用 InfiniteLoader 动态加载数据，代码链接]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>react-virtualized</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[防抖和节流]]></title>
    <url>%2F2020%2F02%2F05%2Fdebouceandthrottle%2F</url>
    <content type="text"><![CDATA[防抖和节流容易混淆，其实一句话就能说清楚！ 防抖：持续触发（事件）不执行，不触发的一段时间之后再执行 12345678910111213141516const debouce = (fn, time) =&gt; &#123; let timer = null; return function () &#123; clearTimeout(timer); timer = setTimeout(() =&gt; &#123; fn.apply(this, arguments); // 这样写需要上面传递一下 // fn.call(this, e); &#125;, time); &#125;;&#125;;const box = document.getElementById('box');box.onmousemove = debouce(function (e) &#123; console.log(this, e);&#125;, 1000); 节流：持续触发（事件）也执行，但执行的频率变低了 1234567891011121314151617181920const throttle = (fn, time) =&gt; &#123; let bBar = true; return function () &#123; if (bBar) &#123; // 持续触发的话，bBar 一直是 false，这里就不会再次进来 bBar = false; setTimeout(() =&gt; &#123; fn.apply(this, arguments); // 这样写需要上面传递一下 // fn.call(this, e); // 定时器到达之后再把开关打开，函数就会执行 bBar = true; &#125;, time); &#125; &#125;;&#125;;const box = document.getElementById('box');box.onmousemove = throttle(function (e) &#123; console.log(this, e);&#125;, 1000);]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>debounce</tag>
        <tag>throttle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类数组转数组分析]]></title>
    <url>%2F2019%2F12%2F20%2Farray-like%2F</url>
    <content type="text"><![CDATA[12// 为了方便对类数组进行操作，有时候需要进行转换成数组，下面的操作都会以此类数组举例let arrlike = &#123; 0: '深圳', 1: '郑州', 2: '武汉', length: 3 &#125;; 移花接个木利用 Call 或 apply 改变数组方法下的 this 指向，达到“借用”的目的！ Array.prototype.slice：slice(begin, end) 方法返回一个新的数组对象（包括 begin，不包括end），原始数组不会被改变。 1234// 基本使用let arr = Array.prototype.slice.call(arrlike);arr.push('西安');console.log(arr); // ["深圳", "郑州", "武汉", "西安"] 123456789// 为什么改变 slice 方法内部的 this 指向就能实现类数组转数组呢？// 假设 slice 内部是下面的实现方式你是否可以理解了呢？Array.prototype.slice = function (start=0, end=this.length) &#123; let newArr = []; for (let i = start; i &lt; end; i++) &#123; newArr[newArr.length] = this[i]; &#125; return newArr;&#125;; 123456789101112// 注意细节：slice 是浅拷贝，修改 newArr 会影响原 arrlikelet arrlike = &#123; 0: '深圳', 1: '郑州', 2: &#123; age: 18 &#125;, length: 3&#125;;let newArr = Array.prototype.slice.call(arrlike);newArr['2'].age = 19;console.log(arrlike['2'].age); // 19 Array.prototype.splice：splice(start, deleteCount, item1, item2, …) 以数组形式返回被修改的内容，此方法会改变原数组。 12345// splice 也可以实现类数组转成数组，原理同上（splice内部实现要依赖 this）// 需要注意的是 splice 会对原类数组产生影响let newArr = Array.prototype.splice.call(arrlike, 0);newArr.push('西安');console.log(newArr); // ["深圳", "郑州", "武汉", "西安"] Array.prototype.concat：同理 concat 也可以实现同样的功能 123let newArr = Array.prototype.concat.apply([], arrlike);newArr.push('西安');console.log(newArr); // ["深圳", "郑州", "武汉", "西安"] 扩展运算符1console.log([...arrlike]); // TypeError: arrlike is not iterable 关于 Iterator 接口 12345678910// 注意扩展运算符只能转换具备 Iterator 接口的数据，可改写如下let arrlike = &#123; 0: '深圳', 1: '郑州', length: 2, [Symbol.iterator]: Array.prototype[Symbol.iterator]&#125;;let arr = [...arrlike]arr.push('北京');console.log(arr); // ["深圳", "郑州", "北京"] Array.from推荐使用 ES6 新增的 Array.from 方法，语法简洁且通用！ 12345678let arrlike = &#123; 0: '深圳', 1: '郑州', length: 2&#125;;let arr = Array.from(arrlike);arr.push('北京');console.log(arr); // ["深圳", "郑州", "北京"]]]></content>
      <categories>
        <category>JS 高级</category>
      </categories>
      <tags>
        <tag>类数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB 基本操作]]></title>
    <url>%2F2019%2F12%2F05%2Fmongo%2F</url>
    <content type="text"><![CDATA[操作数据库1234567891011mongod --dbpath=./ // 通过 shell 连接 MongoDB 服务show dbs // 查看有哪些数据库db use school // 使用 school 数据库db.students.insert(&#123;name: 'ifer', age: 18&#125;) // 当前数据库中创建集合并插入文档db // 查看当前在哪个数据库db.dropDatabase() // 删除当前数据库 操作集合12345678// 查看集合使用帮助db.students.help()db.students.find().help()// 查看集合show collections// 创建集合，一般使用 db.students.insert(document) 创建集合并插入文档db.createCollection('teachers') 创建文档12345// insert 不能插入重复的 _iddb.students.insert(&#123;_id: 1, name: 'ifer', age: 18&#125;)// save 当插入有重复 _id 的时候，会当前当前文档db.students.save(&#123;_id: 1, name: 'ifer', age: 18&#125;) 更新文档12345678db.collection.update( &lt;queryObj&gt;, // 查询条件 &lt;updateObj&gt;, // 更新的对象 &#123; upsert: &lt;boolean&gt;, // 如果不存在符合条件的记录时，是否插入，默认 false multi: &lt;boolean&gt; // 默认只更新符合条件的第一条记录，如果为 true 则更新所有符合条件的 &#125;) 123456789101112131415161718db.students.update(&#123; name: 'ifer'&#125;,&#123; name:'elser' // 注意这里没有加 $set 会整体把匹配到的文档变成只有 &#123;name: elser&#125;&#125;,&#123; upsert:true&#125;)// 把所有 name 为 elser 的更新为 iferdb.students.update(&#123; name: 'elser'&#125;,&#123; $set: &#123; // 注意这里要配合 $set 使用 name:'ifer' &#125;&#125;,&#123; multi:true&#125;) 更新符号$set：指定需要更新的字段 1db.students.update(&#123;_id: 1&#125;, &#123;$set: &#123;name: 'test2'&#125;&#125;) $inc：在此字段基础上增加数字，例如之前 age 是 1，下面代码执行后 age 就变成了 19 1db.students.update(&#123;_id: 1&#125;, &#123;$inc: &#123;age: 18&#125;&#125;) $unset：删除指定的字段和值 1db.students.update(&#123;_id: 1&#125;, &#123;$unset: &#123;age: 18&#125;&#125;) $push：向数组中增加元素 12// 原来的 hobbies 字段不必存在db.students.update(&#123;_id: 1&#125;, &#123;$push: &#123;hobbies: '喝酒'&#125;&#125;) $ne：not in / not exist / not equal 12// 之前的 hobbies 字段要保证是一个数组才能 pushdb.students.update(&#123;name:'ifer',hobbies:&#123;$ne:'抽烟'&#125;&#125;,&#123;$push:&#123;"hobbies":"烫头"&#125;&#125;); $addToSet: 向集合（这个集合指的是 hobbies）中增加元素 1db.students.update(&#123;name:'ifer'&#125;,&#123;$addToSet:&#123;'hobbies':'烫头'&#125;&#125;, &#123;multi: true&#125;); $each: 把数组中的元素逐个添加到集合中 12const arr = ['JS', 'Node', 'HTML'];db.students.update(&#123;name:'ifer'&#125;,&#123;$addToSet:&#123;hobbies:&#123;$each:arr&#125;&#125;&#125;); $pop: 删除数组中指定索引对应的元素 12345// -1 顺着删，1 倒着删db.students.update(&#123;name:'ifer'&#125;,&#123;$pop:&#123;hobbies:1&#125;&#125;);// 修改指定索引元素db.students.update(&#123;name:'ifer'&#125;,&#123;$set:&#123;'hobbies.1': 'hello world'&#125;&#125;); 删除文档123456db.collection.remove( &lt;query&gt;, // 查询条件 &#123; justOne: &lt;boolean&gt; // 为 true 或 1 则只删除匹配多条中的1个 &#125;) 1db.students.remove(&#123;name:'zfpx2'&#125;); 查询文档find 123db.students.find()// 1 显示，0 不显示db.students.find(&#123;&#125;,&#123;name:1, _id:0&#125;) findOne 1db.students.findOne() $in: 查询包含某些项 12// 查询 age 为 10 或 11 的 documentdb.students.find(&#123;age:&#123;$in:[10,11]&#125;&#125;,&#123;age:1&#125;); $nin: 不查询包含某些项 12// 查询 age 不为 10 或 11 的 documentdb.students.find(&#123;age:&#123;$nin:[10,11]&#125;&#125;,&#123;age:1&#125;); $not: 对特定条件取反 12// 不要年龄大于 20 小于 30的db.students.find(&#123;age:&#123;$not:&#123;$gte:20,$lte:30&#125;&#125;&#125;); array: 查询 array 中的内容 123456789101112131415161718// 按所有元素匹配// db.students.find(&#123;hobbies:[ "JS", "hello world", "HTML"]&#125;);// 匹配一项 包含A的就可以// db.students.find(&#123;hobbies:"JS"&#125;);// $all 必须同时包含A B// db.students.find(&#123;hobbies:&#123;$all:['JS',"hello world"]&#125;&#125;);// $in 或者关系 ，包含A或者B// db.students.find(&#123;hobbies:&#123;$in:['JS',"Node"]&#125;&#125;);// $size 按数组的长度去匹配// db.students.find(&#123;hobbies:&#123;$size:4&#125;&#125;);// $slice 只返回数组中的某一部分// db.students.find(&#123;hobbies:&#123;$size:3&#125;&#125;,&#123;name:1,hobbies:&#123;$slice:2&#125;&#125;); // 前 2 项// db.students.find(&#123;hobbies:&#123;$size:3&#125;&#125;,&#123;name:1,hobbies:&#123;$slice:-2&#125;&#125;); // 后 2 项 where 1db.students.find(&#123;$where:"this.age&gt;30"&#125;); cursor: 游标不是查询结果，而是查询的一个返回资源或者接口，通过这个接口，可以逐条读取数据 条件操作符1234567891011121314151617// 大于db.students.find(&#123;age:&#123;$gt:30&#125;&#125;)// 大于等于db.students.find(&#123;age:&#123;$gte:30&#125;&#125;)// 小于db.students.find(&#123;age:&#123;$lt:30&#125;&#125;)// 小于等于db.students.find(&#123;age:&#123;$lte:30&#125;&#125;)// 大于等于 10 小于等于 18db.students.find(&#123;age: &#123;$gte: 10, $lte: 18&#125;&#125;)// 等于db.students.find(&#123;"age": 18&#125;) 12// 使用 ID 进行查询db.students.find(&#123;_id:ObjectId("5de8f76b5bcdb8733a40a325")&#125;) 12// 查询结果集的条数db.students.find().count() 1234// 正则匹配db.students.find(&#123;name:/f/&#125;) // 包含 fdb.students.find(&#123;name:/^i/&#125;) // 以 i 开头 与和或12// 与db.students.find(&#123;name:'ifer',age:1&#125;) 12// $ordb.students.find(&#123;$or:[&#123;age:18&#125;,&#123;age:19&#125;]&#125;) 12// 与或连用db.students.find(&#123;name:'ifer',$or:[&#123;age:18&#125;,&#123;age:19&#125;]&#125;) 分页查询1234567891011// limitdb.students.find().limit(3)// skipdb.students.find().skip(1)// skip + limit，第 3 ~ 4 之间的数据db.students.find().skip(2).limit(2)// sort，1 升序，-1 降序db.students.find().sort(&#123;age:1&#125;) 执行脚本123let user = &#123;name: 'elser', age: 15 &#125;;let db = connect('school'); // 选择 school 数据库，所以当前不必在 school 数据库下db.students.insert(user); 1234567let start = Date.now();let db = connect('school'); // scholl 数据库for (let i = 0; i &lt; 1000; i++) &#123; db.students.insert(&#123; name: 'elser' + i &#125;); // students 集合&#125;let cost = Date.now() - start;print('cost ' + cost + ' ms'); 12345678910let start = Date.now();// mongodb://127.0.0.1:27017/schoollet db = connect('school');let users = [];for (let i = 0; i &lt; 1000; i++) &#123; users.push(&#123; name: 'ifer' + i &#125;);&#125;db.students.insert(users);let cost = Date.now() - start;print('cost ' + cost + ' ms'); 12// 命令行中执行mongo test.js 备份与导出 12mongodump // 会把所有数据备份到当前命令行目录的 dump 目录下mongodump -h 127.0.0.1 -d school -o "D:\Mongo\bak" 12// school 数据库名字（随意）、备份时候的数据库路径mongorestore -d school "D:\Mongo\bak\school" 权限管理123456789101112131415161718192021// 进入数据库mongo// 创建超级管理员use admindb.createUser(&#123;user: 'root', pwd: 'root', roles: ['root']&#125;)// 创建普通用户use blogdb.createUser(&#123;user: 'ifer', pwd: 'ifer', roles: ['readWrite']&#125;)// 斩断之前的服务net stop MongoDBmongod --remove// 开启新的服务mongod --bind_ip 0.0.0.0 --logpath="D:\Soft\MongoDb\log\mongod.log" --dbpath="D:\Soft\MongoDb\data" --install --authnet start MongoDB// 上面命令行中的所有配置信息，也可以通过配置并加载mongod.cfg文件完成mongod --config "D:\Soft\MongoDb\bin\mongod.cfg"]]></content>
      <categories>
        <category>服务端编程</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React 必知必会]]></title>
    <url>%2F2019%2F08%2F01%2Freact-base%2F</url>
    <content type="text"><![CDATA[常见绑定事件的操作查看代码 结论：应尽量避免 render 中使用箭头函数或 bind 绑定！ bind 的形式 123handleClick() &#123; this.setState((prevState, props) =&gt; (&#123;num: prevState.num+1&#125;));&#125; 1&lt;Button type="primary" onClick=&#123;this.handleClick.bind(this)&#125;&gt;点击&lt;/Button&gt; 定义实例方法时采用箭头函数的形式，推荐！ 123handleClick = () =&gt; &#123; this.setState((prevState, props) =&gt; (&#123;num: prevState.num+1&#125;));&#125; 1&lt;Button type="primary" onClick=&#123;this.handleClick&#125;&gt;点击&lt;/Button&gt; 绑定事件时采用箭头函数的形式 123handleClick() &#123; this.setState((prevState, props) =&gt; (&#123;num: prevState.num+1&#125;));&#125; 1&lt;Button type="primary" onClick=&#123;() =&gt; this.handleClick()&#125;&gt;点击&lt;/Button&gt; 实例方法和绑定事件都采用箭头函数的形式 123handleClick = () =&gt; &#123; this.setState((prevState, props) =&gt; (&#123;num: prevState.num+1&#125;));&#125; 12// 方便值的传递&lt;Button type="primary" onClick=&#123;() =&gt; this.handleClick()&#125;&gt;点击&lt;/Button&gt; constructor 中就扭正 this 的指向 1234567constructor(props) &#123; super(props); this.state = &#123; num: 0 &#125;; this.handleClick = this.handleClick.bind(this);&#125; 123handleClick() &#123; this.setState((prevState, props) =&gt; (&#123;num: prevState.num+1&#125;));&#125; 1&lt;Button type="primary" onClick=&#123;this.handleClick&#125;&gt;点击&lt;/Button&gt; Error Boundaries部分 UI 的 JavaScript 错误不应该导致整个应用崩溃，为了解决这个问题，React 16 引入了一个新的概念 —— 错误边界。查看代码 123456789export default class App extends Component &#123; render() &#123; return ( &lt;ErrorBoundary&gt; &lt;Test/&gt; &lt;/ErrorBoundary&gt; ); &#125;&#125; 12345678910111213141516171819202122export class ErrorBoundary extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; error: false &#125;; &#125; componentDidCatch(error, info) &#123; this.setState(&#123; error, info &#125;); &#125; render() &#123; if(this.state.error) &#123; return ( &lt;h1&gt;出错啦！&lt;/h1&gt; ); &#125; return this.props.children; &#125;&#125; Portals查看代码 可以将子节点渲染到存在于父组件以外的 DOM 节点，常用于弹框、对话框等。 123456789101112131415161718192021class Modal extends Component &#123; constructor(props) &#123; super(props); this.container = document.createElement('div'); document.body.appendChild(this.container); &#125; componentWillUnmount() &#123; document.body.removeChild(this.container); &#125; render() &#123; return ReactDOM.createPortal( &lt;div className="modal"&gt; &lt;span className="close" onClick=&#123;this.props.onClose&#125;&gt;&amp;times;&lt;/span&gt; &lt;div className="content"&gt; &#123;this.props.children&#125; &lt;/div&gt; &lt;/div&gt;, this.container ) &#125;&#125; 123456789101112131415161718192021222324252627export default class Test extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; showModal: true &#125;; &#125; closeModal = () =&gt; &#123; this.setState(&#123; showModal: false &#125;); &#125; render() &#123; return ( &lt;&gt; &lt;h2&gt;标题&lt;/h2&gt; &#123; this.state.showModal &amp;&amp; ( &lt;Modal onClose=&#123;this.closeModal&#125;&gt; Modal Dialog &lt;/Modal&gt; ) &#125; &lt;/&gt; ); &#125;&#125; Fragments查看代码 Fragments 允许你将子列表分组，而无需向 DOM 添加额外节点 1234567891011export default class Fragment extends Component &#123; render() &#123; return ( &lt;React.Fragment&gt; &lt;p&gt;1&lt;/p&gt; &lt;p&gt;2&lt;/p&gt; &lt;p&gt;3&lt;/p&gt; &lt;/React.Fragment&gt; ); &#125;&#125; 原理实现如下 12345678910111213// const Fragment = (&#123;children&#125;) =&gt; children;const Fragment = (props) =&gt; props.children;export default class Fragment extends Component &#123; render() &#123; return ( &lt;Fragment&gt; &lt;p&gt;1&lt;/p&gt; &lt;p&gt;2&lt;/p&gt; &lt;p&gt;3&lt;/p&gt; &lt;/Fragment&gt; ); &#125;&#125; Ref 获取元素/组件需求：打开页面使 Input 获取焦点，查看代码 通过 this.refs.xxx 1&lt;input type="text" ref="inputRef"/&gt; 1234// 注意是 componentDidMountcomponentDidMount() &#123; this.refs.inputRef.focus();&#125; 通过 ref 接受一个函数进行处理 1&lt;input type="text" ref=&#123;ele =&gt; ele.focus()&#125;/&gt; 或者 1234componentDidMount() &#123; this.inputRef.focus();&#125;&lt;input type="text" ref=&#123;ele =&gt; this.inputRef=ele&#125;/&gt; 利用 React.createRef() 1234constructor(props) &#123; super(props); this.inputRef = React.createRef();&#125; 123componentDidMount() &#123; this.inputRef.current.focus();&#125; 1&lt;input type="text" ref=&#123;this.inputRef&#125;/&gt; 如何自取子组件（函数）中的 DOM 节点？ 12345678910111213141516171819202122232425262728293031323334import React, &#123;Component&#125; from 'react';export default class AboutRef extends Component &#123; constructor(props) &#123; super(props); this.inputRef = React.createRef(); &#125; handleClick = () =&gt; &#123; // this.inputRef.current.refs.test.style.backgroundColor = 'red'; this.inputRef.current.style.backgroundColor = 'red'; &#125; render() &#123; return ( &lt;div&gt; &lt;Test ref=&#123;this.inputRef&#125;/&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;改变组件&lt;/button&gt; &lt;/div&gt; ); &#125;&#125;/* class Test extends Component &#123; render() &#123; return ( &lt;div ref="test"&gt;hello world&lt;/div&gt; ); &#125;&#125; */const Test = React.forwardRef((props, ref) =&gt; &#123; return ( &lt;div ref=&#123;ref&#125;&gt;hello world&lt;/div&gt; );&#125;); 新增生命周期v16.3 新增，v16.4 再次更新了 getDerivedStateFromProps，查看代码 12345static getDerivedStateFromProps(nextProps, prevState) &#123; // 将传入的 props 映射到 state 上面，props 更新 和 setState 时都会触发 const &#123; number &#125; = nextProps; return number % 2 === 0 ? &#123; num: number + 1 &#125; : &#123; num: number + 3 &#125;;&#125; 123456789getSnapshotBeforeUpdate() &#123; // 发生于 render 之后，但并没有渲染完毕，可以从 DOM 中捕获一些信息（例如滚动之前的高度） // 返回值会作为 componentDidUpdate 的第三个参数 console.log(2); return this.ulRef.current.offsetHeight&#125;componentDidUpdate(prevProps, prevState, snapshot) &#123; console.log(snapshot);&#125; 跨组件传值查看代码 旧版 Context API12345// Step1: 父static childContextTypes=&#123; color: PropTypes.string, changeColor:PropTypes.func&#125; 123456789// Step2: 父getChildContext() &#123; return &#123; color: this.state.color, changeColor:(color)=&gt;&#123; this.setState(&#123;color&#125;) &#125; &#125;&#125; 12345// step3: 子孙static contextTypes=&#123; color: PropTypes.string, changeColor:PropTypes.func&#125; 12// step4: 子孙&lt;button onClick=&#123;() =&gt; this.context.changeColor('pink')&#125;&gt;改变孙子的颜色&lt;/button&gt; 新版 Context APIReact 16.3 12// Step1: 全局const ThemeContent = React.createContext(); 123456789101112// Step2: 父const ctx = &#123; color: this.state.color, changeColor: this.changeColor&#125;;&lt;ThemeContent.Provider value=&#123;ctx&#125;&gt; &lt;div style=&#123;&#123; border: '3px solid red' &#125;&#125;&gt; &lt;h1&gt;父&lt;/h1&gt; &lt;Large1 /&gt; &lt;Large2 /&gt; &lt;/div&gt;&lt;/ThemeContent.Provider&gt; 1234567891011// Step3: 子孙&lt;ThemeContent.Consumer&gt;&#123; value =&gt; ( &lt;div style=&#123;&#123; border: '3px solid red', margin: 10, color: value.color &#125;&#125;&gt; &lt;h4&gt;孙子2&lt;/h4&gt; &lt;button onClick=&#123;() =&gt; value.changeColor('pink')&#125;&gt;改变孙子的颜色&lt;/button&gt; &lt;/div&gt; )&#125;&lt;/ThemeContent.Consumer&gt; 上面的 Step3 也可以改写如下： React16.6 提供的 API 1static contextType = ThemeContent; 1&lt;button onClick=&#123;() =&gt; this.context.changeColor('pink')&#125;&gt;改变孙子的颜色&lt;/button&gt; PureComponent浅比较新旧 props 和 state，发生变化时才会更新组件，提高效率！查看代码 React.memo()查看代码 PureComponent 要和 class component 配合使用，而 React.memo() 可以和 function component 一起使用，例如： 123456789function Child(props) &#123; console.log('res 没有变化时我不会 render ~~'); return ( &lt;div&gt; 结果是：&#123;props.res&#125; &lt;/div&gt; )&#125;Child = React.memo(Child); React.lazy()可以实现基于路由的代码分割/懒加载，查看代码 1234567891011121314151617181920212223import React, &#123; Suspense, lazy, Component &#125; from 'react';import &#123; HashRouter as Router, Route, Switch, Link &#125; from 'react-router-dom';const Home = lazy(() =&gt; import('./Home'));const News = lazy(() =&gt; import('./News'));// render 时需要 return 的内容如下&lt;Router&gt; &lt;Suspense fallback=&#123;&lt;div&gt;loading...&lt;/div&gt;&#125;&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to="/"&gt;Home&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to="/news"&gt;News&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;Switch&gt; &lt;Route exact path="/" component=&#123;Home&#125; /&gt; &lt;Route path="/news" component=&#123;News&#125; /&gt; &lt;/Switch&gt; &lt;/Suspense&gt;&lt;/Router&gt; 高阶组件及应用高阶组件是一个函数，能对接收过来的组件进行加工后再返回！查看代码 12345678910111213141516// 基本操作const Logger = (Com) =&gt; &#123; return class extends Component &#123; render() &#123; return &lt;Com &#123;...this.props&#125;/&gt;; &#125; &#125;&#125;const Hello = Logger((props) =&gt; &#123; return ( &lt;p&gt;Hello &#123;props.name&#125;&lt;/p&gt; )&#125;);&lt;Hello name="Ifer"/&gt; 1234567891011121314151617181920212223242526272829303132// 案例import React, &#123;Component&#125; from 'react';const withFetch = url =&gt; View =&gt; &#123; return class extends Component &#123; constructor() &#123; super(); this.state = &#123; loading: true, data: null &#125;; &#125; async componentDidMount() &#123; const res = await fetch(url); const data = await res.json(); this.setState(&#123; loading: false, data &#125;); &#125; render() &#123; if(this.state.loading) &#123; return &lt;div&gt;loading...&lt;/div&gt; &#125; else &#123; // 注意这里不要忘记把 this.props 继续往下传递，不然使用高阶组件封装后的组件时无法传递 props return &lt;View data=&#123;this.state.data&#125; &#123;...this.props&#125;&gt;&lt;/View&gt; &#125; &#125; &#125;&#125;;export default withFetch; 12345678910import React from 'react';import withFetch from './WithFetch';const User = withFetch('https://randomuser.me/api/')(props =&gt; &#123; return ( &lt;h1&gt;邮箱：&#123;props.data.results[0].email&#125; 年龄：&#123;props.age&#125;&lt;/h1&gt; );&#125;);export default User; Render Props123456789101112131415161718192021import React from 'react';export default class Mouse extends React.Component &#123; state = &#123; x: 0, y: 0 &#125;; handleMousemove = e =&gt; &#123; this.setState(&#123; x: e.clientX, y: e.clientY &#125;); &#125;; componentDidMount() &#123; window.addEventListener('mousemove', this.handleMousemove); &#125; render() &#123; return this.props.render(this.state); // return this.props.children(this.state); // 当然对应的使用方式也要改变 &#125;&#125; 1234567891011121314151617181920&lt;Fragment&gt; &lt;Mouse render=&#123;mouse =&gt; &lt;p&gt; x坐标：&#123;mouse.x&#125;y坐标：&#123;mouse.y&#125; &lt;/p&gt;&#125; /&gt; &lt;Mouse render=&#123;(&#123; x, y &#125;) =&gt; &lt;img src=&#123;dog&#125; style=&#123;&#123; width: 100, position: 'absolute', top: y, left: x &#125;&#125; /&gt;&#125; /&gt;&lt;/Fragment&gt; HooksuseState12345678910111213import React, &#123; Component, useState &#125; from 'react';export default () =&gt; &#123; const [num, setNum] = useState(0); return ( &lt;div&gt; &lt;p&gt; &#123;num&#125; &lt;/p&gt; &lt;button onClick=&#123;() =&gt; setNum(num + 1)&#125;&gt;click&lt;/button&gt; &lt;/div&gt; );&#125;; useEffect12345678910111213141516import React, &#123; useState, useEffect &#125; from 'react';export default () =&gt; &#123; const [count, setCount] = useState(0); useEffect(() =&gt; &#123; console.log('useEffect=&gt;' + count); &#125;); return ( &lt;div&gt; &lt;p&gt; &#123;count&#125; &lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;click&lt;/button&gt; &lt;/div&gt; );&#125;; 相当于之前的 componentDidMount 和 componentDidUpdate 12345678910111213141516171819202122232425262728import React from 'react';export default class Test extends React.Component &#123; state = &#123; count: 0 &#125;; handleClick = () =&gt; &#123; this.setState(&#123; count: this.state.count + 1 &#125;); &#125;; componentDidMount() &#123; console.log('useEffect=&gt;' + this.state.count); &#125; componentDidUpdate() &#123; console.log('useEffect=&gt;' + this.state.count); &#125; render() &#123; return ( &lt;div&gt; &lt;p&gt; &#123;this.state.count&#125; &lt;/p&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;click&lt;/button&gt; &lt;/div&gt; ); &#125;&#125; useEffect 可以实现 componentWillUnmount，若 useEffect 第二个参数为空数组，代表只有组件销毁时才会执行返回的函数，假如传递了一个 count，代表 count 发生变化时就会执行返回的函数。 123456789const Index = () =&gt; &#123; useEffect(() =&gt; &#123; // console.log('欢迎来到 Index 页面'); return () =&gt; &#123; console.log('你离开了 Index 页面'); &#125;; &#125;, []); return &lt;div&gt;Index&lt;/div&gt;;&#125;; 123456789const List = () =&gt; &#123; useEffect(() =&gt; &#123; // console.log('欢迎来到 List 页面'); return () =&gt; &#123; console.log('你离开了 List 页面'); &#125;; &#125;, []); return &lt;div&gt;List&lt;/div&gt;;&#125;; 12345678910111213141516171819202122232425262728293031export default () =&gt; &#123; const [count, setCount] = useState(0); useEffect( () =&gt; &#123; return () =&gt; &#123; console.log('只要 count 变化就会执行这里的函数'); &#125;; &#125;, [count] ); return ( &lt;div&gt; &lt;p&gt; &#123;count&#125; &lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;click&lt;/button&gt; &lt;Router&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to="/"&gt;首页&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to="/list"&gt;列表&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;Route path="/" exact component=&#123;Index&#125; /&gt; &lt;Route path="/list" component=&#123;List&#125; /&gt; &lt;/Router&gt; &lt;/div&gt; );&#125;; useContext用于父子/孙组件传值 12345678910111213141516171819import React, &#123; useState, createContext, useContext &#125; from 'react';// step1const CountContext = createContext();export default () =&gt; &#123; const [count, setCount] = useState(0); return ( &lt;div&gt; &lt;p&gt; &#123;count&#125; &lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;click&lt;/button&gt; &#123;/* step2 */&#125; &lt;CountContext.Provider value=&#123;count&#125;&gt; &lt;Counter1 /&gt; &lt;/CountContext.Provider&gt; &lt;/div&gt; );&#125;; 12345678910111213const Counter1 = () =&gt; &#123; return &lt;Counter2 /&gt;;&#125;;const Counter2 = () =&gt; &#123; // step3 const count = useContext(CountContext); return ( &lt;div&gt; &#123;count&#125; &lt;/div&gt; );&#125;; userReducer123456789101112131415161718192021222324import React, &#123; useReducer &#125; from 'react';export default () =&gt; &#123; const [count, dispatch] = useReducer((state, action) =&gt; &#123; switch (action) &#123; case 'add': return state + 1; case 'sub': return state - 1; default: return state; &#125; &#125;, 0); return ( &lt;div&gt; &lt;p&gt; &#123;count&#125; &lt;/p&gt; &lt;button onClick=&#123;() =&gt; dispatch('add')&#125;&gt;add&lt;/button&gt; &lt;button onClick=&#123;() =&gt; dispatch('sub')&#125;&gt;sub&lt;/button&gt; &lt;/div&gt; );&#125;; useReducer 模拟 redux 效果用到了 createContext、useContext、useReducer 123456789101112import React from 'react';import Color from './Color';import Card from './Card';import Buttons from './Buttons';export default () =&gt; &#123; return ( &lt;Color&gt; &lt;Card /&gt; &lt;Buttons /&gt; &lt;/Color&gt; );&#125;; 1234567891011121314151617181920212223242526272829// Color.jsimport React, &#123; createContext &#125; from 'react';import &#123; useReducer &#125; from 'react';// Step1export const ColorContext = createContext(&#123;&#125;);export const UPDATE_COLOR = 'UPDATE_COLOR';const reducer = (state, action) =&gt; &#123; switch (action.type) &#123; case UPDATE_COLOR: return action.color; default: return state; &#125;&#125;;const Color = props =&gt; &#123; const [color, dispatch] = useReducer(reducer, 'blue'); // Step2 return ( &lt;ColorContext.Provider value=&#123;&#123; color, dispatch &#125;&#125;&gt; &#123;props.children&#125; &lt;/ColorContext.Provider&gt; );&#125;;export default Color; 1234567891011121314// Card.jsimport React, &#123; useContext &#125; from 'react';import &#123; ColorContext &#125; from './Color';const Card = () =&gt; &#123; // Step3 const &#123; color &#125; = useContext(ColorContext); return ( &lt;div style=&#123;&#123; color &#125;&#125;&gt; 字体颜色为&#123;color&#125; &lt;/div&gt; );&#125;;export default Card; 12345678910111213141516171819202122232425262728// Buttons.jsimport React from 'react';import &#123; ColorContext, UPDATE_COLOR &#125; from './Color';import &#123; useContext &#125; from 'react';const Buttons = () =&gt; &#123; const &#123; dispatch &#125; = useContext(ColorContext); return ( &lt;div&gt; &lt;button onClick=&#123;() =&gt; &#123; dispatch(&#123; type: UPDATE_COLOR, color: 'red' &#125;); &#125;&#125; &gt; 红色 &lt;/button&gt; &lt;button onClick=&#123;() =&gt; &#123; dispatch(&#123; type: UPDATE_COLOR, color: 'blue' &#125;); &#125;&#125; &gt; 蓝色 &lt;/button&gt; &lt;/div&gt; );&#125;;export default Buttons; useMemo使用 function 的形式来声明组件，失去了 shouldCompnentUpdate（在组件更新之前）这个生命周期，也就是说我们没有办法通过组件更新前条件来决定组件是否更新。useMemo 解决此问题，它可以在某些状态变化时才执行某方法。 123456789101112// 问题：点击 number 按钮，count 的结果没变，但是改变 count 的方法每次都执行，这就是性能损耗export default () =&gt; &#123; const [count , setCount] = useState(0) const [number , setNumber] = useState(0) return ( &lt;&gt; &lt;button onClick=&#123;()=&gt;&#123;setCount(count+1)&#125;&#125;&gt;count++&lt;/button&gt; &lt;button onClick=&#123;()=&gt;&#123;setNumber(number+1)&#125;&#125;&gt;number++&lt;/button&gt; &lt;ChildComponent count=&#123;count&#125;&gt;&#123;number&#125;&lt;/ChildComponent&gt; &lt;/&gt; )&#125; 1234567891011121314151617import React , &#123;useState,useMemo&#125; from 'react';function ChildComponent(&#123;count,children&#125;)&#123; function changeCount(count)&#123; console.log('count 变化的方法执行了') return count; &#125; // const actionCount = changeCount(count) // [count] 代表只有 count 变化时才执行此函数 const actionCount = useMemo(() =&gt; changeCount(count), [count]); return ( &lt;&gt; &lt;div&gt;&#123;actionCount&#125;&lt;/div&gt; &lt;div&gt;&#123;children&#125;&lt;/div&gt; &lt;/&gt; )&#125; useRef123456789101112131415// 获取普通元素import React, &#123; useRef &#125; from 'react';export default () =&gt; &#123; const inputEl = useRef(null); const onButtonClick = () =&gt; &#123; inputEl.current.value = 'hello world'; &#125;; return ( &lt;div&gt; &lt;input type="text" ref=&#123;inputEl&#125; /&gt; &lt;button onClick=&#123;onButtonClick&#125;&gt;click&lt;/button&gt; &lt;/div&gt; );&#125;; 12345678910111213141516171819// 保存普通变量export default () =&gt; &#123; const [text, setText] = useState('xxx'); const textRef = useRef(); useEffect(() =&gt; &#123; // 把每次变化的 text 挂载到 textRef.current 上 textRef.current = text; console.log(textRef.current); &#125;); return ( &lt;input value=&#123;text&#125; onChange=&#123;e =&gt; &#123; setText(e.target.value); &#125;&#125; /&gt; );&#125;; 自定义 Hooks12345678910111213141516171819202122232425262728293031323334import React, &#123; useState, useEffect, useCallback &#125; from 'react';const useWinSize = () =&gt; &#123; // size 初始值是一个对象 const [size, setSize] = useState(&#123; width: document.documentElement.clientWidth, height: document.documentElement.clientHeight &#125;); const onResize = useCallback(() =&gt; &#123; setSize(&#123; width: document.documentElement.clientWidth, height: document.documentElement.clientHeight &#125;); &#125;, []); useEffect(() =&gt; &#123; window.addEventListener('resize', onResize); return () =&gt; &#123; // 组件卸载的时候解绑事件 window.removeEventListener('resize', onResize); &#125;; &#125;, []); return size;&#125;;export default () =&gt; &#123; const size = useWinSize(); return ( &lt;div&gt; 页面size: &#123;size.width&#125;x&#123;size.height&#125; &lt;/div&gt; );&#125;;]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React 技巧</tag>
        <tag>React 必知必会</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个栗子认识正则]]></title>
    <url>%2F2019%2F07%2F28%2Fregexp-case%2F</url>
    <content type="text"><![CDATA[需求：取出字符串 &#39;张三工资：10000，李四工资：20000，我：30000&#39; 中的所有工资放到数组中。 分别用字符串下的 match、split、replace、search 和正则下的 exec、test 实现，希望大家对正则配合 JS 的使用有一个基础的认识！ Match 匹配123const str = '张三工资：10000，李四工资：20000，我：30000';let reg = /\d+/g;console.log(str.match(reg)); // ["10000", "20000", "30000"] Match 通过改变正则分组捕获12345const str = '张三工资：10000，李四工资：20000，我：30000';let reg = /(\d+)，[\u4e00-\u9fa5]+：(\d+)，[\u4e00-\u9fa5]+：(\d+)/; // 加不加 g 无所谓str.match(reg);console.log([RegExp.$1, RegExp.$2, RegExp.$3]); // ["10000", "20000", "30000"] Split 分组str.split(/xxx/)，以 xxx 把字符串拆分成数组，并且把 xxx 干掉。str.split(/(xxx)/)，这样拆分后的结果也会保留 (xxx) 分组！ 12345678910let str = '张三工资：10000，李四工资：20000，我：30000';let reg = /(\d+)/g;let arr = str.split(reg);console.log(arr); // ["张三工资：", "10000", "，李四工资：", "20000", "，我：", "30000", ""]let newArr = [];for(let i = 1; i &lt; arr.length; i +=2) &#123; newArr.push(arr[i]);&#125;console.log(newArr); // ["10000", "20000", "30000"] Split 通过改变正则分组捕获12345const str = '张三工资：10000，李四工资：20000，我：30000';let reg = /(\d+)，[\u4e00-\u9fa5]+：(\d+)，[\u4e00-\u9fa5]+：(\d+)/; // 加不加 g 无所谓str.split(reg);console.log([RegExp.$1, RegExp.$2, RegExp.$3]); // ["10000", "20000", "30000"] Replace 匹配123456789let str = '张三工资：10000，李四工资：20000，我：30000';let reg = /\d+/g;let arr = [];// 正则对象匹配到的字符串，分组1，分组2，匹配到的字符串在元字符中的偏移量，被匹配的原字符串str.replace(reg, function(regExpStr, p1, offset,) &#123; arr.push(regExpStr);&#125;);console.log(arr); Replace 分组捕获123456789let str = '张三工资：10000，李四工资：20000，我：30000';let reg = /(\d+)/g;let arr = [];// 正则对象匹配到的字符串，分组1，分组2，匹配到的字符串在元字符中的偏移量，被匹配的原字符串str.replace(reg, function(regExpStr, p1, offset,) &#123; arr.push(p1);&#125;);console.log(arr); Replace 通过改变正则分组捕获12345const str = '张三工资：10000，李四工资：20000，我：30000';let reg = /(\d+)，[\u4e00-\u9fa5]+：(\d+)，[\u4e00-\u9fa5]+：(\d+)/; // 加不加 g 无所谓str.replace(reg);console.log([RegExp.$1, RegExp.$2, RegExp.$3]); // ["10000", "20000", "30000"] Search 通过改变正则分组捕获123456let str = '张三工资：10000，李四工资：20000，我：30000';let reg = /(\d+)，[\u4e00-\u9fa5]+：(\d+)，[\u4e00-\u9fa5]+：(\d+)/;str.search(reg);console.log([RegExp.$1, RegExp.$2, RegExp.$3]); Exec 匹配12345678910111213141516171819const str = '张三工资：10000，李四工资：20000，我：30000';RegExp.prototype.execAll = function () &#123; let str = arguments[0] || '', result = []; // 如果没有加 g 永远匹配的都是第一项是死循环，我们只让执行一次就行 if (!this.global) return this.exec(str); let arr = this.exec(str); // 匹配不上时 arr 就是 null while (arr) &#123; // 第 0 项就是全局匹配的结果 result.push(arr[0]); arr = this.exec(str); &#125; return result;&#125;;let reg = /\d+/g;console.log(reg.execAll(str)); // ["10000", "20000", "30000"] Exec 分组捕获12345678910111213141516const str = '张三工资：10000，李四工资：20000，我：30000';RegExp.prototype.execAll = function () &#123; let str = arguments[0] || '', result = []; if (!this.global) return this.exec(str); let arr = this.exec(str); while (arr) &#123; // 第 1 个分组 result.push(arr[1]); arr = this.exec(str); &#125; return result;&#125;;let reg = /(\d+)/g;console.log(reg.execAll(str)); // ["10000", "20000", "30000"] Exec 通过改变正则分组捕获12345const str = '张三工资：10000，李四工资：20000，我：30000';let reg = /(\d+)，[\u4e00-\u9fa5]+：(\d+)，[\u4e00-\u9fa5]+：(\d+)/;reg.exec(str);console.log([RegExp.$1, RegExp.$2, RegExp.$3]); // ["10000", "20000", "30000"] Test 分组捕获123456789let str = '张三工资：10000，李四工资：20000，我：30000';let reg = /(\d+)/g;let arr = [];while(reg.test(str)) &#123; // 每次 test lastIndex 的值都会变成下次开始查找的位置 arr.push(RegExp.$1);&#125;console.log(arr); // ["10000", "20000", "30000"] Test 通过改变正则分组捕获12345let str = '张三工资：10000，李四工资：20000，我：30000';let reg = /(\d+)，[\u4e00-\u9fa5]+：(\d+)，[\u4e00-\u9fa5]+：(\d+)/;reg.test(str);console.log([RegExp.$1, RegExp.$2, RegExp.$3]); // ["10000", "20000", "30000"]]]></content>
      <categories>
        <category>JS 高级</category>
      </categories>
      <tags>
        <tag>RegExp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES2015(ES6)]]></title>
    <url>%2F2019%2F07%2F15%2Fes5ores6%2F</url>
    <content type="text"><![CDATA[主要是 ES6 的知识梳理 ~ let/const12345// 有代码块的概念&#123; let a = 12;&#125;console.log(a);// ReferenceError: a is not defined 123// 不允许重复声明let a = 12;let a = 5; 123456let f = 10;function fn() &#123; f = 7; // 暂时性死去，报错 let f = 2;&#125;fn(); 123// 不支持预解析（变量提升）了console.log(a); // ReferenceError: a is not definedlet a = 1; 123456// 循环语句之内是一个父作用域，循环体之中是一个子作用域for(let i = 0; i &lt; 3; i ++) &#123; let i = 10; console.log(i);&#125;console.log(i); // 报错，i is not defined 1234567// const 必须给初始值，且一旦赋值，终身不变// const 对象的话是可以修改内部的值的const a = &#123; name: 'yangk'&#125;;a.name = 'momo';console.log(a.name); 关于字符串模板字符串1234// 基础套路let name = "yangk"let age = 22;let str = `my name is $&#123;name&#125;, age $&#123;age&#125;.`; 12345678// 尝试替换 $&#123;xxx&#125;let name = 'yangk';let age = 22;let str = 'my name is $&#123;name&#125;, age $&#123;age&#125;.';str = str.replace(/\$\&#123;([^&#125;]+)\&#125;/g, function() &#123; return eval(arguments[1]);&#125;); 12345// 标签函数function fn(args) &#123; console.log(args);&#125;fn`aaa`; 12345678910111213141516171819// 自定义模板let name = 'yangk';let age = 22;function fn() &#123; // console.log(arguments);// [["my name is ", ", age ", "."], "yangk", 22] let strings = arguments[0]; // 把第一项后面的变成数组 let values = [].slice.call(arguments, 1); let res = ''; for(let i = 0; i &lt; values.length; i ++) &#123; res += `$&#123;strings[i]&#125;~$&#123;values[i]&#125;~`; &#125; res += strings[strings.length - 1]; return res;&#125;let str = fn`my name is $&#123;name&#125;, age $&#123;age&#125;.`;console.log(str); 新增方法123// includes 代替 indexOflet str = 'hello world';console.log(str.includes('hello')); 1234// startWith/endsWithlet str = 'hello world';console.log(str.startsWith('hello'));// trueconsole.log(str.endsWith('world'));// true 123// repeatlet str = 'hello world';console.log(str.repeat(3)); // hello worldhello worldhello world 123456// padStart/padEndlet str = 'hello world';// 长度，要往前填充的内容console.log(str.padStart(20, 'x')); // xxxxxxxxxhello world// 长度，要往后填充的内容console.log(str.padEnd(20, 'x')); // hello worldxxxxxxxxx 解构赋值解构普通数组1let [a,b,c] = [12,54,74]; 12let [a, [b, c], d] = [12, [1, 2], 6];let [&#123;a, e&#125;, [b, c], d] = [&#123;a: 'haha',e: 'xixi'&#125;, [1, 2], 6]; 解构 JSON 对象12// 解构一个对象，与顺序无关let &#123;a,b,c&#125; = &#123;b: 5, c: 7, a: 12&#125; 123// 解构 [] 对象的 length 属性let &#123;length&#125; = ['哈', 9];console.log(length); // 2 12// 使用别名，不然直接使用 default 关键字会报错let &#123;default: d&#125; = &#123;default: 2&#125;; 123// 默认值let &#123;time=12,id=0&#125; = &#123;time:33&#125;;console.log(time); // 33 解构字符串12let [a, b, c, d] = '1234';console.log(a, b, c, d); 12let &#123;length: len&#125; = 'test';console.log(len); // 4 其他解构赋值12345let &#123;toString: ts&#125; = 1;let &#123;toString: bs&#125; = true;console.log(ts === Number.prototype.toString);console.log(bs === Boolean.prototype.toString); 注：null 和 undefined 是不能进行解构赋值的 Iterator 和 for ofIterator 可以为各种不同的数据结构提供统一的访问机制，任何数据结构只要部署 Iterator 接口，就可以完成遍历操作，而且这种遍历是依次进行的 为各种数据结构，提供一个统一的、简便的访问接口 使得数据结构的成员能够按某种次序排列 Iterator 结构主要供 for of 循环来消费 123456789101112131415161718192021222324252627// Iterator 遍历过程：// - 创建一个指针对象，指向当前数据结构的起始位置// - 第一次调用指针对象的 next 方法，将指针对象指向数据结构的第一个成员// - ...const arr = [1, 2, 3];function iterator(arr) &#123; let index = 0; return &#123; next: function() &#123; return index &lt; arr.length ? &#123; value: arr[index++], done: false &#125; : &#123; value: undefined, done: true &#125;; &#125; &#125;;&#125;let it = iterator(arr);console.log( it.next() );console.log( it.next() );console.log( it.next() );console.log( it.next() ); 有些数据结构本身就具备了 Iterator 接口，例如数组、字符串、set、map，对象就没有 Iterator 接口，凡是具有 Symbol.iterator 属性的数据结构都具有 Iterator 接口 12345678910111213141516const arr = [1, 2, 3];const set = new Set(['a', 'b', 'c']);const map = new Map([ ['name', 'aaayang']]);const itArr = arr[Symbol.iterator]();const itSet = set[Symbol.iterator]();const itMap = map[Symbol.iterator]();console.log(itArr, itSet, itMap); // 打印 Iterator 的对象指针console.log(itSet.next()); // &#123;value: 'a', done: false&#125;console.log(itSet.next());console.log(itSet.next());console.log(itSet.next()); 12const obj = &#123;&#125;;console.log(obj[Symbol.iterator]); // undefined，说明对象并不具备 Iterator 接口 具备 iterator 接口的数据结构都可以进行结构赋值、扩展运算符、for of 123const set = new Set(['a', 'b', 'c']);let [x, y] = set;console.log(x, y); 1234let str = 'test'; // 类数组，也具备 Iterator 接口let arrStr = [...str];console.log(arrStr); // ['t', 'e', 's', 't'] 1234// 数组去重let arr = [1, 1];let newArr = [...new Set(arr)];console.log(newArr); 12345let arr = ['a', 'b', 'c'];for (let i of arr) &#123; console.log(i); // a, b, c&#125; 123456const m = new Map();m.set('a', 1).set('b', 2).set('c', 3);for(let i of m) &#123; console.log(i); // ['a', 1], ['b', 2], ['c', 3]&#125; 123456const m = new Map();m.set('a', 1).set('b', 2).set('c', 3);// 也可以在循环的时候对数组进行解构for(let [k, v] of m) &#123; console.log(k, v); // a 1, b 2, c 3&#125; 给一个不具备 Iterator 接口的对象部署一个 Iterator 接口 123456789101112131415161718192021222324252627let obj = &#123; name: 'aaayang', age: 18&#125;;obj[Symbol.iterator] = function() &#123; let keys = Object.keys(obj); let len = keys.length; let i = 0; // 该函数必须返回一个对象 return &#123; // 返回对象中必须包含 next 方法，这个 next 方法就是给迭代进行调用的，比如 for of，每次迭代就是调用这个 next() next() &#123; return i &lt; len ? &#123; value: obj[keys[i++]], done: false &#125; : &#123; value: undefined, done: true &#125;; &#125; &#125;;&#125;;for(let i of obj) &#123; console.log(i);&#125; 展开和收缩主要针对的是数组（ES2018对象也可以了），既可以扩展，也可以收缩，也可以剩余（写在函数参数中） 扩展成多个（值）可以用来拷贝对象，并且对新对象的修改不会影响到原对象 123456let arr1 = [1, 2, 3];let arr2 = [];// 先扩展数组，在放进数组arr2 = [...arr1]; // 也可以 Array.from(arr1)arr2.pop();console.log(arr1); 12345let aDiv = document.getElementsByTagName('div');// let aEle = [].slice.call(aDiv);// Array.fromlet aEle = [...aDiv];console.log(aEle); 12345// 之前的做法function show(a,b,c,d) &#123; console.log(a,b,c,d);&#125;show.apply(null, [1, 2, 3, 4]); 12345// 现在的做法function show(a,b,c,d) &#123; console.log(a,b,c,d);&#125;show(...[1, 2, 3, 4]); 收缩为一个（数组）之前的做法是：Array.prototype.slice.call(arguments)，现在可以用 Array.from 或扩展运算符 12345function show(...args)&#123; args.push(5);// args 就是一个数组，直接可以push console.log(...args);&#125;show(1,2,3,4); 对象的收缩和展开12let &#123; x, y, ...z &#125; = &#123; x: 1, y: 2, z: 3, m: 4 &#125;;console.log(z); // &#123;z: 3, m: 4&#125; 1234// 常用来复制一个对象let json1 = &#123; x: 1, y: 2, z: 3, m: 4 &#125;;let json2 = &#123;...json1&#125;;console.log(json2); 关于数组reduce1234567// 求和，因为没有默认值，第一次 prev 是 1，next 是 2，nextIndex 就是 1let arr = [1, 2, 3, 4];let res = arr.reduce((prev, next, nextIndex, arr) =&gt; &#123; // 返回结果会作为下一次循环的 prev return prev + next;&#125;);console.log(res); 12345// 加默认值就多循环了一次，第一次 prev 是 0，next 是1，nextIndex 在数组中的索引也就是 0let arr = [1, 2, 3, 4];let res = arr.reduce((prev, next, nextIndex, arr) =&gt; &#123; return prev + next;&#125;,0); 123456789// 求平均数let arr = [1, 2, 3, 4];let res = arr.reduce((prev, next, nextIndex, arr) =&gt; &#123; if(arr.length -1 === nextIndex) &#123; return (prev + next)/arr.length; &#125; return prev + next;&#125;);console.log(res); 123456789101112131415161718// 默认值的使用let arr = [&#123; count: 1&#125;,&#123; count: 2&#125;,&#123; count: 3&#125;];/* let res = arr.reduce((prev, next, nextIndex, arr) =&gt; &#123; // 第一次没问题，第二次返回的结果 3 会作为下一次的 prev，3.count 这是什么鬼 return prev.count + next.count;&#125;); */let res = arr.reduce((prev, next, nextIndex, arr) =&gt; &#123; // 第一次 prev 为 0，next.count 就是 1，它们的和作为下一次的 prev，下一次的 next.count 又是 2 return prev + next.count;&#125;,0); 123456789101112// 实现 reduceArray.prototype.myReduce = function (fn, prev) &#123; for (let i = 0; i &lt; this.length; i++) &#123; if (typeof prev === 'undefined') &#123; prev = fn(this[i], this[i + 1], i + 1, this); // ++i; &#125; else &#123; prev = fn(prev, this[i], i, this); &#125; &#125; return prev;&#125;; 12345678910// 没有默认值，reduce 回调只执行了一次，只能展开二维数组let arr = [ [1,2,3], [4,5,6]];arr = arr.reduce((prev,next, nextIndex,ary) =&gt; &#123; return [...prev,...next];&#125;);console.log(arr); forEachforEach 可以完全代替 for 1234// ['a', 'b', 'c', 'd'].forEach(console.log);['a', 'b', 'c', 'd'].forEach(function (value, index, array) &#123; console.log(this,value); // this 默认 window，现在改成了 'xxx'&#125;, 'xxx'); 123['a', 'b', 'c', 'd'].forEach( (value, index, array) =&gt; &#123; console.log(this,value); // 用箭头函数第二个参数就凉了&#125;, 'xxx'); 1234// 注意 jQuery 中的第一个参数是 index ...$.each([], function(index, value, array) &#123; // ...&#125;); 1234567// 应用let sum = 0;[1, 2, 3, 4].forEach(function(value,index,array)&#123; // console.log(array[index] == value); sum += value;&#125;);console.log(sum);// 10 map123456// map 对元素重新组装，生成新数组let arr = [1, 2, 3, 4];let arrNew = arr.map(function (item) &#123; return item * item;// 一般配合return使用&#125;);console.log(arrNew); // 1, 4, 9, 16 filter12345678let arr = [1, 2, 3, 4];// filter 筛选出符合条件的元素，返回新数组let result3 = arr.filter(function(item, index) &#123; if(item &gt;= 2) &#123; return true; &#125;&#125;);console.log(result3); find123456// 返回数组中符合条件的第一个元素let array1 = [5, 12, 8, 130, 44];let found = array1.find(function (element) &#123; return element &gt; 10;&#125;);console.log(found); // 12 findIndex123456// 返回数组中符合的第一个元素的索引let array1 = [5, 12, 8, 130, 44];let found = array1.findIndex(function (element) &#123; return element &gt; 10;&#125;);console.log(found); // 1 some123456789let arr = [1, 2, 3, 4];// some 判断是否有至少一个元素符合条件，返回true or falselet result2 = arr.some(function (item, index) &#123; /* if (item &lt; 4) &#123; return true; &#125; */ return item &lt; 4;&#125;);console.log(result2); // true every123456789// every 判断所有元素是否都符合条件，返回true or falselet arr = [1, 2, 3, 4];let result = arr.every(function(item, index) &#123; /* if(item &lt; 4) &#123; return true; &#125; */ return item &lt; 4;&#125;);console.log(result); // false fill123let arr = new Array(5);arr.fill('xxx');console.log(arr); // ["xxx", "xxx", "xxx", "xxx", "xxx"] includes数组也有 includes，和字符串的一样的意思 from类数组转数组 复制一份对新赋值对象的修改不会影响原来的对象 12345let arr1 = [1, 2, 3];let arr2 = [];arr2 = Array.from(arr1);arr2.pop();console.log(arr1); 类数组转数组1234let aDiv = document.getElementsByTagName('div');// let aEle = [].slice.call(aDiv);let aEle = Array.from(aDiv);// 类数组转数组console.log(aEle); 12345678910// 一般有 length 就是类数组，就可以转let json = &#123; 0: 'xxx', 1: 'yyy', 2: 'zzz', length: 2&#125;;let arr = Array.from(json);console.log(arr); // ['xxx', 'yyy'] 字符串拆分成数组123let name = 'yangk';let arrName = Array.from(name);console.log(arrName); // ["y", "a", "n", "g", "k"] of也可以把一堆参数组合成数组 12let arr = Array.of(1,2,3,4,5);console.log(arr); // [1, 2, 3, 4, 5] flat会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回 12// depth 默认1var newArray = arr.flat(depth) 123var arr1 = [1, 2, [3, 4]];arr1 = arr1.flat();console.log(arr1); // [1, 2, 3, 4] 1234var arr = [1, 2, [3, 4, [5, 6]]];// 使用 Infinity 作为深度，展开任意深度的嵌套数组arr = arr.flat(Infinity);console.log(arr); 1234// 去重扁平化后的数组并排序var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10];arr = Array.from(new Set(arr.flat(Infinity))).sort((a,b) =&gt; a-b);console.log(arr); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14] 函数变更默认参数1234function show(a='hello', b='world') &#123; console.log(a,b);&#125;show(); 12345function show(&#123;x=0,y=1&#125;=&#123;&#125;) &#123; console.log(x,y);&#125;show(&#123;x:8&#125;); 箭头函数1234document.onclick = () =&gt; &#123; // this =&gt; window document.body.style.background = "red";&#125;; this 指向123456789let json = &#123; a: 1, b: 2, show: () =&gt; &#123; // this =&gt; window console.log(this.a); &#125;&#125;;json.show();// undefined 12345678910let json = &#123; a: 1, b: 2, show: () =&gt; &#123; setTimeout(() =&gt; &#123; console.log(this.a); &#125;, 1000); &#125;&#125;;json.show();// undefined 1234567891011let json = &#123; a: 1, b: 2, show: function() &#123; setTimeout(() =&gt; &#123; // 取决于父级中的 this console.log(this.a); &#125;, 1000); &#125;&#125;;json.show();// 1 arguments箭头函数中没有 arguments 1234let show = ()=&gt;&#123; console.log(arguments);// arguments is not defined&#125;;show(1,2,3); 12345// 常用let show = (...args) =&gt; &#123; console.log(args); // [1,2,3]&#125;;show(1, 2, 3); 简便写法1234567891011let name = "yangk";let age = 18;let person = &#123; name, age, showName()&#123; // this =&gt; window console.log(this.name); &#125;&#125;;person.showName(); 箭头函数不能当构造函数使用12345// 错误姿势let Show = (name) =&gt; &#123; this.name = name;&#125;let show = new Show('xxx'); 对象简洁语法12345678910111213let name = 'aaa';let age = 18;let json = &#123; name, age, // 里面的方法不要用箭头函数，不然自找蛋疼 showName() &#123; console.log(this.name); &#125;&#125;;json.showName(); // aaa ObjectObject.assign只会拷贝源对象自身的并且可枚举的属性到目标对象，注意是浅拷贝 12345678910111213let json1 = &#123; name: 'xxx'&#125;;let json2 = &#123; name: 'yyy', age: 18&#125;;let json3 = &#123; hobby: '足球'&#125;;// 目标用新的空对象，假如去掉会对原来的 json1 造成影响let obj = Object.assign(&#123;&#125;, json1, json2, json3); 1234// 也可以对数组进行复制操作let arr1 = ['a', 'b', 'c'];let arr2 = Object.assign([],arr1);console.log(arr2); Object.keys1234567let json = &#123; name: 'aaayang', age: 18&#125;;for(let key of Object.keys(json)) &#123; console.log(key); // name, age, for in 循环得到的是 0, 1&#125; Object.valuesObject.entriesObject.is1Object.is(NaN, NaN); // true 12console.log(+0 === -0); // trueconsole.log(Object.is(+0, -0)); // false setPrototypeOf1234567891011// 设let obj1 = &#123; name: 'aaayang'&#125;;let obj2 = &#123; age: 18&#125;;// 链：__proto__，任何东西都有obj1.__proto__ = obj2;// 先找自己的，找不到通过链找console.log(obj1.age); 1234// 取// console.log(obj1.__proto__); // &#123;age: 18&#125;Object.getPrototypeOf(obj1); // &#123;age: 18&#125; 12345678910111213// 可以通过 super 找到父let obj1 = &#123; name: 'aaayang'&#125;;let obj2 = &#123; name: 'bbb', getPName() &#123; return super.name; &#125;, __proto__: obj1&#125;;console.log(obj2.name); // bbbconsole.log(obj2.getPName()); // aaayang 异步的发展回调函数函数返回函数高阶函数：函数返回函数，或函数当做参数传递 1234567// 简单判断类型的需求function isType(type, content) &#123; return Object.prototype.toString.call(content) === `[object $&#123;type&#125;]`;&#125;// 麻烦isType('String', 'hello')isType('String', 'world') 1234567891011121314function isType(type) &#123; return function(content) &#123; return Object.prototype.toString.call(content) === `[object $&#123;type&#125;]`; &#125;&#125;let arr = ['String', 'Number', 'Array', 'Object', 'Null'];let util = &#123;&#125;;arr.forEach(item =&gt; &#123; util['is'+item] = isType(item);&#125;);console.log(util.isString('hello')); 函数当做参数高阶函数：函数返回函数，或函数当做参数传递 123456789101112131415161718// 调用 3 次 fn 才执行回调let fn = after(3, function() &#123; console.log('done');&#125;);// 当达到某个条件时执行 callbackfunction after(times, callback) &#123; return function() &#123; // 这里可以写一些逻辑 xxx // xxx if(--times === 0) &#123; callback(); &#125; &#125;&#125;fn();fn();fn(); // done 能干什么1234567891011121314151617// 把两个文件读取的结果同时打印出来let fs = require('fs');fs.readFile('./a.txt', 'utf-8', function(err, data) &#123; out(data);&#125;);fs.readFile('./b.txt', 'utf-8', function (err, data) &#123; out(data)&#125;);let arr = [];function out(data) &#123; arr.push(data); if (arr.length === 2) &#123; console.log(arr); &#125;&#125; 1234567891011121314151617181920212223// 改进上面的代码let fs = require('fs');function after(times, callback) &#123; // 可以缓存函数，当达到条件时执行回调函数 let arr = []; return function (data) &#123; arr.push(data); if (--times === 0) &#123; callback(arr); &#125; &#125;&#125;fs.readFile('./a.txt', 'utf-8', function (err, data) &#123; out(data);&#125;);fs.readFile('./b.txt', 'utf-8', function (err, data) &#123; out(data)&#125;);let out = after(2, function (arr) &#123; console.log(arr);&#125;); Promise12345678910let promise = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve('success'); &#125;, 1000);&#125;);promise.then(res =&gt; &#123; console.log(res);&#125;, err =&gt; &#123; console.log(err);&#125;); generator预热12345678910111213// 有索引，有长度，是一个类数组let obj = &#123; 0: 'hello', 1: 'world', length: 2&#125;;// 默认不可被迭代// let arr = [...obj];// 可以使用 Array.fromlet arr = Array.from(obj);console.log(arr); 12345678910111213141516171819202122// 模拟迭代let obj = &#123; 0: 'hello', 1: 'world', length: 2, // 迭代器函数，会返回一个对象，对象中必须有一个 next 方法 [Symbol.iterator]: function() &#123; let index = 0; let that = this; return &#123; next() &#123; return &#123; value: that[index], // 是否迭代完成 done: index++ === that.length &#125; &#125; &#125; &#125;&#125;;let arr = [...obj]; 123456789101112131415161718// 模拟迭代器function read(arr) &#123; let index = 0; return &#123; next() &#123; return &#123; value: arr[index], done: index++ &gt;= arr.length &#125;; &#125; &#125;;&#125;let it = read(['vue', 'react', 'angular']);console.log(it.next());console.log(it.next());console.log(it.next());console.log(it.next()); // &#123; value: undefined, done: true &#125; 正式开始generator 是一个生成器，生成的是上面我们模拟的迭代器，它可以把一个函数拆分成若干个部分执行。 123456function *gen() &#123; return 1000;&#125;let a = gen();// 碰到 return 认为迭代完成了console.log(a.next()); // &#123; value: 1000, done: true &#125; 123456function *gen() &#123; yield 1000;&#125;let a = gen();// yield 并不认为迭代完成console.log(a.next()); // &#123; value: 1000, done: false &#125; 12345678910111213// 第一次调用迭代器 next 传递的参数没有意义，想穿在调用生成器的时候穿// 第二次 next 传递的参数是上次 yield 的返回值 ...function *gen(xxx) &#123; let a = yield xxxx; let b = yield a; return b;&#125;let a = gen('买菜');console.log(a.next());console.log(a.next('买好的菜')); // 赋值给了 aconsole.log(a.next('做菜')); 12345678910111213141516171819202122232425262728293031323334/* const read = function(filename) &#123; return new Promise((resolve, reject) =&gt; &#123; fs.readFile(filename, (err, data) =&gt; &#123; if(err) reject(err); resolve(data.toString()); &#125;); &#125;);&#125;; */// 读取依赖文件，手工迭代let fs = require('fs');let &#123;promisify&#125; = require('bluebird');let read = promisify(fs.readFile);function * gen() &#123; // read 返回的是个 promise let b = yield read('a.txt', 'utf8'); let c = yield read(b, 'utf8'); let res = yield read(c, 'utf8'); return res;&#125;let it = gen();// it.next() 的 read 的返回结果，结果的value 是个 promiseit.next().value.then(data =&gt; &#123; // data =&gt; b.txt =&gt; 传递给上面的 b it.next(data).value.then(data =&gt; &#123; // data =&gt; c.txt =&gt; 传递给上面的 c it.next(data).value.then(data =&gt; &#123; // data =&gt; hello world =&gt; 传递给上面的 res console.log(it.next(data).value) &#125;); &#125;);&#125;); 12345678910111213141516// 用 co 帮我们执行上面的迭代，yield 后要求返回的是一个 promiselet fs = require('fs');let co = require('co');let &#123;promisify&#125; = require('bluebird');let read = promisify(fs.readFile);function * gen() &#123; let b = yield read('a.txt', 'utf8'); let c = yield read(b, 'utf8'); let res = yield read(c, 'utf8'); return res;&#125;co(gen()).then(data =&gt; &#123; console.log(data);&#125;); 123456789101112131415function *a() &#123; yield '1'; yield '2';&#125;// 如果在 generator 中调用另一个 generator，加个 *function *b() &#123; yield '3'; yield * a(); yield '4';&#125;let it = b();console.log(it.next());console.log(it.next()); asyncasync 是 generator 的语法糖 await 后面可以是 promise，也可以是数字、字符串 只要 await 语句后面的 Promise 状态变成 reject，那么整个 async 函数都会中断执行，所以建议任何有 await 的地方都要 try catch，或者用 promise 本身的 catch，比较累 123456789101112131415let &#123;promisify&#125; = require('bluebird');let fs = require('fs');let read = promisify(fs.readFile);// async 返回的是个 promiseasync function r() &#123; let b = await read('./a.txt', 'utf8'); let c = await read(b, 'utf8'); let res = await read(c, 'utf8'); return res;&#125;r().then(data =&gt; &#123; console.log(data);&#125;); 123456789async function fn() &#123; let [a,b,c] = await Promise.all([ readFile('./a.txt'), readFile('./b.txt'), readFile('./c.txt') ]); console.log(a,b,c);&#125;fn(); 模块化 CommonJS，服务端，同步的 AMD，requireJS CMD，seaJS ES规范，统一客户端和服务端 一般套路服务器环境下运行，默认严格模式 12// mod.jsexport const name = 'aaa'; 12345// 可以相对路径&lt;script type="module"&gt;import &#123;name&#125; from './mod.js';console.log(name);&lt;/script&gt; 123456789// 也可以绝对路径&lt;script type="module"&gt;import 'https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js';setTimeout(() =&gt; &#123; $('body').css(&#123; background: 'red' &#125;);&#125;);&lt;/script&gt; 12// 只有 export default 在引入时不需要解构// 其他情况在引入时要么解构，要么 import * as xxx from './mod' 动态加载123456789101112&lt;script type="module"&gt;let a = 'xxx';if (a === 'xxx') &#123; import('./mod1.js').then(res =&gt; &#123; console.log(res.name); &#125;);&#125; else &#123; import('./mod2.js').then(res =&gt; &#123; console.log(res.name); &#125;);&#125;&lt;/script&gt; 123456789&lt;script type="module"&gt;import('https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js').then(res =&gt; &#123; $(function() &#123; $('body').css(&#123; background: 'red' &#125;); &#125;);&#125;);&lt;/script&gt; 12345678910// await 后跟 promise，返回的是 promise 执行的结果&lt;script type="module"&gt;async function load() &#123; const mod1 = await import('./mod1.js'); const mod2 = await import('./mod2.js'); console.log(mod1.name); console.log(mod2.name);&#125;load();&lt;/script&gt; 12345678910&lt;script type="module"&gt;async function load() &#123; const [m1,m2] = await Promise.all([ import('./mod1.js'), import('./mod2.js') ]); console.log(m1.name, m2.name);&#125;load();&lt;/script&gt; ES6 中的类class 没有预解析，必须先定义后调用 ES5和ES6 对比12345678910111213141516const Test = function(a, b) &#123; this.a = a; this.b = b; return this;&#125;;Test.prototype = &#123; constructor: Test, print: function() &#123; console.log(this.a + ' ' + this.b); &#125;&#125;;let t = new Test('hello', 'world');t.print(); 123456789101112class Test &#123; constructor(a, b) &#123; this.a = a; this.b = b; return this; &#125; print() &#123; console.log(this.a + ' ' + this.b); &#125;&#125;new Test('hello', 'world').print(); 基本套路12345678910111213class Person &#123; // 调用 new 自动执行，默认也会添加 contructor constructor(name, age) &#123; this.name = name; this.age = age; &#125; // 定义在类中方法都是不可以被枚举的，Object.keys(Person.prototype) 搞不出来 showName() &#123; console.log(this.name); &#125;&#125;let p1 = new Person('aaayang', 18);p1.showName(); 方法可以是变量12345678910let hobby = 'hobbyFn';class Person &#123; [hobby]() &#123; console.log('hello world'); &#125;&#125;let p1 = new Person();p1[hobby]();p1.hobbyFn(); 关于 this一般定义妥妥的 1234567891011class Person &#123; constructor(name) &#123; this.name = name; &#125; sayName() &#123; console.log(this.name); &#125;&#125; let p1 = new Person('aaayang');p1.sayName(); // ok 解构后再使用，this 就是 undefined 了 1234567891011class Person &#123; constructor(name) &#123; this.name = name; &#125; sayName() &#123; console.log(this.name); &#125;&#125;let p1 = new Person('aaayang');let &#123;sayName&#125; = p1;sayName(); // this 是 undefined 矫正 this 1234567891011121314class Person &#123; constructor(name) &#123; this.name = name; // call 和 apply 也可以矫正 this，但会调用函数 // bind 只管矫正，并不调用函数 this.sayName = this.sayName.bind(this); &#125; sayName() &#123; console.log(this.name); &#125;&#125;let p1 = new Person('aaayang');let &#123;sayName&#125; = p1;sayName(); // aaayang 静态方法123456class Person &#123; static sayName() &#123; console.log('hello world'); &#125;&#125;Person.sayName(); 继承1234567891011121314class Person &#123; constructor(name) &#123; this.name = name; &#125; sayName() &#123; console.log(this.name); &#125;&#125;class Student extends Person &#123;&#125;let stu = new Student('xxx');stu.sayName(); // xxx 123456789101112131415161718class Person &#123; constructor(name) &#123; this.name = name; &#125; sayName() &#123; console.log(this.name); &#125;&#125;class Student extends Person &#123; constructor(name, age) &#123; super(name); // 想有自己的属性，必须先继承父级的属性 this.age = age; &#125;&#125;let stu = new Student('xxx', 18);console.log(stu.name, stu.age); 执行父的方法 1234567891011121314151617181920212223class Person &#123; constructor(name) &#123; this.name = name; &#125; sayName() &#123; console.log(this.name); &#125;&#125;class Student extends Person &#123; constructor(name) &#123; super(name); &#125; sayName() &#123; // 执行父的方法，也可以是父类的静态方法 // super 指的是父类的原型对象 super.sayName(); console.log(this.name); &#125;&#125;let stu = new Student('xxx');stu.sayName(); 总结 子类继承父类用 extends 关键字 为父类指定静态方法，使用 static 方法名字 super 在构造函数中可以当一个函数来使用，相当于调用父类的构造函数 super 在原型方法中可以当一个对象来使用，相当于父类的原型对象，并且会自动绑定 this 到子类上 一个例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; canvas &#123; box-shadow: 2px 2px 12px rgba(0, 0, 0, 0.5); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id="canvas"&gt;&lt;/canvas&gt; &lt;script&gt; const canvas = document.querySelector('#canvas'); const ctx = canvas.getContext('2d'); canvas.width = 600; canvas.height = 400; class Ball &#123; constructor(x, y, r) &#123; this.x = x; this.y = y; this.r = r; // ~~ 代表去掉小数部分 this.color = `rgba($&#123;~~Ball.rpFn([55, 255])&#125;, $&#123;~~Ball.rpFn([55, 255])&#125;, $&#123;~~Ball.rpFn([55, 255])&#125;)`; return this; // 可以在实例化后继续调用其他的方法 &#125; render(ctx) &#123; ctx.save(); ctx.translate(this.x, this.y); ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(0, 0, this.r, 0, 2*Math.PI); ctx.fill(); ctx.restore(); return this; &#125; static rpFn(arr) &#123; // Ball.rpFn([1, 10]) let max = Math.max(...arr), min = Math.min(...arr); return Math.random() * (max - min) + min; &#125; &#125; class SuperBall extends Ball &#123; constructor(x, y, r) &#123; // 继承父类构造函数中所有的属性 super(x, y, r); // 调用父类的构造函数，相当于之前的 Ball.call(this, x, y, r) // 继承时，没调 super 这里是没有 this 的 this.vy = SuperBall.rpFn([2, 4]); this.g = SuperBall.rpFn([0.2, 0.4]); this.a = 0; return this; &#125; move(ctx) &#123; // super(); // 不能在非构造函数中调用 this.y += this.vy; this.vy += this.g; let current = this.vy * -0.75; if(this.y + this.r &gt;= ctx.canvas.height) &#123; this.y = ctx.canvas.height - this.r; if(Math.abs(current - this.a) &lt; 0.01) return false; this.a = this.vy *= -0.75; &#125; ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height); // 注意这里的 super 指的是父类的原型对象 super.render(ctx); return true; &#125; &#125; let ball, timer; canvas.onclick = function(e) &#123; let x = e.offsetX, y = e.offsetY; let r = ~~Ball.rpFn([25, 55]); ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height); ball = new SuperBall(x, y, r).render(ctx); ballMove(); &#125;; function ballMove() &#123; timer = window.requestAnimationFrame(ballMove); if(!ball.move(ctx)) &#123; window.cancelAnimationFrame(timer); &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Symbol一般当做唯一的 key 使用，Symbol 不能使用 new 去调用 1234567891011121314let syml = Symbol('hello');let json = &#123; a: 'apple', b: 'bannana', [syml]: 'symbol'&#125;;// console.log(json[syml]); // symbol// 不能被 for in 出来for(let key in json)&#123; console.log(key); // a b&#125; 12345678910let obj = &#123; [Symbol()]: 123, name: 'aaayang'&#125;;let a = Object.getOwnPropertySymbols(obj);console.log(a); // [ Symbol() ]let b = obj[a[0]];// 可见即使不在外面把 Symbol 当做一个变量，也是可以得到它的值的console.log(b); // 123 123456// 转成字符串console.log( String(Symbol('test')) );console.log( Symbol('test').toString() );// 转布尔console.log( !!Symbol() ); generator执行 generator 函数返回的是什么？？ 1234567891011function* gen() &#123; yield 'hello'; yield 'world'; return 'last';&#125;let g1 = gen();console.log(g1.next());console.log(g1.next());// 最后一个的 done 是不是 true 取决于 generator 函数最后是 return 还是 yieldconsole.log(g1.next()); // &#123; value: "last", done: true &#125; for of 遍历 12345678910function * gen() &#123; yield 'hello'; yield 'world'; return 'last';&#125;let g1 = gen();for(let val of g1) &#123; console.log(val); // hello workd，return 的东西不会遍历&#125; 123456789function * gen() &#123; yield 'hello'; yield 'world'; return 'last';&#125;let [a,b] = gen();console.log(a,b); // hello worldconsole.log(...gen()); // hello world 1234567function* gen() &#123; yield 'hello'; yield 'world'; return 'last';&#125;console.log(Array.from(gen())); // ['hello', 'world'] 1234567891011function* gen() &#123; let val = yield 'aaayang'; yield axios.get(`https://api.github.com/users/$&#123;val&#125;`);&#125;let g1 = gen();let username = g1.next().value; // aaayangg1.next(username).value.then(res =&gt; &#123; console.log(res);&#125;); Set/MapSet 类似于数组，不重复，其实没有真正的 key，所有也就没有 get 方法，因为 get 要通过 key 获取的 Map 类似于 JSON，相对于 Set 多了个 get 方法，另外 key 可以是任意的值 Set相当于 Python 中的集合 1234// 数据结构// set: 类似数组，里面不能有重复的值let arr = ['a', 'b', 'c', 'a'];let set = new Set(arr); 12345// 方法set.add('xxx'); // 添加set.delete('xxx'); // 删除console.log(set.has('c')); // 检测set.clear(); // 清空 12// 属性console.log(set.size); // 长度 1234// 循环for(let item of set) &#123; console.log(item); // a, b, c&#125; 1234567891011121314// Set 的 keys 和 values 是一样的for (let item of set.keys()) &#123; console.log(item); // a, b, c&#125;// 默认是values()for(let item of set.values()) &#123; console.log(item); // a, b, c&#125;for(let item of set.entries()) &#123; console.log(item); // ["a", "a"], ["b", "b"] ...&#125;for(let [k, v] of set.entries()) &#123; console.log(k,v); // a a, b b ...&#125; 1234// set 有 forEachset.forEach((val, index) =&gt; &#123; console.log(val, index);// a a, b b, c c ...&#125;); 12// 可以链式操作 new set(arr).add().add()set.add('gg').add('bb'); 12345678// 去重let xxx = ['1', '1', '2', '3', '3'];// Set 数据结构变成数组通过 ...console.log([...new Set(xxx)]);// 使用数组中的方法let m = new Set([...new Set(xxx)].map(value =&gt; value * 2));console.log(m); 123456789101112// 正常Set里面放的数组// 也可以放对象，最好用weaksetlet j1 = &#123; name: 'aaa'&#125;;let j2 = &#123; age: 18&#125;;// 注意是 add 进去的let j3 = new Set().add(j1).add(j2);j3.forEach(val =&gt; console.log(val)); // &#123;name: "aaa"&#125; &#123;age: 18&#125; 123456789let wSet = new WeakSet();let json = &#123; name: 'aaa', age: 18&#125;;// 建议存 jsonwSet.add(json);// 没有 size 没有 clear，有add, has, deleteconsole.log(wSet.size); // undefined ... Map相当于 Python 中的字典 12345678910// 问题，为对象添加了两次 key(是个对象)，结果却只有只有let data1 = &#123;a:1&#125;;let data2 = &#123;b:2&#125;;let obj = &#123;&#125;;// 如果 key 的对象，会自动调用 toString()，而这两个对象 toString() 后是一样的obj[data1] = 1;obj[data2] = 2;console.log(obj); // &#123; '[object Object]': 2 &#125; Map 数据结构，键的范围不限于字符串，对象也可以，是一种更完善的 Hash 结构的实现 1234const map = new Map([ ['a', 1], // 键是a ，值是1 ['b', 2]]); 12345let map = new Map();// 设置// map.set(key, value)console.log(map.set('name', 'aaa')); 12// 可以链式map.set('name', 'aaayang').set('age', 18); 123456789// map 的 key 可以是任意类型let json = &#123; a: 1&#125;;// key 可以是对象console.log(map.set(json, 'aaa'));// 获取// set 没有获取，只能循环console.log(map.get(json)); 123456map.delete('name'); // 返回true or false// 判断console.log(map.has('name'));// 清空map.clear(); 123456789101112131415161718192021// 默认 valuesfor(let [key,val] of map) &#123; console.log(key, val); // name aaa&#125;for(let key of map.keys()) &#123; console.log(key);&#125;for(let key of map.values()) &#123; console.log(key);&#125;for(let key of map.entries()) &#123; console.log(key);&#125;map.forEach((val, key) =&gt; &#123; console.log(val, key); // aaa name&#125;); 12345// WeakMap key 只能是对象let obj = &#123; name: 'aaa'&#125;;let weakMap = new WeakMap().set(obj, 'xxx'); 细节1234// 会认为 NaN 是一个东西let map = new Map();let a = map.set(NaN, '1').set(NaN, '2');console.log(a); // &#123;NaN =&gt; '2'&#125; 1234// 两个空对象就不是一个东西了let map = new Map();let a = map.set(&#123;&#125;, '1').set(&#123;&#125;, '2');console.log(a); // &#123;&#123;&#125; =&gt; '1', &#123;&#125; =&gt; '2&#125; 1// map 里面 key 的排列顺序永远是按照添加的顺序进行的 数值变化进制123// 0b 代表二进制let a = 0b11;console.log(a); // 3 123// 八进制let a = 0o11;console.log(a); // 0 Number Number.isNaN Number.isFinite，是否是数字 Number.isInteger，是否是整数 Number.parseInt Number.parseFloat Number.isSafeInteger(253)，是否是安全整数【-(253-1) ~ (2**53-1)】 Number.MAX_SAFE_INTEGER，最大安全整数 Number.MAX_VALUE Math.trunc(1.23)，截取，只保留整数部分 Math.sign，整数返回1，负数返回-1，0返回0，-0返回-0 幂运算123// 2 的 3 次方console.log(Math.pow(2,3)); // 8console.log(2**3); // 8 关于正则命名捕获12345let str = '2018-08-25';let reg = /(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/;let arr = str.match(reg);let &#123;year, month, daty&#125; = arr.groups; 12345678let reg = /^(?&lt;aaayang&gt;welcome)-\k&lt;aaayang&gt;$/;// let reg = /^(?&lt;aaayang&gt;welcome)-\1$/;let str = 'a-a';let str2 = 'welcome-welcome';console.log(reg.test(str));console.log(reg.test(str2)); 123456let str = '2018-08-25';let reg = /(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/;// let a = str.replace(reg, '$2$1$3');let a = str.replace(reg, '$&lt;year&gt;/$&lt;month&gt;/$&lt;day&gt;');console.log(a); 12345678let str = '2018-08-25';let reg = /(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/;let a = str.replace(reg, (...args) =&gt; &#123; let &#123;year, month, day&#125; = args[args.length-1]; return `$&#123;year&#125;/$&#123;month&#125;/$&#123;day&#125;`;&#125;);console.log(a); 123// s 修饰符让 . 代表所有let reg = /^\w.\w$/s;console.log(reg.test('w\nx')); // false]]></content>
      <categories>
        <category>JS 高级</category>
      </categories>
      <tags>
        <tag>ES2015</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拖了个拽]]></title>
    <url>%2F2019%2F06%2F30%2Ftransform%2F</url>
    <content type="text"><![CDATA[殊途同归原理1：按下时获取光标到盒子的距离，即 disX = e.pageX（红线） - oDiv.offsetLeft（蓝线） ，移动时再用当前光标到窗口的距离减去上次获得的 disX，就可实时得到蓝线的距离，即盒子当前应该距离窗口左侧的距离。 原理1代码实现 原理2：按下时记录当前光标位置（红线）和盒子原来的位置（蓝线），移动时用盒子原来的位置加上移动的距离（移动距离=当前移动时的光标位置-按下时的光标位置）。 原理2代码实现 transform 对拖拽的影响上面使用原理1确实可以实现想要的拖拽效果，但获取到的光标到盒子的距离却是错误的！比实际的大小多了个 translate 值，测试代码如下： 1234567#box &#123; position: absolute; width: 100px; height: 100px; background-color: pink; transform: translate(100px, 100px);&#125; 123456var oBox = document.querySelector('#box');oBox.onmousemove = function (e) &#123; var disX = e.clientX - this.offsetLeft; var disY = e.clientY - this.offsetTop; this.innerHTML = 'x: ' + disX + ', y: ' + disY;&#125;; 当使用了 translate 移动了盒子之后，光标到盒子的计算结果是不对的，那为什么最终还能实现正确的拖拽效果呢？那是因为 offsetLeft 的计算并不会把 translateX 包括在内，移动时操作的是 oDiv.style.left（并没有管 translate 的事情，原来是多少移动时还是多少），所以也就能得到正确的结果！ 上面我们明白了即便使用 translate 改变元素的初始位置，也不会对拖拽本身产生影响，但是！如果拖拽过程中有涉及到范围的判断时，要格外小心了。例如限制元素不能超出窗口的左侧，就不能简单的 if(x &lt; 0) {x = 0}，因为当 x 为负的 translateX 才是真正的到达边界，所以再判断时应该 if(x &lt; -translateX) {x = -translateX}，其他边界的判断同理！ 查看代码 margin 对拖拽的影响首先建议不要给想要拖拽的元素加 margin，如果想要改变它的初始位置，完全可以使用 top 或 left（既然是拖拽，元素应该就有了绝对定位！） 如果在应用了定位的同时竟然又加了 margin（不推荐，因为这里 top、left 完全可以搞定 margin 的功能），那需要在 mousemove 的时候减去这个值，当然你在按下的时候 disX = e.pageX - this.offsetLeft + marginLeft 也是 ok！ 查看代码 使用 translate 改变盒子的位置可以直接把之前对 oBox.style.left 的修改变成 oBox.style.transform 吗？ 1234567document.onmousemove = function (e) &#123; var l = e.clientX - disX; var t = e.clientY - disY; // oBox.style.left = l + 'px'; // oBox.style.top = t + 'px'; oBox.style.transform = 'translate(' + l + 'px, ' + t + 'px)';&#125;; l 本来指的应该是 oBox 的 left 值，这里直接把 l 使用在了 translate 上，那就相当于在原来定位的基础上又直接 translate 了 l 的值，肯定是不行的！ 核心原理：把上次移动位置（结果）变成下次按下时的起始位置！ 第一种写法 mousemove 时当前鼠标位置 减去 按下时的鼠标位置 加上 一次原来的 moveX，注意在 mousedown 加 moveX 才能保证是 1 次 代码实现1 第二种写法 定义上次的 translate 值 var startX = 50;，定义默认当前需要移动的值 var needMoveX = 0;，mousemove 时 needMoveX = startX + moveX(e.pageX - originPageX);，mouseup 时则需要 startX = needMoveX; 代码实现2 第三种写法 和上面同理，只不过把初始值挂载到了移动的元素上 代码实现3]]></content>
      <categories>
        <category>Web API</category>
      </categories>
      <tags>
        <tag>拖拽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[再说事件绑定]]></title>
    <url>%2F2019%2F06%2F27%2FaddEventListener%2F</url>
    <content type="text"><![CDATA[大家都清楚，常用的事件绑定有两种形式，一种是传统绑定，例如 oBtn.onclick = fn; 还有一种是通过事件监听，例如 oBtn.addEventListener(&#39;click&#39;, fn, false); 两种绑定方式最大的差异我相信大家也比较清楚，就是传统方式给同一元素绑定多个事件处理程序时生效的是最后的那个（后面的覆盖前面的），事件监听的形式给同一元素绑定多个不同的事件处理程序时都会生效。但是在具体使用时用什么方式绑？绑定在谁身上（是点击的当前元素还是父元素）？什么时候绑（是点击的时候绑还是程序加载的时候绑）？都是你需要关注的细节，这里我举了一个例子来说明这三个问题！ 基本需求 需求：点击添加按钮，把 input 框中的内容放入新创建的 li，并给 li 中添加删除按钮可以删除当前行，最后把 li 添加到 ul 中，如上图 代码实现： 123&lt;input type="text"&gt;&lt;button&gt;添加&lt;/button&gt;&lt;ul style="width: 200px;"&gt;&lt;/ul&gt; 123456789101112131415161718192021222324252627var oInput = document.querySelector('input');var oBtn = document.querySelector('button');var oUl = document.querySelector('ul');oBtn.onclick = function() &#123; // 创建 li var oLi = document.createElement('li'); // 给 li 添加内容 oLi.innerHTML = oInput.value; // 添加 li 到 ul oUl.appendChild(oLi); // 创建删除按钮 span var oBtn = document.createElement('span'); // 添加文字 oBtn.innerHTML = '删除'; // 添加删除按钮到 li oLi.appendChild(oBtn); // 每次点击时选择所有按钮，并绑定点击事件做删除操作 var aBtn = document.querySelectorAll('span'); for(var i = 0; i &lt; aBtn.length; i ++) &#123; aBtn[i].onclick = function() &#123; oUl.removeChild(this.parentNode); &#125;; &#125;&#125;; 问题重现上面删除当前列表的功能，我们是用普通的事件绑定形式(onclick)去做的，没有什么问题。有同学尝试用事件监听的形式(addEventListener)改写代码如下： 123456var aBtn = document.querySelectorAll('span');for(var i = 0; i &lt; aBtn.length; i ++) &#123; aBtn[i].addEventListener('click', function() &#123; oUl.removeChild(this.parentNode); &#125;);&#125; 点击添加按钮，增加了 2 个或大于 2 个元素，此时再删除非最后一个列表时（非最后一个还是非第一个取决于是用 appendChild 还是 insertBefore 插入的），却发现出现了错误！打开控制台报错信息如下（删除了一个不是 oUl 子元素的节点）： 问题分析第 1 次点击按钮添加完成后，会通过 var aBtn = document.querySelectorAll(&#39;span&#39;); 选择所有的删除按钮，绑定事件 第 2 次点击添加按钮完成后，会通过 var aBtn = document.querySelectorAll(&#39;span&#39;); 选择所有的删除按钮，绑定事件。问题就出在这里，选择所有删除按钮并绑定事件的操作，其实又会把之前已经绑定事件的元素再次绑定了一次。所以点击删除按钮时会发现 oUl.removeChild(this.parentNode); 执行了多次（取决于重复绑定了多少次），第 1 次执行时已经把当前 li 从 ul 中移除，下次再执行 oUl.removeChild(this.parentNode); 时其实 ul 中已经没有了这个 li，删除一个不存在的子节点就会报错！ 第 3 次点击添加按钮完成后，同理… 解决方案Way1: 使用普通的事件绑定形式（onclick） Way2: 对于同样的事件处理程序独立出去变成同一个函数，每次保证绑定的是同一个（函数），例如： 123456789var aBtn = document.querySelectorAll('span');for(var i = 0; i &lt; aBtn.length; i ++) &#123; // aBtn[i].removeEventListener('click', rm); // 这里就没有必要进行先解绑了，因为每次绑定的是同一个 rm，会覆盖掉之前的 aBtn[i].addEventListener('click', rm);&#125;function rm(e) &#123; // 这里也可以用 this.parentNode oUl.removeChild(e.target.parentNode);&#125; Way3: 其实前面每次添加列表就通过 querySelectorAll 重新选择所有删除按钮并绑定事件，本身就是一个糟糕的思路！其实只需要找到最新添加的那一个进行事件绑定就可以了，往前插入的话可以直接通过 var oBtn = document.querySelector(&#39;span&#39;); 找到最新添加的那个，往后插入的话代码如下： 1234var oBtn = document.querySelectorAll('span')[oUl.children.length-1];oBtn.addEventListener('click', function() &#123; oUl.removeChild(this.parentNode);&#125;); 除了上面通过元素选择的方式查找最新添加的那一个，最正确的方式其实是根本不用查找，它就在那里！每次添加列表的时候，当前创建的删除按钮就是最新的，直接给其绑定事件即可，这样无论是从效率，还是代码简洁度上都最佳，代码如下： 1234567var oBtn = document.createElement('span');// 给一个创建的元素单独绑定事件，而不是每次点击通过 querySelectorAll 选择的形式oBtn.addEventListener('click', function() &#123; oUl.removeChild(this.parentNode);&#125;);oBtn.innerHTML = '删除';oLi.appendChild(oBtn); Way4: 使用事件委托，推荐！ 1234567// 把事件绑定在父级上oUl.addEventListener('click', function(e) &#123; // 根据点击当前元素的名字（或其他）来判断是否是 span（即删除按钮），然后做相应的操作 if(e.target.nodeName.toLowerCase() === 'span') &#123; e.currentTarget.removeChild(e.target.parentNode); &#125;&#125;);]]></content>
      <categories>
        <category>Web API</category>
      </categories>
      <tags>
        <tag>addEventListener</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于数组塌陷]]></title>
    <url>%2F2019%2F06%2F23%2Fsplice%2F</url>
    <content type="text"><![CDATA[关于数组的方法有很多，splice 算是比较强大的一个，它能用来删除、添加、替换数组中的元素，实际开发中非常实用！ 基本语法123456// start: 从哪里开始，也支持负值，-n 相当于 arr.length - n// deleteCount: 要删除几个（可选）// item1, item2: 要添加进数组的元素（可选）// 返回值: 以数组的形式返回删除的那些元素array.splice(start, deleteCount, item1, item2); 代码演练删除：从第 2 位开始，删除 2 个 123var arr = ['apple', 'orange', 'banana', 'watermelon'];arr.splice(2, 2);console.log(arr); // ['apple', 'orange'] 添加：从第 2 位开始，删除 0 个，添加 🤣😎 123var arr = ['apple', 'orange', 'banana', 'watermelon'];arr.splice(2, 0, '🤣', '😎');console.log(arr); // ["apple", "orange", "🤣", "😎", "banana", "watermelon"] 替换：从第 2 项开始，删除 2 项并添加🍌和🍉 123var arr = ['apple', 'orange', 'banana', 'watermelon'];arr.splice(2, 2, '🍌', '🍉');console.log(arr); // ["apple", "orange", "🍌", "🍉"] 数组塌陷需求：利用 splice 删除数组中的指定元素 1234var arr = ['apple', 'orange', 'banana', 'watermelon'];// 从 0 开始删到最后，并不能指定删除某个元素arr.splice(0);console.log(arr); // [] 1234567// 删除指定的某个元素时就需要遍历，但最终的结果和我们想的不一样！var arr = ['apple', 'orange', 'banana', 'watermelon'];for(var i = 0; i &lt; arr.length; i ++) &#123; // 从第 i 个开始，删除 1 个 arr.splice(i, 1);&#125;console.log(arr); // ["orange", "watermelon"] 上面的写法删不干净，因为 splice 每删除一个元素就会改变原来数组的索引以及长度，而 i 的值永远是个递增的状态，代码分析如下（建议断点调试）： 第 1 次 i 等于 0， arr.splice(0, 1) 后的结果是 [‘orange’, ‘banana’, ‘watermelon’]，arr 的 length 变为了 3； 第 2 次 i 等于 1，arr.splice(1, 1) 后的结果是 [‘orange’, ‘watermelon’]，arr 的 length 变为了 2； 第 3 次 i 等于 2， i &lt; arr.length 条件为假，结束循环； 解决方法需求：解决上面利用 splice 删除不干净的问题！ 每次删除数组的第一个元素 1234567var arr = ['apple', 'orange', 'banana', 'watermelon'];for(var i = 0; i &lt; arr.length; i ++) &#123; arr.splice(i, 1); // 每次删除后进行 i--，这样就能保证删除的永远都是数组的第一个元素（说第一个元素不太准确，取决于i的值变化到哪里了） i --;&#125;console.log(arr); // [] 1234// 原理和上面一样，永远删除数组最前面那个元素while(arr.length) &#123; arr.splice(0, 1);&#125; 倒着删 123456// 可以通过断点调试查看代码执行过程var arr = ['apple', 'orange', 'banana', 'watermelon'];for(var i = arr.length - 1; i &gt;= 0; i --) &#123; arr.splice(i, 1);&#125;console.log(arr); 使用场景数组去重：每次用当前元素和后面的所有元素进行比较，如果相同就利用 splice 删除掉后面相同的那个元素 j（或当前的 i） 12345678910var arr = ['apple', 'apple', 'apple', 'orange', 'apple'];for(var i = 0; i &lt; arr.length; i ++) &#123; for(var j = i + 1; j &lt; arr.length; j ++) &#123; if(arr[i] === arr[j]) &#123; arr.splice(j, 1); // 解决 splice 后带来的数组塌陷问题 j --; &#125; &#125;&#125; 题目测试需求：在数组 var arr = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]; 每一项的前面添加 @ 字符 123456// Way1for(var i = arr.length - 1; i &gt;= 0; i --) &#123; arr.splice(i, 0, '@');&#125;console.log(arr); // ["@", "a", "@", "b", "@", "c", "@", "d"] 12345678// Way2for(var i = 0; i &lt; arr.length; i ++) &#123; arr.splice(i, 0, '@'); // ['@', 'a', 'b', 'c', 'd'] 下次 'b' 的索引已经是 2 了，需要再次进行 i++ i++;&#125;console.log(arr); // ["@", "a", "@", "b", "@", "c", "@", "d"] 1234567// Way3for(var i = 0; i &lt; arr.length; i ++) &#123; arr.splice(i, 1, '@'+arr[i]);&#125;arr = arr.join('').split('');console.log(arr); // ["@", "a", "@", "b", "@", "c", "@", "d"] 其他方法用 splice 删除指定元素的目的，换句话说无非是想得到想要的元素，其实数组也提供了 filter 方法，可以帮我们筛选出想要的数组元素！ 12345// 具体使用看文档，这里不再啰嗦了！var arr = ['apple', 'orange', 'banana', 'watermelon'];// 返回一个新的、由通过测试的元素组成的新数组var newArr = arr.filter(word =&gt; !word);console.log(newArr); // []]]></content>
      <categories>
        <category>JS 基础</category>
      </categories>
      <tags>
        <tag>数组塌陷</tag>
        <tag>splice</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[标记语句]]></title>
    <url>%2F2019%2F06%2F21%2Fjs-label%2F</url>
    <content type="text"><![CDATA[之前课上做过一个计算器的案例，选择 1、2、3、4 后会对后面填入的数字进行对应的运算并弹出结果，点击确定后又会回到初始界面。如果用户在初始界面输入的是数字 5，点击确定就会进行退出操作，不再回到初始界面了！ 可实现代码如下： 123456789101112131415161718192021222324252627282930313233343536373839// 输入内容并返回function inputValue() &#123; var num1 = parseFloat(prompt('请输入第一个数：')); var num2 = parseFloat(prompt('请输入第二个数：')); return [num1, num2];&#125;// 相当于创建了一个开关，默认开启状态var bBar = true;do &#123; var opration = prompt('请选择要进行的运算：\n1. 加法运算\n2. 减法运算\n3. 乘法运算\n4. 除法运算\n5. 退出'); opration = parseInt(opration); switch (opration) &#123; case 1: var arr = inputValue(); alert('相加的结果是：' + (arr[0] + arr[1])); break; case 2: var arr = inputValue(); alert('相减的结果是：' + (arr[0] - arr[1])); break; case 3: var arr = inputValue(); alert('相乘的结果是：' + (arr[0] * arr[1])); break; case 4: var arr = inputValue(); alert('相除的结果是：' + (arr[0] / arr[1])); break; case 5: alert('退出...'); // 如果用户输入的是 5，则关闭开关，那下次的循环 bBar 就是 false，while(bBar) 也就不会执行了 bBar = false; // 默认只会退出当前的 switch break; &#125;&#125; while (bBar); 其实上面退出循环的操作也可以使用标记语句来完成，感兴趣的同学可以点击链接进去学习下，修改后的代码如下： 123456789101112// Step1: 指定标记点loopPoint:do &#123; // ... switch (opration) &#123; // ... case 5: alert('退出...'); // Step2: 跳到标记点 break loopPoint; &#125;&#125; while (true); 下面是测试代码： 1234567891011121314var num = 0;for (var i = 0; i &lt; 6; i++) &#123; for (var j = 0; j &lt; 6; j++) &#123; // 当 i 等于 3 并且 j 等于 3 时，会直接 break 里面一层的 for 循环，继续外面的 for 循环 // 当 i 等于 3 时，导致 j 值为 [3,6) 之间的没有进行，num 少加了 3 次 // 所以最终的 num 值为 33 if (i == 3 &amp;&amp; j == 3) &#123; // 跳出当前循环 break; &#125; num++; &#125;&#125;console.log(num); // 打印结果是多少？ 1234567891011121314151617var num = 0;outerMark:for (var i = 0; i &lt; 6; i++) &#123; // 外层 for 循环，i 等于 0 时，里层执行完 6 次 // 外层 for 循环，i 等于 1 时，里层执行完 6 次 // 外层 for 循环，i 等于 2 时，里层执行完 6 次 // 外层 for 循环，i 等于 3 时，里层循环 j 执行了 3 次 [0, 3) // 最终的 num 值是 21 for (var j = 0; j &lt; 6; j++) &#123; if (i == 3 &amp;&amp; j == 3) &#123; // 跳出到 outerMark 标记的地方 break outerMark; &#125; num++; &#125;&#125;console.log(num); // 打印结果是多少？ 123456789101112var num = 0;outerMark:for (var i = 0; i &lt; 6; i++) &#123; for (var j = 0; j &lt; 6; j++) &#123; if (i == 3 &amp;&amp; j == 3) &#123; // 跳出外层的当前循环，继续下次 i++ continue outerMark; &#125; num++; &#125;&#125;console.log(num); // 打印结果是多少？]]></content>
      <categories>
        <category>JS 基础</category>
      </categories>
      <tags>
        <tag>标记语句</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端布局那点事]]></title>
    <url>%2F2019%2F06%2F07%2Fmobile-layout%2F</url>
    <content type="text"><![CDATA[作为前端，在今天来说，移动端布局必须是一件必知必会的事情，重要程度不言而喻！这里我总结了同一案例下不同布局的写法（原理就不再赘述，直接右键查看源代码即可），方便大家回忆。 百分比布局特点：宽度百分比、高度写死（750的设计稿下一般除以2）。缺点：高度或文字很难自适应。 举例 Flexible 布局特点：宽度弹性布局、高度写死。缺点：高度或文字还是很难自适应。优点：灵活、简洁。 举例 REM 布局原理：不同尺寸屏幕下给根元素设置不同的文字大小（利用媒体查询或JS），宽、高、间距…都统一使用 REM 单位。使用：量取到的设计稿尺寸除以根元素字体大小（基准值）即可，例如使用 flexible.js，150px 用 rem 表示就是 2rem。优点：高度和文字可以自适应。 注意 em 是相对于当前元素的字体大小（如果当前元素没有设置字体大小那就是继承过来的大小）的单位。 举例 响应式布局原理：利用 bootstrap 的栅格系统（核心还是媒体查询），不同尺寸下设置不同的样式，实现 PC 和移动端布局使用同一套代码！场景：适用于相对简单的页面，复杂页面下的响应式开发成本太高。]]></content>
      <categories>
        <category>移动 Web 开发</category>
      </categories>
      <tags>
        <tag>移动端布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[steps(number[, end | start])]]></title>
    <url>%2F2019%2F05%2F31%2Fsteps%2F</url>
    <content type="text"><![CDATA[缘起CSS3 中用于设置动画的 animation 语法如下： 1animation: name duration timing-function delay iteration-count direction; 其中，timing-function 取值如下： 1timing-function: linear / ease / ease-in / ease-out / ease-in-out / cubic-bezier() / steps() 上面 timing-function 的取值除了 steps() 都代表补间动画（线性动画），steps() 代表帧动画，有时候一些动画效果必须用它才能实现，例如上面图奔跑的动物是我们曾经做过的动画，就是通过 steps() 配合改变雪碧图（1600px宽）的位置实现的，代码如下： 12345678@keyframes aniSelf &#123; 0% &#123; background-position: 0 0; &#125; 100% &#123; background-position: -1600px 0; &#125;&#125; 123.wolf&#123; animation: aniSelf 1s steps(8) infinite;&#125; 上面代码确实能实现预期的效果，但不知道大家有没有这样一个疑问：当背景位置为 background-position: -1600px 0; 时，图片在盒子中应该是看不到的才对（因为图片总共是1600px，这样刚好是图片的最右边卡到盒子的最左边），但为什么动画还能正常跑起来，而没有出现空白的问题呢？ 要解答上面的疑问，我们就要明白关于 steps(number[, end | start]) 参数的含义，第一个参数大家都知道是什么意思，第二个参数是可选的，表示在每个间隔的起点或是终点发生阶跃变化，如果忽略，默认是 end。 看完上面加粗部分的定义，我不知道你作何感想…😣 我的感性认识我的理解：steps() 第二个参数如果是 end 则代表忽略结束帧，如果是 start 则代表忽略开始帧，如何理解这句话呢？ 上面是一张 50 * 200 的图片，作为 50 * 50 盒子的背景图，我想实现在 hover 盒子的时候背景从 A 变化到 A 的逐帧动画。由于我们知道 steps(4, end) 时会忽略最后一帧，动画走完时没有 forwards，又会回到初始状态，故可以用以下方法来实现： 1234567891011121314151617181920.box &#123; border: 1px solid #333; width: 50px; height: 50px; background: url(./images/steps.png) no-repeat;&#125;.box:hover &#123; /* 分为 4 步来完成，会忽略最后一步 background-position: 0 -150px; 到 background-position: 0 -200px; 这个区间！ */ animation: way1 2s steps(4);&#125;@keyframes way1 &#123; 0% &#123; background-position: 0 0; &#125; 100% &#123; background-position: 0 -200px; &#125;&#125; 上面代码其实就是和我们课上实现动物运动的代码是一样的思路，那如果我把上面的代码改为 steps(4, start) 会怎样的，根据我们之前的结论，start 会忽略第一帧，也就是 hover 上的一刹那就会定位到 B，然后也会走 background-position: 0 -150px; 到 background-position: 0 -200px; 最后一帧这个区间，即会出现空白，最后又回到初始状态 A，可见，这并不是我们所需要的。 我就想用 start如果实在想用 start 可以改写代码如下： 1234567891011121314/* Step1: 分为 3 步走 */.box:hover &#123; animation: way1 2s steps(3, start);&#125;/* Step2: 最后一帧的位置改成严丝合缝的最后一样图片 */@keyframes way1 &#123; 0% &#123; background-position: 0 0; &#125; 100% &#123; background-position: 0 -150px; &#125;&#125; 注意：以上代码虽然能实现 hover 时背景从 A、B、C、D 到 A 的变换，但并不推荐这样做，因为 hover 的一刹那 A 到 B 的变换是没有动画的（逐帧动画也是动画） 其他写法注意看我的注释部分！ 123456789101112131415161718192021.box &#123; border: 1px solid #333; width: 50px; height: 50px; /* Step1: 背景重复！ */ background: url(./images/steps.png) repeat-y;&#125;.box:hover &#123; /* Step2: 这时候 steps 第二个参数是 start or end 只是开始时第一帧有没有动画的区别，并不会出现空白了，因为背景平铺了 */ animation: way1 2s steps(4);&#125;@keyframes way1 &#123; 0% &#123; background-position: 0 0; /* A */ &#125; 100% &#123; background-position: 0 -200px; /* A */ &#125;&#125; 123456789/* 设置是这样的写法 */@keyframes way1 &#123; 0% &#123; background-position: 0 200px; /* A */ &#125; 100% &#123; background-position: 0 0px; /* A */ &#125;&#125; 其他属性对 step 的影响当 steps() 第二个参数为 end 时会忽略结束帧，但 animation-fill-mode: forwards; 是会影响 steps() 的表现的，例如我想让一个盒子从 0 运动到 100，可写代码如下： 12345678910111213141516.box&#123; width: 100px; height: 100px; background-color: pink; position: absolute; top: 70px; animation: move 3s steps(5) forwards;&#125;@keyframes move &#123; 0%&#123; left: 0; &#125; 100%&#123; left: 100px; &#125;&#125; 结果如下： 说好的 steps() 第二个参数为 end 时会忽略最后一帧，但最后却停在了 100px 的位置上，说明 animation-fill-mode 为 forwards 时会对 steps() 帧动画造成影响，以 forwards 为准！当然你如果又设置了 infinite，那 forwards 也就“失效”了… 再来个小栗子点我去远方]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>steps()</tag>
        <tag>帧动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据类型检测的 N 中方式]]></title>
    <url>%2F2019%2F05%2F26%2Fjudge-type%2F</url>
    <content type="text"><![CDATA[从 JS 基础第一天开始，我们就学习了如何使用 typeof 去判断数据类型，学习构造函数时我们又说了 constructor 以及 instanceof 也可以去进行类型检测，到 JS 高级时还讲了 Object.prototype.toString() 方法也可以去判断数据类型，那么问题来了，这么多方法它们之间有什么异同吗？不同场景下该怎样使用才比较合适呢？ 数据类型知多少既然要检测数据类型，首先要明确 JS 中的数据类型有以下 7 种： 简单数据类型：Number、String、Boolean、Null、Undefined、Symbol（ES6） 复杂数据类型：Object（包括函数、数组、对象、正则、日期等） typeoftypeof 它的使用方法有两种： 1234// 可以不带括号，直接跟数据console.log(typeof 36);// 也可以带括号console.log(typeof(36)); typeof 的返回值永远是一个全小写字符串，例如： 1console.log(typeof (typeof (typeof 66))); // string typeof 的返回值除了上面 7 种数据类型外，还多了一个 function，例如： 12function test() &#123;&#125;console.log(typeof test); // function 总结： 除了 Null（返回 object），typeof 对于基本数据类型都能返回正确的结果 除了 Function（返回 function），typeof 对于复杂数据类型都返回 object 缺点： typeof 对于复杂数据类型的处理，只能返回处于原型链最顶端的 Object 类型，不能细分 constructor新建一个（构造）函数 Fn 时，JS 引擎会给自 Fn 添加一个 prototype 属性，prototype 下又有一个 constructor 指向 Fn 函数，可用如下代码表示： 12function Fn() &#123;&#125;console.log(Fn.prototype.constructor === Fn); // true 当我们执行 new Fn 来创建 Fn 的实例后，这个实例的 constructor 也就指向 Fn，如下： 1234function Fn() &#123;&#125;var f1 = new Fn;// f1 下本没有 constructor，自己没有则会通过原型链向上查找到 Fn.prototype 上console.log(f1.constructor === Fn); // true 如此一来我们就可以通过 constructor 来判断某个实例对象具体的类型（来源），例如上面代码从原型链的角度来说 f1 的类型（来源）就是 Fn。 同样的道理，其他数据的也可以通过 constructor 来判断具体的类型，它可以解决 typeof 对应复杂数据类型的判断无能为力的问题，测试如下： 1234567console.log([].constructor === Array); // trueconsole.log(new Date().constructor === Date); // trueconsole.log(new Function().constructor === Function);console.log(''.constructor === String);console.log(true.constructor === Boolean);console.log(new Error().constructor === Error);console.log(document.constructor === HTMLDocument); constructor 的小问题： null 和 undefined 上没有 constructor 这属性，不能通过 constructor 来判断 当 prototype 被不小心重写后，会导致 constructor 判断不准确的问题，例如： 1234567891011function Test() &#123;&#125;var t1 = new Test;console.log(t1.constructor === Test); // true// 重写原型会导致 Test.prototype.constructor 指向不正确// 当然对应的实例对象在用 constructor 去判断类型的时候也就会指向不正确Test.prototype = &#123; showAge: function() &#123;&#125;&#125;;var t2 = new Test();console.log(t2.constructor === Test); // false instanceof它主要用来判断一个对象是否能够通过原型链找到另一个对象的原型，什么意思呢？例如： 12// [] 可以通过 __proto__ 找到 Array.prototype，所以结果是 trueconsole.log([] instanceof Array); 123// [].__proto__.__proto__ === Object.prototype// 说明 [] 也是可以通过原型链找过 Object 的原型，所以下面结果也是 trueconsole.log([] instanceof Object); 所以大家也看到了，instanceof 并不能准确的找到某个实例的类型，但它相对于 constructor 有这样一个特点，即便构造函数的原型被重写后，实例也能通过 instanceof 去判断自己的类型，例如： 1234567function Test() &#123;&#125;Test.prototype = &#123; showAge: function() &#123;&#125;&#125;;var t1 = new Test();console.log(t1 instanceof Test); // trueconsole.log(t1 instanceof Object); // 当然对应顶级对象 Object 也是 true，还是不能准确判断就是 Test 类型 instanceof 还有另外一个问题需要你注意的，当页面中引入 iframe 时，实例化 iframe 窗口下的对象和当前窗口下相对应的构造函数进行 instanceof 判断时也会出现问题。例如： 1234567891011var oFrame = document.createElement('iframe');document.body.appendChild(oFrame);// ifame 窗口下实例化的 arrvar arr = new window.frames[0].Array;console.log(arr instanceof window.frames[0].Array); // trueconsole.log(arr instanceof Array); // false// 针对上面的问题 ES5 提供了 Array.isArray() 这个方法进行判断console.log(Array.isArray(arr)); // true Object.prototype.toString他返回的信息格式是 [object Xxx]（注意第一个 X 是大写），对于 {} 直接调用 toString 既可以返回 [object Object]，其他类型需要借助 call/apply 方法去调用，例如： 12345678910111213// 也可以把 Object.prototype 替换成 &#123;&#125;// 因为调用 &#123;&#125; 下的 toString() 方法，自己没有会通过原型链去 Object.prototype 上面找console.log(Object.prototype.toString.call(233)); // [object Number]console.log(Object.prototype.toString.call('233')); // [object String]console.log(Object.prototype.toString.call(true)); // [object Boolean]console.log(Object.prototype.toString.call(null)); // [object Null]console.log(Object.prototype.toString.call(undefined)); // [object Undefined]console.log(Object.prototype.toString.call(Symbol())); // [object Symbol]console.log(Object.prototype.toString.call([])); // [object Array]console.log(Object.prototype.toString.call(new Function)); // [object Function]console.log(Object.prototype.toString.call(new Date)); // [object Date]console.log(Object.prototype.toString.call(new RegExp)); // [object RegExp] 可见 Object.prototype.toString() 简直太好用啦，推荐使用！]]></content>
      <categories>
        <category>JS 高级</category>
      </categories>
      <tags>
        <tag>判断数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据在内存中的存储形式]]></title>
    <url>%2F2019%2F05%2F25%2Fsnake-question%2F</url>
    <content type="text"><![CDATA[学习贪吃蛇时，往蛇身体增加最后一节，当时代码是直接这样写的 this.body.push({ x: last.x, y: last.y, color: last.color })，有些同学问 last 这个变量保存的数据和 { x: last.x, y: last.y, color: last.color } “长的一样”，为什么不能直接 this.body.push(last) 呢？ 基本数据类型存储要说清楚上面的问题，首先大家要明白不同数据类型在内存中的存储形式是怎样的。我们都知道 JS 中的数据类型分为 2 大类，分别是： 基本数据类型：Number、String、Boolean、Null、Undefined、Symbol(ES6) 复杂数据类型：Object(包括数组、对象、函数、正则) 其中基本数据类型存储在栈内存中，他们是按值存放的，例如： 1234var age1 = 18;var age2 = age1;age2 = 20;console.log(age1, age2); // 18 20 上面代码在内存中的表现形式如下： 复杂数据类型存储复杂数据类型的真实数据是存放在堆内存中的，变量保存的只是在栈内存中的一个地址，这个地址指向堆内存中数据。例如： 1234var obj1 = &#123; age: 18 &#125;;var obj2 = obj1;obj2.age = 20; // obj2 是改变堆内存中的同一份数据console.log(obj1.age); // 所以 obj1 的数据也被影响了，结果是 20 上面代码在内存中的表现形式如下： 解释贪吃蛇的问题讲贪吃蛇时，关于蛇如何吃到食物我们说了这么一段话：在蛇运动时，判断蛇头的坐标是否与食物的坐标吻合，如果吻合，则往蛇身体后增加一节，然后再随机食物的坐标即可，代码如下： 12345678if (headX === food.x &amp;&amp; headY === food.y) &#123; // Step1: 获取蛇的最后一节 var last = this.body[this.body.length - 1]; // Step2: 添加到身体的最后 this.body.push(&#123; x: last.x, y: last.y, color: last.color &#125;); // Step3: 随机随机食物坐标 food.render(map);&#125; 如果直接 this.body.push(last) 的话，相当于每次添加的还是堆内存中的同一个 last，那在下次 move 修改数据的时候就会相互影响，无论你往后面 push 多少项 last，在修改到最前面的 three 时也会把后面的给修改掉（因为都是堆内存中的同一份数据），所以你看到的结果是后面的数据都是重复的，对应到页面上也就是最后一节的元素都是覆盖在一起的。测试代码如下： 12345678910var one = &#123;x: 26, y: 14, color: "red"&#125;;var two = &#123;x: 25, y: 14, color: "blue"&#125;;var three = &#123;x: 24, y: 14, color: "blue"&#125;;var arr = [one, two, three, three];for (var i = arr.length - 1; i &gt; 0; i--) &#123; arr[i].x = arr[i - 1].x; arr[i].y = arr[i - 1].y;&#125;console.log(arr); 该如何解决12345678910111213141516171819var arr = [ &#123;x: 26, y: 14, color: "red"&#125;, &#123;x: 25, y: 14, color: "blue"&#125;, &#123;x: 24, y: 14, color: "blue"&#125;];var last = arr[arr.length - 1];// 每次造一个全新的对象var newObj = &#123; x: last.x, y: last.y, color: last.color &#125;;// 或者拷贝原来的对象// var newObj = JSON.parse(JSON.stringify(last));arr.push(newObj);for (var i = arr.length - 1; i &gt; 0; i--) &#123; arr[i].x = arr[i - 1].x; arr[i].y = arr[i - 1].y;&#125;console.log(arr);]]></content>
      <categories>
        <category>JS 高级</category>
      </categories>
      <tags>
        <tag>贪吃蛇</tag>
        <tag>引用类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS 中的隐式转换]]></title>
    <url>%2F2019%2F05%2F24%2Finvisible-transform%2F</url>
    <content type="text"><![CDATA[JS 中有个“经典”的面试题：请问 [] == ![] 的结果是什么？一眼看上去肯定是 false，但结果却是 true，要清楚为什么是这样，就要了解 JS 在进行数据比较时的隐式转换规则是怎样的？ 注：除了对本问题的解释部分，其他都来自 JavaScript 高级程序设计，建议看书！我这里摘出了其中两点，来作为对常见问题的解释，其实还有其他细节或特殊注意的地方，建议在精力充沛的情况下可以自己去探索！ 相等操作符规则在转换不同的数据类型时，相等和不相等操作符遵循下列基本规则： 1 . 如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值，false 转换为 0，而 true 转换为 12 . 如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值3 . 如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf()方法，用得到的基本类型值按照前面的规则进行比较 这两个操作符在进行比较时又要遵循下列特殊的情况： 1 . null 和 undefined 是相等的2 . 要比较相等性之前，不能将 null 和 undefined 转换成其他任何值3 . 如果有一个操作数是 NaN，则相等操作符返回 false，而不相等操作符返回 true。重要提示：即使两个操作数都是 NaN，相等操作符也返回 false；因为按照规则，NaN 不等于 NaN4 . 如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回 true；否则，返回 false 关系操作符规则当关系操作符的操作数使用了非数值时，也要进行数据转换或完成某些奇怪的操作。以下就是相应的规则： 1 . 如果两个操作数都是数值，则执行数值比较2 . 如果两个操作数都是字符串，则比较两个字符串对应的字符编码值3 . 如果一个操作数是数值，则将另一个操作数转换为一个数值，然后执行数值比较4 . 如果一个操作数是对象，则调用这个对象的 valueOf()方法，用得到的结果按照前面的规则执行比较。如果对象没有 valueOf()方法，则调用 toString()方法，并用得到的结果根据前面的规则执行比较5 . 如果一个操作数是布尔值，则先将其转换为数值，然后再执行比较 解释 [] == ![]1[] == ![] Step1: ! 的优先级比 == 高，先执行 ![]，除了 null、undefined、’’、NaN、0 都是 true，所以 ![] 是 false 1[] == false Step2: 参考相等操作符比较的第 1 条规则，如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值，故结果如下： 1[] == 0 Step3: 参考相等操作符比较的第 3 条规则，调用对象的 valueOf() 方法得到原始值，并将原始值转换为数字结果如下： 1Number([].valueOf()) == 0]]></content>
      <categories>
        <category>JS 基础</category>
      </categories>
      <tags>
        <tag>隐式转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[触发全选按钮的几种思路]]></title>
    <url>%2F2019%2F05%2F22%2Fselect-all%2F</url>
    <content type="text"><![CDATA[需求：点击全选，选中上面所有的列表项；点击列表项中的每一个水果，如果有未选中则取消全选按钮，如果都选中了则激活全选按钮。 常规操作点击每个列表选项时，遍历所有列表选项并检查是否有未选中的，如果有则可以确定全选按钮的状态为未选中，否则全选按钮置为选中。 1234567891011121314151617181920212223242526272829303132var oAllInput = document.querySelector('#all');var aInput = document.querySelectorAll('ul input');// 点击全选 input 时根据自己的状态来控制其他列表项的 inputoAllInput.onchange = function() &#123; for(var i = 0; i &lt; aInput.length; i ++) &#123; aInput[i].checked = this.checked; &#125;&#125;;// 每次点击每一个列表项的 input 时，判断全选的 input 是否需要被选中for(var i = 0; i &lt; aInput.length; i ++) &#123; aInput[i].onclick = function() &#123; if (!this.checked) &#123; // 如果当前点击的按钮未选中，那就可以直接确定全选按钮的状态了 oAllInput.checked = false; // 也就没有必要进行下去了 return; &#125; var bBar = true; for(var i = 0; i &lt; aInput.length; i ++) &#123; // 发现有一个没选中的 if(!aInput[i].checked) &#123; bBar = false; // 发现有一个没选中的也就可以断定 oAllInput 的状态了，就没有必要再进行下去了 // 当然你不写 break 逻辑上也是对的，只是存在性能浪费 break; &#125; &#125; oAllInput.checked = bBar; &#125;;&#125; 注意细节思路和上面一样，下面的写法也是可以的，但有一点需要注意：点击列表中的每一项进行循环时，碰到未选中的一定要跳出循环，不然前面全选按钮的状态都会被最后一个按钮的状态所覆盖。 12345678910111213141516171819for (var i = 0; i &lt; aInput.length; i++) &#123; aInput[i].onclick = function () &#123; if (!this.checked) &#123; // 如果当前点击的按钮未选中，那就可以直接确定全选按钮的状态了 oAllInput.checked = false; // 也就没有必要进行下去了 return; &#125; for (var i = 0; i &lt; aInput.length; i++) &#123; if (!aInput[i].checked) &#123; oAllInput.checked = false; // 这里的 break 是必须要加的！不然全选按钮的状态永远是以最后一个的选中状态为准，这并不是我们所希望的 break; &#125; else &#123; oAllInput.checked = true; &#125; &#125; &#125;;&#125; 其他方法每次点击列表中的按钮时，获取所有已选中 input 的长度，并判断已选中 input 的 length 是否等于所有 input 的 length，如果相等，就可以激活全选按钮啦，否则则取消全选。 1234567891011for (var i = 0; i &lt; aInput.length; i++) &#123; aInput[i].onclick = function () &#123; var aInputChecked = document.querySelectorAll('ul input:checked'); // 已选中 length 等于所有 length 就证明全选中了，也就可以激活全选按钮啦 if (aInputChecked.length === aInput.length) &#123; oAllInput.checked = true; &#125; else &#123; oAllInput.checked = false; &#125; &#125;;&#125;]]></content>
      <categories>
        <category>Web API</category>
      </categories>
      <tags>
        <tag>全选</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排他思想]]></title>
    <url>%2F2019%2F05%2F21%2Fkill-other%2F</url>
    <content type="text"><![CDATA[上课我们在做点击当前按钮高亮，其他按钮重置为默认颜色的需求时，用到了“排他思想”，思路是：第一步，先干掉所有的；第二步，再操作自己的，简单明了，相信大家都比较清楚了！这里我再给大家做个总结，顺便再拓展一下其他的实现思路 ~ 排完思想需求：有 5 个按钮，点击当前按钮变红，其他按钮恢复默认颜色 123456&lt;!-- HTML 结构 --&gt;&lt;button&gt;1&lt;/button&gt;&lt;button&gt;2&lt;/button&gt;&lt;button&gt;3&lt;/button&gt;&lt;button&gt;4&lt;/button&gt;&lt;button&gt;5&lt;/button&gt; 123456789101112var aBtn = document.querySelectorAll('button');for(var i = 0; i &lt; aBtn.length; i ++) &#123; aBtn[i].onclick = function() &#123; // Step1: 先干掉所有人，“排完” for(var i = 0; i &lt; aBtn.length; i ++) &#123; aBtn[i].style.backgroundColor = ''; &#125; // Step2: 再操作自己的 this.style.backgroundColor = 'red'; &#125;;&#125; 排兄思想1234567&lt;script src="https://cdn.bootcss.com/jquery/3.4.0/jquery.min.js"&gt;&lt;/script&gt;&lt;script&gt;$("button").on("click", function() &#123; // 先操作自己的，再干掉所有的兄弟，“排兄” $(this).css("background", "red").siblings().css("background", "");&#125;);&lt;/script&gt; 排上思想1234567891011121314var aBtn = document.querySelectorAll('button');var prev = 0;for (var i = 0; i &lt; aBtn.length; i++) &#123; aBtn[i].index = i; aBtn[i].onclick = function () &#123; // Step1: 先干掉上一个，“排上” aBtn[prev].style.backgroundColor = ""; // Step2: 再操作自己的 this.style.backgroundColor = 'red'; // Step3: 操作完别忘了把自己也变成“上一个” prev = this.index; &#125;;&#125;]]></content>
      <categories>
        <category>Web API</category>
      </categories>
      <tags>
        <tag>排他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[认清 Node.appendChild()]]></title>
    <url>%2F2019%2F05%2F19%2FappendChild%2F</url>
    <content type="text"><![CDATA[Node.appendChild() 方法用于将一个节点添加到指定父节点的子节点列表的末尾，但在具体使用时还有其他一些需要我们关注的细节，以及对应的应用场景。 常规操作大家都清楚 appendChild 可以把创建好的元素插入到另一个元素内容的最后面，常规操作如下： 123456// 创建元素var oDiv = document.createElement('div');// 给创建好的元素加点内容oDiv.innerHTML = 'hello world';// 添加到 body 里面document.body.appendChild(oDiv); 需要注意上面代码必然没有任何问题，但这里还有一点需要大家注意的是，appendChild 在插入已存在元素的时候其实是做了两件事的： 先把原来已存在的元素删除 再进行后续的添加操作 具体是什么意思呢？大家看下面的例子就清楚了。需求：每次点击按钮把上面 ul 中的第一个元素移动到下面的 ul 中： 1234567891011121314151617181920&lt;ul id="ul1"&gt; &lt;li&gt;aaa&lt;/li&gt; &lt;li&gt;bbb&lt;/li&gt; &lt;li&gt;ccc&lt;/li&gt; &lt;li&gt;ddd&lt;/li&gt;&lt;/ul&gt;&lt;button id="btn"&gt;插入下面&lt;/button&gt;&lt;ul id="ul2"&gt;&lt;/ul&gt;&lt;script&gt;// 选择元素var oUl1 = document.querySelector('#ul1');var oBtn = document.querySelector('#btn');var oUl2 = document.querySelector('#ul2');oBtn.onclick = function() &#123; var oLi = oUl1.children[0]; // 每次点击按钮确实在 oUl2 中添加了一个新的元素，但同时 oUl1 中也相应少了这个元素 // 所以 appendChild 时相当于偷偷帮我们做了这么一步操作：oUl1.removeChild(oLi); oUl2.appendChild(oLi);&#125;;&lt;/script&gt; 实际应用好，现在我们清楚了当用 appendChild 插入已存在元素时会先删除之前再进行插入，那明白这个特性有什么实际的用处吗？答案是肯定的。例如下面一个需求，点击按钮，根据元素中的数字大小对这组元素进行排序： 123456789&lt;!-- HTML 结构 --&gt;&lt;ul id="ul1"&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;4&lt;/li&gt;&lt;/ul&gt;&lt;button id="btn"&gt;点击&lt;/button&gt; 123456789101112131415161718192021222324252627282930313233// 选择元素var oUl1 = document.querySelector('#ul1');var aLi = oUl1.querySelectorAll('li');var oBtn = document.querySelector('#btn');// 把伪数组 aLi 中的每一项都放到数组里面，目的是为了进行排序var arr = [];for(var i = 0; i &lt; aLi.length; i ++) &#123; arr.push(aLi[i]);&#125;oBtn.onclick = function () &#123; // 这就是我们熟悉的冒泡排序，你还记得吗 for (var i = 0; i &lt; arr.length - 1; i++) &#123; // 需要走 arr.length - 1 轮 for (var j = 0; j &lt; arr.length - i - 1; j++) &#123; // 每轮比较 arr.length - i - 1 次 var prevNum = parseFloat(arr[j].innerText); var nextNum = parseFloat(arr[j + 1].innerText); if (prevNum &gt; nextNum) &#123; // 不能对伪数组中其中一些直接赋值，例如：aLi[j] = aLi[j+1]，所以需要把伪数组转换成数组后再进行排序 var temp = null; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125; // 此时 arr 中装的已经是排好序的一堆 li 元素了 for(var i = 0; i &lt; arr.length; i ++) &#123; // 分别把排好序的数组中的每个元素插入到 oUl1 内容的最后 // 注意每次插入的同时也会把 oUl1 中那个相同的元素先给干掉，所以 oUl1 中也就不会存在重复元素的问题 oUl1.appendChild(arr[i]); &#125;&#125;; 优化代码这里优化相关的代码我们并没有学（不建议查看），我这里也提供一种较佳实战，是给你们以后看的（甚至是工作后），优化后的 JS 代码如下： 123456789101112const oUl1 = document.querySelector('#ul1');const aLi = oUl1.querySelectorAll('li');const oBtn = document.querySelector('#btn');oBtn.addEventListener('click', () =&gt; &#123; // Array.from 可以把伪数组转成数组，sort 的原理就是上面写的冒泡排序 Array.from(aLi).sort((li1, li2) =&gt; &#123; return parseFloat(li1.innerText) - parseFloat(li2.innerText); &#125;).forEach(li =&gt; &#123; oUl1.appendChild(li); &#125;)&#125;);]]></content>
      <categories>
        <category>Web API</category>
      </categories>
      <tags>
        <tag>appendChild</tag>
      </tags>
  </entry>
</search>
