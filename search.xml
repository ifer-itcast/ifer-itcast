<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数据类型检测]]></title>
    <url>%2F2019%2F05%2F26%2Fjudge-type%2F</url>
    <content type="text"><![CDATA[从 JS 基础第一天开始，我们就学习了如何使用 typeof 去判断数据类型，学习构造函数时我们又说了 constructor 以及 instanceof 也可以去进行类型检测，到 JS 高级时还讲了 Object.prototype.toString() 方法也可以去判断数据类型，那么问题来了，这么多方法它们之间有什么异同吗？不同场景下该怎样使用才比较合适呢？ 数据类型知多少既然要检测数据类型，首先要明确 JS 中的数据类型有以下 7 种： 简单数据类型：Number、String、Boolean、Null、Undefined、Symbol（ES6） 复杂数据类型：Object（包括函数、数组、对象、正则、日期等） typeoftypeof 它的使用方法有两种： 1234// 可以不带括号，直接跟数据console.log(typeof 36);// 也可以带括号console.log(typeof(36)); typeof 的返回值永远是一个全小写字符串，例如： 1console.log(typeof (typeof (typeof 66))); // string typeof 的返回值除了上面 7 种数据类型外，还多了一个 function，例如： 12function test() &#123;&#125;console.log(typeof test); // function 总结： 除了 Null（返回 object），typeof 对于基本数据类型都能返回正确的结果 除了 Function（返回 function），typeof 对于复杂数据类型都返回 object 缺点： typeof 对于复杂数据类型的处理，只能返回处于原型链最顶端的 Object 类型，不能细分 constructor新建一个（构造）函数 Fn 时，JS 引擎会给自 Fn 添加一个 prototype 属性，prototype 下又有一个 constructor 指向 Fn 函数，可用如下代码表示： 12function Fn() &#123;&#125;console.log(Fn.prototype.constructor === Fn); // true 当我们执行 new Fn 来创建 Fn 的实例后，这个实例的 constructor 也就指向 Fn，如下： 1234function Fn() &#123;&#125;var f1 = new Fn;// f1 下本没有 constructor，自己没有则会通过原型链向上查找到 Fn.prototype 上console.log(f1.constructor === Fn); // true 如此一来我们就可以通过 constructor 来判断某个实例对象具体的类型（来源），例如上面代码从原型链的角度来说 f1 的类型（来源）就是 Fn。 同样的道理，其他数据的也可以通过 constructor 来判断具体的类型，它可以解决 typeof 对应复杂数据类型的判断无能为力的问题，测试如下： 1234567console.log([].constructor === Array); // trueconsole.log(new Date().constructor === Date); // trueconsole.log(new Function().constructor === Function);console.log(''.constructor === String);console.log(true.constructor === Boolean);console.log(new Error().constructor === Error);console.log(document.constructor === HTMLDocument); constructor 的小问题： null 和 undefined 上没有 constructor 这属性，不能通过 constructor 来判断 当 prototype 被不小写重写后，会导致 constructor 判断不准确的问题，例如： 1234567891011function Test() &#123;&#125;var t1 = new Test;console.log(t1.constructor === Test); // true// 重写原型会导致 Test.prototype.constructor 指向不正确// 当然对应的实例对象在用 constructor 去判断类型的时候也就会指向不正确Test.prototype = &#123; showAge: function() &#123;&#125;&#125;;var t2 = new Test();console.log(t2.constructor === Test); // false instanceof它主要用来判断一个对象是否能够通过原型链找到另一个对象的原型，什么意思呢？例如： 12// [] 可以通过 __proto__ 找到 Array.prototype，所以结果是 trueconsole.log([] instanceof Array); 123// [].__proto__.__proto__ === Object.prototype// 说明 [] 也是可以通过原型链找过 Object 的原型，所以下面结果也是 trueconsole.log([] instanceof Object); 所以大家也看到了，instanceof 并不能准确的找到某个实例的类型，但它相对于 constructor 有这样一个特点，即便构造函数的原型被重写后，实例也能通过 instanceof 去判断自己的类型，例如： 1234567function Test() &#123;&#125;Test.prototype = &#123; showAge: function() &#123;&#125;&#125;;var t1 = new Test();console.log(t1 instanceof Test); // trueconsole.log(t1 instanceof Object); // 当然对应顶级对象 Object 也是 true，还是不能准确判断就是 Test 类型 instanceof 还有另外一个问题需要你注意的，当页面中引入 iframe 时，实例化 iframe 窗口下的对象和当前窗口下相对应的构造函数进行 instanceof 判断时也会出现问题。例如： 1234567891011var oFrame = document.createElement('iframe');document.body.appendChild(oFrame);// ifame 窗口下实例化的 arrvar arr = new window.frames[0].Array;console.log(arr instanceof window.frames[0].Array); // trueconsole.log(arr instanceof Array); // false// 针对上面的问题 ES5 提供了 Array.isArray() 这个方法进行判断console.log(Array.isArray(arr)); // true Object.prototype.toString他返回的信息格式是 [object Xxx]（注意第一个 X 是大写），对于 {} 直接调用 toString 既可以返回 [object Object]，其他类型需要借助 call/apply 方法去调用，例如： 12345678910111213// 也可以把 Object.prototype 替换成 &#123;&#125;// 因为调用 &#123;&#125; 下的 toString() 方法，自己没有会通过原型链去 Object.prototype 上面找console.log(Object.prototype.toString.call(233)); // [object Number]console.log(Object.prototype.toString.call('233')); // [object String]console.log(Object.prototype.toString.call(true)); // [object Boolean]console.log(Object.prototype.toString.call(null)); // [object Null]console.log(Object.prototype.toString.call(undefined)); // [object Undefined]console.log(Object.prototype.toString.call(Symbol())); // [object Symbol]console.log(Object.prototype.toString.call([])); // [object Array]console.log(Object.prototype.toString.call(new Function)); // [object Function]console.log(Object.prototype.toString.call(new Date)); // [object Date]console.log(Object.prototype.toString.call(new RegExp)); // [object RegExp] 可见 Object.prototype.toString() 简直太好用啦，推荐使用！]]></content>
      <categories>
        <category>JS 高级</category>
      </categories>
      <tags>
        <tag>判断数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2F2019%2F05%2F26%2Ftest%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[数据在内存中的存储形式]]></title>
    <url>%2F2019%2F05%2F25%2Fsnake-question%2F</url>
    <content type="text"><![CDATA[学习贪吃蛇时，往蛇身体增加最后一节，当时代码是直接这样写的 this.body.push({ x: last.x, y: last.y, color: last.color })，有些同学问 last 这个变量保存的数据和 { x: last.x, y: last.y, color: last.color } “长的一样”，为什么不能直接 this.body.push(last) 呢？ 基本数据类型存储要说清楚上面的问题，首先大家要明白不同数据类型在内存中的存储形式是怎样的。我们都知道 JS 中的数据类型分为 2 大类，分别是： 基本数据类型：Number、String、Boolean、Null、Undefined、Symbol(ES6) 复杂数据类型：Object(包括数组、对象、函数、正则) 其中基本数据类型存储在栈内存中，他们是按值存放的，例如： 1234var age1 = 18;var age2 = age1;age2 = 20;console.log(age1, age2); // 18 20 上面代码在内存中的表现形式如下： 复杂数据类型存储复杂数据类型的真实数据是存放在堆内存中的，变量保存的只是在栈内存中的一个地址，这个地址指向堆内存中数据。例如： 1234var obj1 = &#123; age: 18 &#125;;var obj2 = obj1;obj2.age = 20; // obj2 是改变堆内存中的同一份数据console.log(obj1.age); // 所以 obj1 的数据也被影响了，结果是 20 上面代码在内存中的表现形式如下： 解释贪吃蛇的问题讲贪吃蛇时，关于蛇如何吃到食物我们说了这么一段话：在蛇运动时，判断蛇头的坐标是否与食物的坐标吻合，如果吻合，则往蛇身体后增加一节，然后再随机食物的坐标即可，代码如下： 12345678if (headX === food.x &amp;&amp; headY === food.y) &#123; // Step1: 获取蛇的最后一节 var last = this.body[this.body.length - 1]; // Step2: 添加到身体的最后 this.body.push(&#123; x: last.x, y: last.y, color: last.color &#125;); // Step3: 随机随机食物坐标 food.render(map);&#125; 如果直接 this.body.push(last) 的话，相当于每次添加的还是堆内存中的同一个 last，那在下次 move 修改数据的时候就会相互影响，无论你往后面 push 多少项 last，在修改到最前面的 three 时也会把后面的给修改掉（因为都是堆内存中的同一份数据），所以你看到的结果是后面的数据都是重复的，对应到页面上也就是最后一节的元素都是覆盖在一起的。测试代码如下： 12345678910var one = &#123;x: 26, y: 14, color: "red"&#125;;var two = &#123;x: 25, y: 14, color: "blue"&#125;;var three = &#123;x: 24, y: 14, color: "blue"&#125;;var arr = [one, two, three, three];for (var i = arr.length - 1; i &gt; 0; i--) &#123; arr[i].x = arr[i - 1].x; arr[i].y = arr[i - 1].y;&#125;console.log(arr); 该如何解决12345678910111213141516171819var arr = [ &#123;x: 26, y: 14, color: "red"&#125;, &#123;x: 25, y: 14, color: "blue"&#125;, &#123;x: 24, y: 14, color: "blue"&#125;];var last = arr[arr.length - 1];// 每次造一个全新的对象var newObj = &#123; x: last.x, y: last.y, color: last.color &#125;;// 或者拷贝原来的对象// var newObj = JSON.parse(JSON.stringify(last));arr.push(newObj);for (var i = arr.length - 1; i &gt; 0; i--) &#123; arr[i].x = arr[i - 1].x; arr[i].y = arr[i - 1].y;&#125;console.log(arr);]]></content>
      <categories>
        <category>JS 高级</category>
      </categories>
      <tags>
        <tag>贪吃蛇</tag>
        <tag>引用类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS 中的隐式转换]]></title>
    <url>%2F2019%2F05%2F24%2Finvisible-transform%2F</url>
    <content type="text"></content>
      <categories>
        <category>JS 基础</category>
      </categories>
      <tags>
        <tag>隐式转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[触发全选按钮的几种思路]]></title>
    <url>%2F2019%2F05%2F22%2Fselect-all%2F</url>
    <content type="text"><![CDATA[需求：点击全选，选中上面所有的列表项；点击列表项中的每一个水果，如果有未选中则取消全选按钮，如果都选中了则激活全选按钮。 常规操作点击每个列表选项时，遍历所有列表选项并检查是否有未选中的，如果有则可以确定全选按钮的状态为未选中，否则全选按钮置为选中。 1234567891011121314151617181920212223242526272829303132var oAllInput = document.querySelector('#all');var aInput = document.querySelectorAll('ul input');// 点击全选 input 时根据自己的状态来控制其他列表项的 inputoAllInput.onchange = function() &#123; for(var i = 0; i &lt; aInput.length; i ++) &#123; aInput[i].checked = this.checked; &#125;&#125;;// 每次点击每一个列表项的 input 时，判断全选的 input 是否需要被选中for(var i = 0; i &lt; aInput.length; i ++) &#123; aInput[i].onclick = function() &#123; if (!this.checked) &#123; // 如果当前点击的按钮未选中，那就可以直接确定全选按钮的状态了 oAllInput.checked = false; // 也就没有必要进行下去了 return; &#125; var bBar = true; for(var i = 0; i &lt; aInput.length; i ++) &#123; // 发现有一个没选中的 if(!aInput[i].checked) &#123; bBar = false; // 发现有一个没选中的也就可以断定 oAllInput 的状态了，就没有必要再进行下去了 // 当然你不写 break 逻辑上也是对的，只是存在性能浪费 break; &#125; &#125; oAllInput.checked = bBar; &#125;;&#125; 注意细节思路和上面一样，下面的写法也是可以的，但有一点需要注意：点击列表中的每一项进行循环时，碰到未选中的一定要跳出循环，不然前面全选按钮的状态都会被最后一个按钮的状态所覆盖。 12345678910111213141516171819for (var i = 0; i &lt; aInput.length; i++) &#123; aInput[i].onclick = function () &#123; if (!this.checked) &#123; // 如果当前点击的按钮未选中，那就可以直接确定全选按钮的状态了 oAllInput.checked = false; // 也就没有必要进行下去了 return; &#125; for (var i = 0; i &lt; aInput.length; i++) &#123; if (!aInput[i].checked) &#123; oAllInput.checked = false; // 这里的 break 是必须要加的！不然全选按钮的状态永远是以最后一个的选中状态为准，这并不是我们所希望的 break; &#125; else &#123; oAllInput.checked = true; &#125; &#125; &#125;;&#125; 其他方法每次点击列表中的按钮时，获取所有已选中 input 的长度，并判断已选中 input 的 length 是否等于所有 input 的 length，如果相等，就可以激活全选按钮啦，否则则取消全选。 1234567891011for (var i = 0; i &lt; aInput.length; i++) &#123; aInput[i].onclick = function () &#123; var aInputChecked = document.querySelectorAll('ul input:checked'); // 已选中 length 等于所有 length 就证明全选中了，也就可以激活全选按钮啦 if (aInputChecked.length === aInput.length) &#123; oAllInput.checked = true; &#125; else &#123; oAllInput.checked = false; &#125; &#125;;&#125;]]></content>
      <categories>
        <category>Web API</category>
      </categories>
      <tags>
        <tag>全选</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排他思想]]></title>
    <url>%2F2019%2F05%2F21%2Fkill-other%2F</url>
    <content type="text"><![CDATA[上课我们在做点击当前按钮高亮，其他按钮重置为默认颜色的需求时，用到了“排他思想”，思路是：第一步，先干掉所有的；第二步，再操作自己的，简单明了，相信大家都比较清楚了！这里我再给大家做个总结，顺便再拓展一下其他的实现思路 ~ 排完思想需求：有 5 个按钮，点击当前按钮变红，其他按钮恢复默认颜色 123456&lt;!-- HTML 结构 --&gt;&lt;button&gt;1&lt;/button&gt;&lt;button&gt;2&lt;/button&gt;&lt;button&gt;3&lt;/button&gt;&lt;button&gt;4&lt;/button&gt;&lt;button&gt;5&lt;/button&gt; 123456789101112var aBtn = document.querySelectorAll('button');for(var i = 0; i &lt; aBtn.length; i ++) &#123; aBtn[i].onclick = function() &#123; // Step1: 先干掉所有人，“排完” for(var i = 0; i &lt; aBtn.length; i ++) &#123; aBtn[i].style.backgroundColor = ''; &#125; // Step2: 再操作自己的 this.style.backgroundColor = 'red'; &#125;;&#125; 排兄思想1234567&lt;script src="https://cdn.bootcss.com/jquery/3.4.0/jquery.min.js"&gt;&lt;/script&gt;&lt;script&gt;$("button").on("click", function() &#123; // 先操作自己的，再干掉所有的兄弟，“排兄” $(this).css("background", "red").siblings().css("background", "");&#125;);&lt;/script&gt; 排上思想1234567891011121314var aBtn = document.querySelectorAll('button');var prev = 0;for (var i = 0; i &lt; aBtn.length; i++) &#123; aBtn[i].index = i; aBtn[i].onclick = function () &#123; // Step1: 先干掉上一个，“排上” aBtn[prev].style.backgroundColor = ""; // Step2: 再操作自己的 this.style.backgroundColor = 'red'; // Step3: 操作完别忘了把自己也变成“上一个” prev = this.index; &#125;;&#125;]]></content>
      <categories>
        <category>Web API</category>
      </categories>
      <tags>
        <tag>排他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[认清 Node.appendChild()]]></title>
    <url>%2F2019%2F05%2F19%2FappendChild%2F</url>
    <content type="text"><![CDATA[Node.appendChild() 方法用于将一个节点添加到指定父节点的子节点列表的末尾，但在具体使用时还有其他一些需要我们关注的细节，以及对应的应用场景。 常规操作大家都清楚 appendChild 可以把创建好的元素插入到另一个元素内容的最后面，常规操作如下： 123456// 创建元素var oDiv = document.createElement('div');// 给创建好的元素加点内容oDiv.innerHTML = 'hello world';// 添加到 body 里面document.body.appendChild(oDiv); 需要注意上面代码必然没有任何问题，但这里还有一点需要大家注意的是，appendChild 在插入已存在元素的时候其实是做了两件事的： 先把原来已存在的元素删除 再进行后续的添加操作 具体是什么意思呢？大家看下面的例子就清楚了。需求：每次点击按钮把上面 ul 中的第一个元素移动到下面的 ul 中： 1234567891011121314151617181920&lt;ul id="ul1"&gt; &lt;li&gt;aaa&lt;/li&gt; &lt;li&gt;bbb&lt;/li&gt; &lt;li&gt;ccc&lt;/li&gt; &lt;li&gt;ddd&lt;/li&gt;&lt;/ul&gt;&lt;button id="btn"&gt;插入下面&lt;/button&gt;&lt;ul id="ul2"&gt;&lt;/ul&gt;&lt;script&gt;// 选择元素var oUl1 = document.querySelector('#ul1');var oBtn = document.querySelector('#btn');var oUl2 = document.querySelector('#ul2');oBtn.onclick = function() &#123; var oLi = oUl1.children[0]; // 每次点击按钮确实在 oUl2 中添加了一个新的元素，但同时 oUl1 中也相应少了这个元素 // 所以 appendChild 时相当于偷偷帮我们做了这么一步操作：oUl1.removeChild(oLi); oUl2.appendChild(oLi);&#125;;&lt;/script&gt; 实际应用好，现在我们清楚了当用 appendChild 插入已存在元素时会先删除之前再进行插入，那明白这个特性有什么实际的用处吗？答案是肯定的。例如下面一个需求，点击按钮，根据元素中的数字大小对这组元素进行排序： 123456789&lt;!-- HTML 结构 --&gt;&lt;ul id="ul1"&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;4&lt;/li&gt;&lt;/ul&gt;&lt;button id="btn"&gt;点击&lt;/button&gt; 123456789101112131415161718192021222324252627282930313233// 选择元素var oUl1 = document.querySelector('#ul1');var aLi = oUl1.querySelectorAll('li');var oBtn = document.querySelector('#btn');// 把伪数组 aLi 中的每一项都放到数组里面，目的是为了进行排序var arr = [];for(var i = 0; i &lt; aLi.length; i ++) &#123; arr.push(aLi[i]);&#125;oBtn.onclick = function () &#123; // 这就是我们熟悉的冒泡排序，你还记得吗 for (var i = 0; i &lt; arr.length - 1; i++) &#123; // 需要走 arr.length - 1 轮 for (var j = 0; j &lt; arr.length - i - 1; j++) &#123; // 每轮比较 arr.length - i - 1 次 var prevNum = parseFloat(arr[j].innerText); var nextNum = parseFloat(arr[j + 1].innerText); if (prevNum &gt; nextNum) &#123; // 不能对伪数组中其中一些直接赋值，例如：aLi[j] = aLi[j+1]，所以需要把伪数组转换成数组后再进行排序 var temp = null; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125; // 此时 arr 中装的已经是排好序的一堆 li 元素了 for(var i = 0; i &lt; arr.length; i ++) &#123; // 分别把排好序的数组中的每个元素插入到 oUl1 内容的最后 // 注意每次插入的同时也会把 oUl1 中那个相同的元素先给干掉，所以 oUl1 中也就不会存在重复元素的问题 oUl1.appendChild(arr[i]); &#125;&#125;; 优化代码这里优化相关的代码我们并没有学（不建议查看），我这里也提供一种较佳实战，是给你们以后看的（甚至是工作后），优化后的 JS 代码如下： 123456789101112const oUl1 = document.querySelector('#ul1');const aLi = oUl1.querySelectorAll('li');const oBtn = document.querySelector('#btn');oBtn.addEventListener('click', () =&gt; &#123; // Array.from 可以把伪数组转成数组，sort 的原理就是上面写的冒泡排序 Array.from(aLi).sort((li1, li2) =&gt; &#123; return parseFloat(li1.innerText) - parseFloat(li2.innerText); &#125;).forEach(li =&gt; &#123; oUl1.appendChild(li); &#125;)&#125;);]]></content>
      <categories>
        <category>Web API</category>
      </categories>
      <tags>
        <tag>appendChild</tag>
      </tags>
  </entry>
</search>
