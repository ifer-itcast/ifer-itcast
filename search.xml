<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Webpack 基础篇]]></title>
    <url>%2F2019%2F07%2F06%2Fwebpack-base%2F</url>
    <content type="text"><![CDATA[打通 Webpack 任督之基础篇 ~ 基本跑通初始化 package.json1npm init -y 安装 webpack 和命令行工具12// 为了避免不必要的版本问题，不建议全局安装！webpack 是核心模块，webpack-cli 是命令行工具npm i webpack webpack-cli -D 123// 安装完成后可以使用以下命令检测版本号npx webpack -vnpx webpack-cli -v 打包第一个应用entry: 资源打包的入口，webpack 默认的入口就是 src/index.js，其实可以省略 entry 配置output-filename: 输出资源名，默认会输出到 dist 目录mode: 打包模式，webpack 会自动添加适合当前模式的一些配置 1npx webpack --entry=./src/index.js --output-filename=bundle.js --mode=development 使用 npm scripts上面每次打包都要输入一大串命令，不好！这时候可以配置 package.json 如下： 12345&#123; "scripts": &#123; "build": "webpack --output-filename=bundle.js --mode=development" &#125;&#125; 下次只需执行 npm run build 即可 使用配置文件可以使用 npx webpack -h 查看 webpack 相关的配置项以及命令行参数！当项目需要越来越多的配置项时，往 package.json 中添加就会变得越来越难以维护，为了解决这个问题，可以把所有的配置放在某个文件中，webpack 每次打包的时候会读取该文件的配置。 这里的默认配置文件是 webpack.config.js，如果修改了需要按这种方式 npx webpack --config webpack.config.my.js 去寻找对应的配置文件！约定大于配置，默认会把 src/index.js 打包到 dist/main.js。 12345678910const path = require('path');// 采用 CommonJS 模块规范module.exports = &#123; mode: 'development', // 默认 entry: './src/index.js', // 默认 output: &#123; path: path.resolve(__dirname, 'dist'), // 默认，__dirname 可省略，或 path.join(__dirname, './dist') filename: 'main.js' // 默认 &#125;&#125;; 配置 package.json12345// webpack --mode production 可以执行模式// 注意这里 package.json 中的 webpack 不是全局的，是 node_modules/.bin 下的"scripts": &#123; "build": "webpack"&#125; 打包并测试执行 npx webpack 或者 npm run build，dist 中建个 HTML 文件引入打包后的代码可以测试打包的结果 命令行传参关于如何给 package.json 中的命令传参？ 1234// 如果 package.json 中只配置了这些"scripts": &#123; "build": "webpack"&#125; 123// 可以通过 -- 的形式传参，相当于执行 webpack --config webpack.config.my.jsnpm run build -- --config webpack.config.my.jsnpm run build -- --config development 本地启动服务通过 webpack-dev-server 可以启动一个服务（内部依赖的是 Express），它也可以在内存中生成打包后的代码 main.js，这点可以通过访问 localhost:8080/main.js 可以证明！ 还有一项特性是 live-reloading（自动刷新），在 index.html 中引入 &lt;script src=&quot;/main.js&quot;&gt;&lt;/script&gt; 可以进行测试！ 还有更先进的功能 hot-module-replacement（模块热替换），不需要刷新浏览器就能展示更新后的内容！ 安装12// 注意是开发依赖，项目上线时可以通过 npm install --production 过滤掉 devDependencies 中的模块cnpm i webpack-dev-server -D 配置 package.json123"scripts": &#123; "dev": "webpack-dev-server"&#125; 也可以像下面一样配置一些参数，不过一般还是建议在 webpack.config.js 中进行配置 123"script": &#123; "dev": "webpack-dev-server --open firefox --port 3000 --hot --progress --compress --host 127.0.0.1"&#125; 配置 webpack.config.js默认启动服务的根目录是和 webpack.config.js 平级的目录，我想用 dist 当做根目录就需要通过 contentBase 来指定。例如配置后访问 localhost:8080/a.js 就是指的 dist 下的 a.js 1234567891011module.exports = &#123; mode: 'development', devServer: &#123; contentBase: path.join(__dirname, "dist"), // 无论这里怎么配置，内存中的 main.js 还是通过 localhost:8080/main.js 访问，但这样配置时会影响实际资源的存放路径，例如通过 localhost:8080 想访问首页时，就要把 index.html 就要放在 dist 目录下 // publicPath: '/dist', // 会为内存中的资源添加一个前缀，这时候再访问内存中的 main.js 就需要 localhost:8080/dist/main.js progress: true, // 显示打包进度 compress: true, // 开启 GZIP 压缩 port: 9000, open: true, &#125;&#125;; 使用运行 npm run dev，此时访问 http://localhost:8080/main.js 可以看到内存中的 main.js 文件 热更新 JS在 dist 目录下新建一个 html 文件如下： 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src="/main.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 通过 localhost:8080 访问，修改 JS 文件会发现页面也进行了刷新。想在不刷新页面的情况下也更新 JS，这就是热更新（注意把 index.html 放在和 webpack.config.js 平级目录下，或通过 contentBase 修改根目录并在 index.html 放在其中）！ 1234567891011121314151617181920const path = require('path');const webpack = require('webpack');module.exports = &#123; mode: 'development', // 默认 entry: './src/index.js', // 默认 output: &#123; path: path.resolve(__dirname, 'dist'), // 默认，__dirname 可省略 filename: 'main.js' // 默认 &#125;, devServer: &#123; contentBase: path.resolve('dist'), // step 1 hot: true &#125;, plugins: [ // step 2 new webpack.HotModuleReplacementPlugin() ]&#125;; 123456console.log('hello world');// step 3if(module.hot) &#123; module.hot.accept();&#125; 注意以上只是 JS 文件的热更新，修改 dist 中的 HTML 文件别说热更新，刷新都刷新不了，当然这也是正常的，后面解决！ 如果关闭 JS 热更新（hot），更改 HTML 文件便会自动刷新！ 模板文件通过 html-webpack-plugin 可以引用模板文件，配合 webpack-dev-server 可以让此 HTML 文件也生成于内存中（快），当然也可以打包进 dist，打包后的文件中会自动帮我们引入 JS 等，这样也就不必在模板文件中手动引入 main.js 了！ 安装1cnpm i html-webpack-plugin -D 配置 plugins12345678910111213141516171819202122232425262728293031323334const path = require('path');const webpack = require('webpack');const HtmlWebpackPlugin = require('html-webpack-plugin');const htmlPlugin = new HtmlWebpackPlugin(&#123; // 引入的模板 template: path.join(__dirname, './src/index.html'), // 在内存中生成的文件的名称 filename: 'index.html', // npm run build 或者运行 webpack-dev-server 时删除 html 文件中属性的双引号 minify: &#123; removeAttributeQuotes: true, collapseWhitespace: true // HTML 变成一行 &#125;, // 给 HTML 中引入的文件加 Hash，防止缓存 hash: true&#125;);module.exports = &#123; mode: 'development', entry: './src/index.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'main.[hash:8].js' &#125;, devServer: &#123; contentBase: path.resolve(__dirname, 'dist'), hot: true &#125;, plugins: [ new webpack.HotModuleReplacementPlugin(), htmlPlugin ]&#125;; 测试此时修改 src/index.js 和 src/index.html 会自动的帮我们刷新页面！注意此时我删除了 index.js 中的如下热更新代码： 1234// 暂时关闭热更新，为了让修改 index.html 时也实时刷新页面if(module.hot) &#123; module.hot.accept();&#125; 以上代码 使用 Loader使用 loader 常写的有三种方式，以 css-loader 和 style-loader 为例，如下： loader 12345678module: &#123; rules: [ &#123; test: /\.css$/, loader: ["style-loader", "css-loader"] &#125; ]&#125; use 12345678module: &#123; rules: [ &#123; test: /\.css$/, use: ["style-loader", "css-loader"], &#125; ]&#125; use + loader 1234567891011121314module: &#123; rules: [ &#123; test: /\.css$/, use: [&#123; loader: "style-loader", options: &#123; // 插入头部 insertAt: 'top' &#125; &#125;, "css-loader"] &#125; ]&#125; 使用样式使用 CSS安装1cnpm i style-loader css-loader -D 配置12345678module: &#123; rules: [ &#123; test: /\.css$/, use: ['style-loader', 'css-loader'] &#125; ]&#125; 使用12import './index.css';require('./index.css'); 使用 Less安裝1cnpm i less less-loader -D 配置module rules 下配置 loader 12345678module: &#123; rules: [ &#123; test: /\.less$/, use: ['style-loader', 'css-loader', 'less-loader'] &#125; ]&#125; 使用 Sass安裝1cnpm i node-sass sass-loader -D 配置12345678module: &#123; rules: [ &#123; test: /\.scss$/, use: ['style-loader', 'css-loader', 'sass-loader'] &#125; ]&#125; 给样式加前缀使用 autoprefixer，并配合 postcss-loader 可以处理 CSS3 的前缀，最后打包时会自动带上 安装1cnpm i postcss-loader autoprefixer -D 配置123456789// 配置 loadermodule: &#123; rules: [ &#123; test: /\.css$/, use: ['style-loader', "css-loader", "postcss-loader"] &#125; ]&#125; 根目录新建 postcss.config.js 并配置如下： 123module.exports = &#123; plugins: [require('autoprefixer')]&#125;; 抽离样式利用 mini-css-extract-plugin 插件可以抽离出 CSS，但使用此插件再次修改 CSS 后页面不会自动刷新或热更新，所以一般生产环境才使用！ 安装1cnpm i mini-css-extract-plugin -D 配置12345678910111213141516171819// 抽离 Less 同理module: &#123; rules: [ &#123; test: /\.css$/, use: [&#123; // Step 1 loader: MiniCssExtractPlugin.loader &#125;, "css-loader", "postcss-loader"] &#125; ]&#125;,plugins: [ // Step 2 new MiniCssExtractPlugin(&#123; // name 指的是入口文件的属性名，单入口默认是 main filename: '[name].css' &#125;)] 修改 CSS 导出的路径也可以给导出的 CSS 划分目录等 1234new MiniCssExtractPlugin(&#123; // entry 的名字 main filename: 'css/[name].css'&#125;) 以上代码 使用图片JS 和 CSS 中使用 file-loader 解决 CSS 和 JS 文件引入图片的路径问题 url-loader 当图片小于 limit 的时候对图片进行 BASE64 编码，大于 limit 调用 file-loader 进行拷贝 安装1cnpm i file-loader url-loader@1.0.1 -D 配置123456789101112131415161718192021222324module: &#123; rules: [ &#123; test: /\.(gif|jpg|jpeg|png|bmp|eot|woff|woff2|ttf|svg)$/, use: [ &#123; // url-loader 里面封装了 file-loader loader: 'url-loader', options: &#123; // 小于 10kb 才需要 base64，这时候起作用的 url-loader // 大于 10kb 会在内部自动调用 file-loader 去处理图片 // 默认不加这个参数全部是用 url-loader 搞成 base64 limit: 10 * 1024, // 将打包的图片放到 img 目录，图片并不会放到缓存中，缓存的是 HTML、JS 和 CSS 文件 // 可以先 npm run build 到 dist/img 目录，当然也要把 devServer 的 contentBase 配置为 dist outputPath: '/img/', // 给引入的图片资源加上前缀 publicPath: 'http://www.zhihur.com' &#125; &#125; ] &#125; ]&#125; 使用123456// 若图片大小小于 limit imgSrc 将是一个 base64，否则是一个路径import imgSrc from './images/timg.jpg';const img = new Image();img.src = imgSrc;img.width = 100;document.body.appendChild(img); 12345.logo &#123; width: 300px; height: 100px; background: url(./images/timg.jpg) no-repeat;&#125; HTML 中使用此 html-withimg-loader 插件可以帮助我们在 HTML 中使用图片 安裝1cnpm i html-withimg-loader -D 配置12345678module: &#123; rules: [ &#123; test: /\.html$/, use: 'html-withimg-loader' &#125; ]&#125; 使用1&lt;img src="timg.jpg" width="100" alt=""&gt; 以上代码 使用 JS主要是对高版本的 JS 代码进行转换，使浏览器兼容 转换箭头函数等如下使用箭头函数，会发现打包后的代码也是箭头函数，没有转成 ES5，这不是我们所期望的 1234let aaa = () =&gt; &#123; console.log('hello1');&#125;aaa(); 解决如下 12// 需要使用 loader 并配合 presetscnpm i babel-loader @babel/core @babel/preset-env -D 123456789101112131415&#123; test: /\.js$/, use: &#123; loader: 'babel-loader', options: &#123; presets: [ '@babel/preset-env' ] &#125; &#125;, // 别忘记排除这个，注意这里的值没有引号！ exclude: /node_modules/, // 最好写上 include: path.resolve(__dirname, 'src')&#125; 上面 presets 的配置也可以写在 .babelrc 单独的文件中，例如： 123&#123; "presets": ["@babel/preset-env"]&#125; 配置完上面再使用 uglifyjs 进行代码压缩时也就不会报错了 转换类等123456// 直接使用报错class A &#123; a = 1&#125;let b = new A();console.log(b.a); 12// 注意这里使用的是一个针对 JS 文件的插件，而不是 loader 或 预设cnpm i @babel/plugin-proposal-class-properties -D 1234567891011121314&#123; test: /\.js$/, use: &#123; loader: 'babel-loader', options: &#123; presets: [ '@babel/preset-env' ], plugins: [ ['@babel/plugin-proposal-class-properties',&#123;loose: true&#125;] ] &#125; &#125;&#125; 或 .bablerc 中配置如下： 12345678&#123; "presets": [ "@babel/preset-env" ], "plugins": [ ["@babel/plugin-proposal-class-properties",&#123;"loose": true&#125;] ]&#125; 转换装饰器等VSCode 中修改这个参数 experimentalDecorators 可以禁用使用装饰器时的警告 12345678@logclass A &#123; a = 1&#125;function log(target) &#123; console.log(target);&#125; 12// 使用的也是一个插件cnpm i @babel/plugin-proposal-decorators -D 12345678910111213141516&#123; test: /\.js$/, use: &#123; loader: 'babel-loader', options: &#123; presets: [ '@babel/preset-env' ], plugins: [ // 注意这里是有顺序讲究的 ['@babel/plugin-proposal-decorators', &#123;legacy: true&#125;], ['@babel/plugin-proposal-class-properties',&#123;loose: true&#125;] ] &#125; &#125;&#125; 转换生成器等123456789function *aaa(x) &#123; yield x + 1; yield x + 2; return x + 3;&#125;let it = aaa(1);console.log(it.next()); // &#123;value: 2, done: false&#125;console.log(it.next()); // &#123;value: 3, done: false&#125;console.log(it.next()); // &#123;value: 4, done: true&#125; 123// 注意 @babel/runtime 是生产依赖cnpm i @babel/plugin-transform-runtime -Dcnpm i @babel/runtime -S 1234567891011121314151617&#123; test: /\.js$/, use: &#123; loader: 'babel-loader', options: &#123; presets: [ '@babel/preset-env' ], plugins: [ // 注意这里是有顺序讲究的 ['@babel/plugin-proposal-decorators', &#123;legacy: true&#125;], ['@babel/plugin-proposal-class-properties',&#123;loose: true&#125;], ['@babel/plugin-transform-runtime'] ] &#125; &#125;&#125; 转换 includes 等12// 直接使用是可以允许，但并不会将打包后的代码转换成 ES5console.log('aaa'.includes('a')); 1cnpm i @babel/polyfill -S 123// 使用require('@babel/polyfill')console.log('aaa'.includes('a')); 注意：Babel 7.4.0 以后使用有变化，参见 以上代码 使用 TS安装12cnpm i typescript -gcnpm i typescript ts-loader -D 配置12// 生成 tsconfig.json 配置文件tsc --init 12345678910111213&#123; module: &#123; rules: [ &#123; test: /\.ts$/, use: 'ts-loader', // 注意这里我配在了 src/ts 目录下 include: path.resolve(__dirname, 'src/ts'), exclude: /node_modules/ &#125; ] &#125;&#125; 使用1234function sum(...args:number[]): number &#123; return eval( args.join('+') );&#125;export default sum; 12import sum from './ts/test.ts';console.log(sum(1, 2, 3)); 以上代码 使用 React安装1cnpm i react react-dom -S 使用12345678910111213import React from 'react';import ReactDOM from 'react-dom';// 元素类型、属性、子节点const virtualH1 = React.createElement('h1', &#123; id: 'title', title: 'hello world'&#125;, 'hello world');const virtualDiv = React.createElement('div', null, '嘻嘻', virtualH1);// 要渲染的虚拟 DOM、容器ReactDOM.render(virtualDiv, document.querySelector('#root')); 使用 JSX上面的 React.createElement 的写法太累，想使用 JSX 语法，注意 JSX 最终还是会转换成 React.createElement 的形式去执行 安装1cnpm install @babel/preset-react -D 配置123456789101112&#123; test: /\.js$/, use: &#123; loader: 'babel-loader', options: &#123; presets: [ '@babel/preset-env', '@babel/preset-react' ], &#125; &#125;&#125; 1234// 也可以在 .babelrc 中进行配置&#123; "presets": ["@babel/preset-env", "@babel/preset-react"]&#125; 1234// 或者简写&#123; "presets": ["@babel/env", "@babel/react"]&#125; 使用123456import React from 'react';import ReactDOM from 'react-dom';ReactDOM.render(&lt;div&gt; hello world&lt;/div&gt;, document.querySelector('#root')); 以上代码 使用 jQuery安装1cnpm i jquery -S 使用123import $ from 'jquery';console.log($);console.log(window.$); // undefined 暴露给 window为什么要暴露给 window 呢？因为有一些第三方模块依赖的是全局 $，这时候就会出问题，例如 jQueryUI 依赖的就是 window.$ 1cnpm i expose-loader -D 1234// 注意 index.html 中需要 DOMContentLoaded 后才能拿到 $ 或 window.$let $ = require('expose-loader?$!jquery');console.log($);console.log(window.$); 也可以在 rules 中进行如下配置： 123456&#123; test: require.resolve('jquery'), use: 'expose-loader?$'&#125;// 后面只需下面写法import $ from 'jquery'; 全局变量不希望每个模块使用时都 import $ from ‘jquery’; 麻烦！ 1234567&#123; plugins: [ new webpack.ProvidePlugin(&#123; $: 'jquery' // $ 来自于 jquery 包，相当于 import $ from 'jquery'，每个模块中都注入了 $，并且 window 下也有，因为上面配置了 expose-loader &#125;) ]&#125; 123// 无需引用，直接使用，真好！console.log($);console.log(window.$); 使用 CDN1&lt;script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js"&gt;&lt;/script&gt; 123// 模块和 HTML 文件中都可以直接使用 $ 和 window.$ 了console.log($);console.log(window.$); 最后优化上面虽然模块中不引用也可以直接使用 $，但感觉怪怪的，并且使用 TS 时也通不过语法检查！我想引用后再使用，这样就解决了看起来奇怪和通不过 TS 语法检查的问题！ 但是又引来了一个新的问题，HTML 中以及 通过 CDN 引入 jQuery 了，模块中再次引入的话会被打包，这样就多了一套重复的代码！ 目的：JS 文件中引入第三方库但不想被打包！ 解决：配置 externals，它可以指定一个变量是外部（script）来的，不需要被打包 123456module.exports = &#123; externals: &#123; // 意思是这个 jquery 是外部提供的，别再给老子打包进去了 jquery: '$' &#125;&#125;; 123// 模块中随便用，不会被打包，美滋滋~import $ from 'jquery';console.log($, window.$); 以上代码 文件压缩注意在 production 模式下 build 文件，压缩功能才会生效！ JSWebpack4 中 production 模式会自动对 JS 文件进行压缩，再配合此插件如虎添翼！ 安装1cnpm i uglifyjs-webpack-plugin -D 配置12345678910optimization: &#123; minimizer: [ // 注意对 JS 的压缩需要在配置 babel 之后 new UglifyjsWebpackPlugin(&#123; cache: true, parallel: true, // 多线程打包 sourceMap: true // ES5 到 ES6 的映射方便调试 &#125;) ]&#125; CSSWebpack4 中 production 模式会自动对 JS 压缩不假，但并不会对 CSS 压缩 安装1cnpm i optimize-css-assets-webpack-plugin -D 配置1234567&#123; optimization: &#123; minimizer: [ new OptimizeCssAssetsWebpackPlugin() ] &#125;&#125; 打包资源分类 图片分类通过配置 outputPath 将其统一分配到对应目录 CSS 分类通过配置 plugins 中的 MiniCssExtractPlugin 通过配置 publicPath 可以在引用资源（例如CSS、Img）的时候会统一加上一个前缀 若只想给图片加前缀，也可以单独配置图片的 publicPath 打包多页应用多入口 JS 文件，利用 html-webpack-plugin 它也可以自动帮我们引入 JS，src 指定多入口时也同样会帮我们打包进去，打包成一个文件引入 多入口单出口1234567891011121314const path = require('path');module.exports = &#123; // 注意这里一个数组，最后会把代码合成一个 index.js entry: [ './src/test.js', './src/index.js' ], output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'index.js' // 合成 index.js &#125;, mode: 'development'&#125;; 多入口多出口1234567891011module.exports = &#123; // 注意这里是一个 JSON entry: &#123; test: './src/test.js', index: './src/index.js' &#125;, output: &#123; path: path.resolve(__dirname, 'dist'), filename: '[name].js' // 这里 name 是一个变量，会输出多个文件并引入到 index.html &#125;&#125;; 多入口多出口多文件1234567891011121314151617181920212223242526272829303132333435const path = require('path');const webpack = require('webpack');const HtmlWebpackPlugin = require('html-webpack-plugin');const htmlIndexPlugin = new HtmlWebpackPlugin(&#123; // 模板文件 template: path.join(__dirname, './src/index.html'), // 生成文件 filename: 'index.html', // 引入的 JS 文件 chunks: ['test', 'index']&#125;);const htmlTestPlugin = new HtmlWebpackPlugin(&#123; template: path.join(__dirname, './src/test.html'), filename: 'test.html', chunks: ['test']&#125;);module.exports = &#123; entry: &#123; test: './src/test.js', index: './src/index.js' &#125;, output: &#123; path: path.resolve(__dirname, 'dist'), filename: '[name].js' &#125;, plugins: [ new webpack.HotModuleReplacementPlugin(), htmlIndexPlugin, htmlTestPlugin ], mode: 'development'&#125;; 调试打包后的代码解析 JS 的过程中可能会把高级语法转成低级语法，也可能对代码进行压缩，配置 source-map（源码映射） 可以调试原味代码 devtool: ‘source-map’, 生成一个新的 sourcemap 文件，可以映射到列 devtool: ‘eval-source-map’, 在当前打包文件中生成，可以映射到列 devtool: ‘cheap-module-source-map’, 生成一个新的 sourcemap 文件，可以保留起来，不能调试 devtool: ‘cheap-module-eval-source-map’, 在同一文件中生成，不能映射到列 实时打包npx webpack –mode development 编译完就断开了，默认 watch: false，希望实时打包成实体文件 12345678watch: true,watchOptions: &#123; ignored: /node_modules/, // 每秒向文件询问的次数 poll: 1000, // 多少毫秒内重复保存不打包 aggregateTimeout: 500&#125; 用 webpack-dev-server 其实对上面已经处理了 版权声明12// 会在请求头加上代码信息new webpack.BannerPlugin('weixian') 拷贝静态文件例如文档，设计稿等 安装1npm i copy-webpack-plugin -D 配置1234new CopyWebpackPlugin([&#123; from: path.resolve(__dirname, &apos;src/assets&apos;), to: path.resolve(__dirname, &apos;dist/assets&apos;)&#125;]) 打包前先清空输出目录安装1npm i clean-webpack-plugin -D 配置1const &#123;CleanWebpackPlugin&#125; = require('clean-webpack-plugin'); 123plugins: [ new CleanWebpackPlugin()] 服务器代理场景一前端代码 123456// 8080 下的页面请求 3001 下的数据必然不行fetch('/api/user').then(res =&gt; &#123; return res.json();&#125;).then(data =&gt; &#123; console.log(data);&#125;); Webpack 配置 12345678910devServer: &#123; contentBase: './dist', port: 8080, host: 'localhost', proxy: &#123; // 如果请求 `localhost:8080/api/users` 开头的就会被代理到 `localhost:3001/api/users` // 自己定义个接口的特点，例如 call "/api": "http://localhost:3001" &#125;&#125; 服务端代码 1234567891011const express = require('express');const app = express();app.get('/api/user', (req, res) =&gt; &#123; res.send(&#123; name: 'ifer', age: 18 &#125;);&#125;);app.listen(3001); 场景二后端写接口的时候不可能都加上 /api 吧，太蛋疼了，需要路径的重命名！ 1234567891011121314151617devServer: &#123; // 生成静态文件根目录 contentBase: './dist', port: 8080, host: 'localhost', proxy: &#123; // 请求的 http://localhost:8080/api/users 映射到 http://localhost:3001/users // 如果请求的是 /api/users 把 /api 去掉 "/api": &#123; target: "http://localhost:3001", pathRewrite: &#123; // "^/api": "" "/api": "" &#125; &#125; &#125;&#125;, 后端只需 123456app.get('/user', (req, res) =&gt; &#123; res.send(&#123; name: 'test', age: 18 &#125;);&#125;); 场景三通过配置 Webpack 也可以实现简单的数据 Mock 123456789101112131415devServer: &#123; // 生成静态文件根目录 contentBase: './dist', port: 8080, host: 'localhost', // 钩子，启动服务之前做一些事情 before(app) &#123; app.get('/api/user', (req, res)=&gt; &#123; res.send(&#123; user: 'ifer', age: 18 &#125;); &#125;); &#125;&#125;, 一般使用的时候最好把 mock 数据独立成一个文件，例如： 12345678910const mock = require('./mock');devServer: &#123; // 生成静态文件根目录 contentBase: './dist', port: 8080, host: 'localhost', before(app) &#123; mock(app); &#125;&#125;, 123456789// mock.jsmodule.exports = function(app) &#123; app.get('/api/user', (req, res) =&gt; &#123; res.send(&#123; user: 'ifer', age: 18 &#125;); &#125;);&#125;; 场景四希望在已有的 Express 服务中集成 webpack，好处是方便利用 Express，不需要代理了，下次只需要启动一个服务（server.js）即可，webpack.config.js 的 devServer 最好不要再配置 proxy 了 1npm i webpack-dev-middleware -D 12345678910111213141516171819202122232425// express 虽然 package.json 中没有，webpack-dev-server 已经依赖了 ...const express = require('express');const morgan = require('morgan');const app = express();const webpack = require('webpack');/** * 1、webpack 中集成了 express(webpack-dev-server) * 2、express 中集成 webpack */const webpackDevMiddleware = require('webpack-dev-middleware');const webpackConfig = require('./webpack.config.js');const compiler = webpack(webpackConfig);app.use(webpackDevMiddleware(compiler));app.use(morgan('dev'));app.get('/user', (req, res) =&gt; &#123; res.send(&#123; name: "ifer", age: 17 &#125;);&#125;);app.listen(3001); 以上代码]]></content>
      <tags>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[再说事件绑定]]></title>
    <url>%2F2019%2F06%2F27%2FaddEventListener%2F</url>
    <content type="text"><![CDATA[大家都清楚，常用的事件绑定有两种形式，一种是传统绑定，例如 oBtn.onclick = fn; 还有一种是通过事件监听，例如 oBtn.addEventListener(&#39;click&#39;, fn, false); 两种绑定方式最大的差异我相信大家也比较清楚，就是传统方式给同一元素绑定多个事件处理程序时生效的是最后的那个（后面的覆盖前面的），事件监听的形式给同一元素绑定多个不同的事件处理程序时都会生效。但是在具体使用时用什么方式绑？绑定在谁身上（是点击的当前元素还是父元素）？什么时候绑（是点击的时候绑还是程序加载的时候绑）？都是你需要关注的细节，这里我举了一个例子来说明这三个问题！ 基本需求 需求：点击添加按钮，把 input 框中的内容放入新创建的 li，并给 li 中添加删除按钮可以删除当前行，最后把 li 添加到 ul 中，如上图 代码实现： 123&lt;input type="text"&gt;&lt;button&gt;添加&lt;/button&gt;&lt;ul style="width: 200px;"&gt;&lt;/ul&gt; 123456789101112131415161718192021222324252627var oInput = document.querySelector('input');var oBtn = document.querySelector('button');var oUl = document.querySelector('ul');oBtn.onclick = function() &#123; // 创建 li var oLi = document.createElement('li'); // 给 li 添加内容 oLi.innerHTML = oInput.value; // 添加 li 到 ul oUl.appendChild(oLi); // 创建删除按钮 span var oBtn = document.createElement('span'); // 添加文字 oBtn.innerHTML = '删除'; // 添加删除按钮到 li oLi.appendChild(oBtn); // 每次点击时选择所有按钮，并绑定点击事件做删除操作 var aBtn = document.querySelectorAll('span'); for(var i = 0; i &lt; aBtn.length; i ++) &#123; aBtn[i].onclick = function() &#123; oUl.removeChild(this.parentNode); &#125;; &#125;&#125;; 问题重现上面删除当前列表的功能，我们是用普通的事件绑定形式(onclick)去做的，没有什么问题。有同学尝试用事件监听的形式(addEventListener)改写代码如下： 123456var aBtn = document.querySelectorAll('span');for(var i = 0; i &lt; aBtn.length; i ++) &#123; aBtn[i].addEventListener('click', function() &#123; oUl.removeChild(this.parentNode); &#125;);&#125; 点击添加按钮，增加了 2 个或大于 2 个元素，此时再删除非最后一个列表时（非最后一个还是非第一个取决于是用 appendChild 还是 insertBefore 插入的），却发现出现了错误！打开控制台报错信息如下（删除了一个不是 oUl 子元素的节点）： 问题分析第 1 次点击按钮添加完成后，会通过 var aBtn = document.querySelectorAll(&#39;span&#39;); 选择所有的删除按钮，绑定事件 第 2 次点击添加按钮完成后，会通过 var aBtn = document.querySelectorAll(&#39;span&#39;); 选择所有的删除按钮，绑定事件。问题就出在这里，选择所有删除按钮并绑定事件的操作，其实又会把之前已经绑定事件的元素再次绑定了一次。所以点击删除按钮时会发现 oUl.removeChild(this.parentNode); 执行了多次（取决于重复绑定了多少次），第 1 次执行时已经把当前 li 从 ul 中移除，下次再执行 oUl.removeChild(this.parentNode); 时其实 ul 中已经没有了这个 li，删除一个不存在的子节点就会报错！ 第 3 次点击添加按钮完成后，同理… 解决方案Way1: 使用普通的事件绑定形式（onclick） Way2: 对于同样的事件处理程序独立出去变成同一个函数，每次保证绑定的是同一个（函数），例如： 123456789var aBtn = document.querySelectorAll('span');for(var i = 0; i &lt; aBtn.length; i ++) &#123; // aBtn[i].removeEventListener('click', rm); // 这里就没有必要进行先解绑了，因为每次绑定的是同一个 rm，会覆盖掉之前的 aBtn[i].addEventListener('click', rm);&#125;// 注意这里巧妙的用到了 e.target 查找当前点击的元素，不要试图通过传参的形式使用 this 查找当前元素！function rm(e) &#123; oUl.removeChild(e.target.parentNode);&#125; Way3: 其实前面每次添加列表就通过 querySelectorAll 重新选择所有删除按钮并绑定事件，本身就是一个糟糕的思路！其实只需要找到最新添加的那一个进行事件绑定就可以了，往前插入的话可以直接通过 var oBtn = document.querySelector(&#39;span&#39;); 找到最新添加的那个，往后插入的话代码如下： 1234var oBtn = document.querySelectorAll('span')[oUl.children.length-1];oBtn.addEventListener('click', function() &#123; oUl.removeChild(this.parentNode);&#125;); 除了上面通过元素选择的方式查找最新添加的那一个，最正确的方式其实是根本不用查找，它就在那里！每次添加列表的时候，当前创建的删除按钮就是最新的，直接给其绑定事件即可，这样无论是从效率，还是代码简洁度上都最佳，代码如下： 1234567var oBtn = document.createElement('span');// 给一个创建的元素单独绑定事件，而不是每次点击通过 querySelectorAll 选择的形式oBtn.addEventListener('click', function() &#123; oUl.removeChild(this.parentNode);&#125;);oBtn.innerHTML = '删除';oLi.appendChild(oBtn); Way4: 使用事件委托，推荐！ 1234567// 把事件绑定在父级上oUl.addEventListener('click', function(e) &#123; // 根据点击当前元素的名字（或其他）来判断是否是 span（即删除按钮），然后做相应的操作 if(e.target.nodeName.toLowerCase() === 'span') &#123; e.currentTarget.removeChild(e.target.parentNode); &#125;&#125;);]]></content>
      <categories>
        <category>Web API</category>
      </categories>
      <tags>
        <tag>addEventListener</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于数组塌陷]]></title>
    <url>%2F2019%2F06%2F23%2Fsplice%2F</url>
    <content type="text"><![CDATA[关于数组的方法有很多，splice 算是比较强大的一个，它能用来删除、添加、替换数组中的元素，实际开发中非常实用！ 基本语法123456// start: 从哪里开始，也支持负值，-n 相当于 arr.length - n// deleteCount: 要删除几个（可选）// item1, item2: 要添加进数组的元素（可选）// 返回值: 以数组的形式返回删除的那些元素array.splice(start, deleteCount, item1, item2); 代码演练删除：从第 2 位开始，删除 2 个 123var arr = ['apple', 'orange', 'banana', 'watermelon'];arr.splice(2, 2);console.log(arr); // ['apple', 'orange'] 添加：从第 2 位开始，删除 0 个，添加 🤣😎 123var arr = ['apple', 'orange', 'banana', 'watermelon'];arr.splice(2, 0, '🤣', '😎');console.log(arr); // ["apple", "orange", "🤣", "😎", "banana", "watermelon"] 替换：从第 2 项开始，删除 2 项并添加🍌和🍉 123var arr = ['apple', 'orange', 'banana', 'watermelon'];arr.splice(2, 2, '🍌', '🍉');console.log(arr); // ["apple", "orange", "🍌", "🍉"] 数组塌陷需求：利用 splice 删除数组中的指定元素 1234var arr = ['apple', 'orange', 'banana', 'watermelon'];// 从 0 开始删到最后，并不能指定删除某个元素arr.splice(0);console.log(arr); // [] 1234567// 删除指定的某个元素时就需要遍历，但最终的结果和我们想的不一样！var arr = ['apple', 'orange', 'banana', 'watermelon'];for(var i = 0; i &lt; arr.length; i ++) &#123; // 从第 i 个开始，删除 1 个 arr.splice(i, 1);&#125;console.log(arr); // ["orange", "watermelon"] 上面的写法删不干净，因为 splice 每删除一个元素就会改变原来数组的索引以及长度，而 i 的值永远是个递增的状态，代码分析如下（建议断点调试）： 第 1 次 i 等于 0， arr.splice(0, 1) 后的结果是 [‘orange’, ‘banana’, ‘watermelon’]，arr 的 length 变为了 3； 第 2 次 i 等于 1，arr.splice(1, 1) 后的结果是 [‘orange’, ‘watermelon’]，arr 的 length 变为了 2； 第 3 次 i 等于 2， i &lt; arr.length 条件为假，结束循环； 解决方法需求：解决上面利用 splice 删除不干净的问题！ 每次删除数组的第一个元素 1234567var arr = ['apple', 'orange', 'banana', 'watermelon'];for(var i = 0; i &lt; arr.length; i ++) &#123; arr.splice(i, 1); // 每次删除后进行 i--，这样就能保证删除的永远都是数组的第一个元素（说第一个元素不太准确，取决于i的值变化到哪里了） i --;&#125;console.log(arr); // [] 1234// 原理和上面一样，永远删除数组最前面那个元素while(arr.length) &#123; arr.splice(0, 1);&#125; 倒着删 123456// 可以通过断点调试查看代码执行过程var arr = ['apple', 'orange', 'banana', 'watermelon'];for(var i = arr.length - 1; i &gt;= 0; i --) &#123; arr.splice(i, 1);&#125;console.log(arr); 使用场景数组去重：每次用当前元素和后面的所有元素进行比较，如果相同就利用 splice 删除掉后面相同的那个元素 j（或当前的 i） 12345678910var arr = ['apple', 'apple', 'apple', 'orange', 'apple'];for(var i = 0; i &lt; arr.length; i ++) &#123; for(var j = i + 1; j &lt; arr.length; j ++) &#123; if(arr[i] === arr[j]) &#123; arr.splice(j, 1); // 解决 splice 后带来的数组塌陷问题 j --; &#125; &#125;&#125; 题目测试需求：在数组 var arr = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]; 每一项的前面添加 @ 字符 123456// Way1for(var i = arr.length - 1; i &gt;= 0; i --) &#123; arr.splice(i, 0, '@');&#125;console.log(arr); // ["@", "a", "@", "b", "@", "c", "@", "d"] 12345678// Way2for(var i = 0; i &lt; arr.length; i ++) &#123; arr.splice(i, 0, '@'); // ['@', 'a', 'b', 'c', 'd'] 下次 'b' 的索引已经是 2 了，需要再次进行 i++ i++;&#125;console.log(arr); // ["@", "a", "@", "b", "@", "c", "@", "d"] 1234567// Way3for(var i = 0; i &lt; arr.length; i ++) &#123; arr.splice(i, 1, '@'+arr[i]);&#125;arr = arr.join('').split('');console.log(arr); // ["@", "a", "@", "b", "@", "c", "@", "d"] 其他方法用 splice 删除指定元素的目的，换句话说无非是想得到想要的元素，其实数组也提供了 filter 方法，可以帮我们筛选出想要的数组元素！ 12345// 具体使用看文档，这里不再啰嗦了！var arr = ['apple', 'orange', 'banana', 'watermelon'];// 返回一个新的、由通过测试的元素组成的新数组var newArr = arr.filter(word =&gt; !word);console.log(newArr); // []]]></content>
      <categories>
        <category>JS 基础</category>
      </categories>
      <tags>
        <tag>数组塌陷</tag>
        <tag>splice</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[标记语句]]></title>
    <url>%2F2019%2F06%2F21%2Fjs-label%2F</url>
    <content type="text"><![CDATA[之前课上做过一个计算器的案例，选择 1、2、3、4 后会对后面填入的数字进行对应的运算并弹出结果，点击确定后又会回到初始界面。如果用户在初始界面输入的是数字 5，点击确定就会进行退出操作，不再回到初始界面了！ 可实现代码如下： 123456789101112131415161718192021222324252627282930313233343536373839// 输入内容并返回function inputValue() &#123; var num1 = parseFloat(prompt('请输入第一个数：')); var num2 = parseFloat(prompt('请输入第二个数：')); return [num1, num2];&#125;// 相当于创建了一个开关，默认开启状态var bBar = true;do &#123; var opration = prompt('请选择要进行的运算：\n1. 加法运算\n2. 减法运算\n3. 乘法运算\n4. 除法运算\n5. 退出'); opration = parseInt(opration); switch (opration) &#123; case 1: var arr = inputValue(); alert('相加的结果是：' + (arr[0] + arr[1])); break; case 2: var arr = inputValue(); alert('相减的结果是：' + (arr[0] - arr[1])); break; case 3: var arr = inputValue(); alert('相乘的结果是：' + (arr[0] * arr[1])); break; case 4: var arr = inputValue(); alert('相除的结果是：' + (arr[0] / arr[1])); break; case 5: alert('退出...'); // 如果用户输入的是 5，则关闭开关，那下次的循环 bBar 就是 false，while(bBar) 也就不会执行了 bBar = false; // 默认只会退出当前的 switch break; &#125;&#125; while (bBar); 其实上面退出循环的操作也可以使用标记语句来完成，感兴趣的同学可以点击链接进去学习下，修改后的代码如下： 123456789101112// Step1: 指定标记点loopPoint:do &#123; // ... switch (opration) &#123; // ... case 5: alert('退出...'); // Step2: 跳到标记点 break loopPoint; &#125;&#125; while (true); 下面是测试代码： 1234567891011121314var num = 0;for (var i = 0; i &lt; 6; i++) &#123; for (var j = 0; j &lt; 6; j++) &#123; // 当 i 等于 3 并且 j 等于 3 时，会直接 break 里面一层的 for 循环，继续外面的 for 循环 // 当 i 等于 3 时，导致 j 值为 [3,6) 之间的没有进行，num 少加了 3 次 // 所以最终的 num 值为 33 if (i == 3 &amp;&amp; j == 3) &#123; // 跳出当前循环 break; &#125; num++; &#125;&#125;console.log(num); // 打印结果是多少？ 1234567891011121314151617var num = 0;outerMark:for (var i = 0; i &lt; 6; i++) &#123; // 外层 for 循环，i 等于 0 时，里层执行完 6 次 // 外层 for 循环，i 等于 1 时，里层执行完 6 次 // 外层 for 循环，i 等于 2 时，里层执行完 6 次 // 外层 for 循环，i 等于 3 时，里层循环 j 执行了 3 次 [0, 3) // 最终的 num 值是 21 for (var j = 0; j &lt; 6; j++) &#123; if (i == 3 &amp;&amp; j == 3) &#123; // 跳出到 outerMark 标记的地方 break outerMark; &#125; num++; &#125;&#125;console.log(num); // 打印结果是多少？ 123456789101112var num = 0;outerMark:for (var i = 0; i &lt; 6; i++) &#123; for (var j = 0; j &lt; 6; j++) &#123; if (i == 3 &amp;&amp; j == 3) &#123; // 跳出外层的当前循环，继续下次 i++ continue outerMark; &#125; num++; &#125;&#125;console.log(num); // 打印结果是多少？]]></content>
      <categories>
        <category>JS 基础</category>
      </categories>
      <tags>
        <tag>标记语句</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端布局那点事]]></title>
    <url>%2F2019%2F06%2F07%2Fmobile-layout%2F</url>
    <content type="text"><![CDATA[作为前端，在今天来说，移动端布局必须是一件必知必会的事情，重要程度不言而喻！这里我总结了同一案例下不同布局的写法（原理就不再赘述，直接右键查看源代码即可），方便大家回忆。 百分比布局特点：宽度百分比、高度写死（750的设计稿下一般除以2）。缺点：高度或文字很难自适应。 举例 Flexible 布局特点：宽度弹性布局、高度写死。缺点：高度或文字还是很难自适应。优点：灵活、简洁。 举例 REM 布局原理：不同尺寸屏幕下给根元素设置不同的文字大小（利用媒体查询或JS），宽、高、间距…都统一使用 REM 单位。使用：量取到的设计稿尺寸除以根元素字体大小（基准值）即可，例如使用 flexible.js，150px 用 rem 表示就是 2rem。优点：高度和文字可以自适应。 注意 em 是相对于当前元素的字体大小（如果当前元素没有设置字体大小那就是继承过来的大小）的单位。 举例 响应式布局原理：利用 bootstrap 的栅格系统（核心还是媒体查询），不同尺寸下设置不同的样式，实现 PC 和移动端布局使用同一套代码！场景：适用于相对简单的页面，复杂页面下的响应式开发成本太高。]]></content>
      <categories>
        <category>移动 Web 开发</category>
      </categories>
      <tags>
        <tag>移动端布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[steps(number[, end | start])]]></title>
    <url>%2F2019%2F05%2F31%2Fsteps%2F</url>
    <content type="text"><![CDATA[缘起CSS3 中用于设置动画的 animation 语法如下： 1animation: name duration timing-function delay iteration-count direction; 其中，timing-function 取值如下： 1timing-function: linear / ease / ease-in / ease-out / ease-in-out / cubic-bezier() / steps() 上面 timing-function 的取值除了 steps() 都代表补间动画（线性动画），steps() 代表帧动画，有时候一些动画效果必须用它才能实现，例如上面图奔跑的动物是我们曾经做过的动画，就是通过 steps() 配合改变雪碧图（1600px宽）的位置实现的，代码如下： 12345678@keyframes aniSelf &#123; 0% &#123; background-position: 0 0; &#125; 100% &#123; background-position: -1600px 0; &#125;&#125; 123.wolf&#123; animation: aniSelf 1s steps(8) infinite;&#125; 上面代码确实能实现预期的效果，但不知道大家有没有这样一个疑问：当背景位置为 background-position: -1600px 0; 时，图片在盒子中应该是看不到的才对（因为图片总共是1600px，这样刚好是图片的最右边卡到盒子的最左边），但为什么动画还能正常跑起来，而没有出现空白的问题呢？ 要解答上面的疑问，我们就要明白关于 steps(number[, end | start]) 参数的含义，第一个参数大家都知道是什么意思，第二个参数是可选的，表示在每个间隔的起点或是终点发生阶跃变化，如果忽略，默认是 end。 看完上面加粗部分的定义，我不知道你作何感想…😣 我的感性认识我的理解：steps() 第二个参数如果是 end 则代表忽略结束帧，如果是 start 则代表忽略开始帧，如何理解这句话呢？ 上面是一张 50 * 200 的图片，作为 50 * 50 盒子的背景图，我想实现在 hover 盒子的时候背景从 A 变化到 A 的逐帧动画。由于我们知道 steps(4, end) 时会忽略最后一帧，动画走完时没有 forwards，又会回到初始状态，故可以用以下方法来实现： 1234567891011121314151617181920.box &#123; border: 1px solid #333; width: 50px; height: 50px; background: url(./images/steps.png) no-repeat;&#125;.box:hover &#123; /* 分为 4 步来完成，会忽略最后一步 background-position: 0 -150px; 到 background-position: 0 -200px; 这个区间！ */ animation: way1 2s steps(4);&#125;@keyframes way1 &#123; 0% &#123; background-position: 0 0; &#125; 100% &#123; background-position: 0 -200px; &#125;&#125; 上面代码其实就是和我们课上实现动物运动的代码是一样的思路，那如果我把上面的代码改为 steps(4, start) 会怎样的，根据我们之前的结论，start 会忽略第一帧，也就是 hover 上的一刹那就会定位到 B，然后也会走 background-position: 0 -150px; 到 background-position: 0 -200px; 最后一帧这个区间，即会出现空白，最后又回到初始状态 A，可见，这并不是我们所需要的。 我就想用 start如果实在想用 start 可以改写代码如下： 1234567891011121314/* Step1: 分为 3 步走 */.box:hover &#123; animation: way1 2s steps(3, start);&#125;/* Step2: 最后一帧的位置改成严丝合缝的最后一样图片 */@keyframes way1 &#123; 0% &#123; background-position: 0 0; &#125; 100% &#123; background-position: 0 -150px; &#125;&#125; 注意：以上代码虽然能实现 hover 时背景从 A、B、C、D 到 A 的变换，但并不推荐这样做，因为 hover 的一刹那 A 到 B 的变换是没有动画的（逐帧动画也是动画） 其他写法注意看我的注释部分！ 123456789101112131415161718192021.box &#123; border: 1px solid #333; width: 50px; height: 50px; /* Step1: 背景重复！ */ background: url(./images/steps.png) repeat-y;&#125;.box:hover &#123; /* Step2: 这时候 steps 第二个参数是 start or end 只是开始时第一帧有没有动画的区别，并不会出现空白了，因为背景平铺了 */ animation: way1 2s steps(4);&#125;@keyframes way1 &#123; 0% &#123; background-position: 0 0; /* A */ &#125; 100% &#123; background-position: 0 -200px; /* A */ &#125;&#125; 123456789/* 设置是这样的写法 */@keyframes way1 &#123; 0% &#123; background-position: 0 200px; /* A */ &#125; 100% &#123; background-position: 0 0px; /* A */ &#125;&#125; 其他属性对 step 的影响当 steps() 第二个参数为 end 时会忽略结束帧，但 animation-fill-mode: forwards; 是会影响 steps() 的表现的，例如我想让一个盒子从 0 运动到 100，可写代码如下： 12345678910111213141516.box&#123; width: 100px; height: 100px; background-color: pink; position: absolute; top: 70px; animation: move 3s steps(5) forwards;&#125;@keyframes move &#123; 0%&#123; left: 0; &#125; 100%&#123; left: 100px; &#125;&#125; 结果如下： 说好的 steps() 第二个参数为 end 时会忽略最后一帧，但最后却停在了 100px 的位置上，说明 animation-fill-mode 为 forwards 时会对 steps() 帧动画造成影响，以 forwards 为准！当然你如果又设置了 infinite，那 forwards 也就“失效”了… 再来个小栗子点我去远方]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>steps()</tag>
        <tag>帧动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据类型检测的 N 中方式]]></title>
    <url>%2F2019%2F05%2F26%2Fjudge-type%2F</url>
    <content type="text"><![CDATA[从 JS 基础第一天开始，我们就学习了如何使用 typeof 去判断数据类型，学习构造函数时我们又说了 constructor 以及 instanceof 也可以去进行类型检测，到 JS 高级时还讲了 Object.prototype.toString() 方法也可以去判断数据类型，那么问题来了，这么多方法它们之间有什么异同吗？不同场景下该怎样使用才比较合适呢？ 数据类型知多少既然要检测数据类型，首先要明确 JS 中的数据类型有以下 7 种： 简单数据类型：Number、String、Boolean、Null、Undefined、Symbol（ES6） 复杂数据类型：Object（包括函数、数组、对象、正则、日期等） typeoftypeof 它的使用方法有两种： 1234// 可以不带括号，直接跟数据console.log(typeof 36);// 也可以带括号console.log(typeof(36)); typeof 的返回值永远是一个全小写字符串，例如： 1console.log(typeof (typeof (typeof 66))); // string typeof 的返回值除了上面 7 种数据类型外，还多了一个 function，例如： 12function test() &#123;&#125;console.log(typeof test); // function 总结： 除了 Null（返回 object），typeof 对于基本数据类型都能返回正确的结果 除了 Function（返回 function），typeof 对于复杂数据类型都返回 object 缺点： typeof 对于复杂数据类型的处理，只能返回处于原型链最顶端的 Object 类型，不能细分 constructor新建一个（构造）函数 Fn 时，JS 引擎会给自 Fn 添加一个 prototype 属性，prototype 下又有一个 constructor 指向 Fn 函数，可用如下代码表示： 12function Fn() &#123;&#125;console.log(Fn.prototype.constructor === Fn); // true 当我们执行 new Fn 来创建 Fn 的实例后，这个实例的 constructor 也就指向 Fn，如下： 1234function Fn() &#123;&#125;var f1 = new Fn;// f1 下本没有 constructor，自己没有则会通过原型链向上查找到 Fn.prototype 上console.log(f1.constructor === Fn); // true 如此一来我们就可以通过 constructor 来判断某个实例对象具体的类型（来源），例如上面代码从原型链的角度来说 f1 的类型（来源）就是 Fn。 同样的道理，其他数据的也可以通过 constructor 来判断具体的类型，它可以解决 typeof 对应复杂数据类型的判断无能为力的问题，测试如下： 1234567console.log([].constructor === Array); // trueconsole.log(new Date().constructor === Date); // trueconsole.log(new Function().constructor === Function);console.log(''.constructor === String);console.log(true.constructor === Boolean);console.log(new Error().constructor === Error);console.log(document.constructor === HTMLDocument); constructor 的小问题： null 和 undefined 上没有 constructor 这属性，不能通过 constructor 来判断 当 prototype 被不小心重写后，会导致 constructor 判断不准确的问题，例如： 1234567891011function Test() &#123;&#125;var t1 = new Test;console.log(t1.constructor === Test); // true// 重写原型会导致 Test.prototype.constructor 指向不正确// 当然对应的实例对象在用 constructor 去判断类型的时候也就会指向不正确Test.prototype = &#123; showAge: function() &#123;&#125;&#125;;var t2 = new Test();console.log(t2.constructor === Test); // false instanceof它主要用来判断一个对象是否能够通过原型链找到另一个对象的原型，什么意思呢？例如： 12// [] 可以通过 __proto__ 找到 Array.prototype，所以结果是 trueconsole.log([] instanceof Array); 123// [].__proto__.__proto__ === Object.prototype// 说明 [] 也是可以通过原型链找过 Object 的原型，所以下面结果也是 trueconsole.log([] instanceof Object); 所以大家也看到了，instanceof 并不能准确的找到某个实例的类型，但它相对于 constructor 有这样一个特点，即便构造函数的原型被重写后，实例也能通过 instanceof 去判断自己的类型，例如： 1234567function Test() &#123;&#125;Test.prototype = &#123; showAge: function() &#123;&#125;&#125;;var t1 = new Test();console.log(t1 instanceof Test); // trueconsole.log(t1 instanceof Object); // 当然对应顶级对象 Object 也是 true，还是不能准确判断就是 Test 类型 instanceof 还有另外一个问题需要你注意的，当页面中引入 iframe 时，实例化 iframe 窗口下的对象和当前窗口下相对应的构造函数进行 instanceof 判断时也会出现问题。例如： 1234567891011var oFrame = document.createElement('iframe');document.body.appendChild(oFrame);// ifame 窗口下实例化的 arrvar arr = new window.frames[0].Array;console.log(arr instanceof window.frames[0].Array); // trueconsole.log(arr instanceof Array); // false// 针对上面的问题 ES5 提供了 Array.isArray() 这个方法进行判断console.log(Array.isArray(arr)); // true Object.prototype.toString他返回的信息格式是 [object Xxx]（注意第一个 X 是大写），对于 {} 直接调用 toString 既可以返回 [object Object]，其他类型需要借助 call/apply 方法去调用，例如： 12345678910111213// 也可以把 Object.prototype 替换成 &#123;&#125;// 因为调用 &#123;&#125; 下的 toString() 方法，自己没有会通过原型链去 Object.prototype 上面找console.log(Object.prototype.toString.call(233)); // [object Number]console.log(Object.prototype.toString.call('233')); // [object String]console.log(Object.prototype.toString.call(true)); // [object Boolean]console.log(Object.prototype.toString.call(null)); // [object Null]console.log(Object.prototype.toString.call(undefined)); // [object Undefined]console.log(Object.prototype.toString.call(Symbol())); // [object Symbol]console.log(Object.prototype.toString.call([])); // [object Array]console.log(Object.prototype.toString.call(new Function)); // [object Function]console.log(Object.prototype.toString.call(new Date)); // [object Date]console.log(Object.prototype.toString.call(new RegExp)); // [object RegExp] 可见 Object.prototype.toString() 简直太好用啦，推荐使用！]]></content>
      <categories>
        <category>JS 高级</category>
      </categories>
      <tags>
        <tag>判断数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据在内存中的存储形式]]></title>
    <url>%2F2019%2F05%2F25%2Fsnake-question%2F</url>
    <content type="text"><![CDATA[学习贪吃蛇时，往蛇身体增加最后一节，当时代码是直接这样写的 this.body.push({ x: last.x, y: last.y, color: last.color })，有些同学问 last 这个变量保存的数据和 { x: last.x, y: last.y, color: last.color } “长的一样”，为什么不能直接 this.body.push(last) 呢？ 基本数据类型存储要说清楚上面的问题，首先大家要明白不同数据类型在内存中的存储形式是怎样的。我们都知道 JS 中的数据类型分为 2 大类，分别是： 基本数据类型：Number、String、Boolean、Null、Undefined、Symbol(ES6) 复杂数据类型：Object(包括数组、对象、函数、正则) 其中基本数据类型存储在栈内存中，他们是按值存放的，例如： 1234var age1 = 18;var age2 = age1;age2 = 20;console.log(age1, age2); // 18 20 上面代码在内存中的表现形式如下： 复杂数据类型存储复杂数据类型的真实数据是存放在堆内存中的，变量保存的只是在栈内存中的一个地址，这个地址指向堆内存中数据。例如： 1234var obj1 = &#123; age: 18 &#125;;var obj2 = obj1;obj2.age = 20; // obj2 是改变堆内存中的同一份数据console.log(obj1.age); // 所以 obj1 的数据也被影响了，结果是 20 上面代码在内存中的表现形式如下： 解释贪吃蛇的问题讲贪吃蛇时，关于蛇如何吃到食物我们说了这么一段话：在蛇运动时，判断蛇头的坐标是否与食物的坐标吻合，如果吻合，则往蛇身体后增加一节，然后再随机食物的坐标即可，代码如下： 12345678if (headX === food.x &amp;&amp; headY === food.y) &#123; // Step1: 获取蛇的最后一节 var last = this.body[this.body.length - 1]; // Step2: 添加到身体的最后 this.body.push(&#123; x: last.x, y: last.y, color: last.color &#125;); // Step3: 随机随机食物坐标 food.render(map);&#125; 如果直接 this.body.push(last) 的话，相当于每次添加的还是堆内存中的同一个 last，那在下次 move 修改数据的时候就会相互影响，无论你往后面 push 多少项 last，在修改到最前面的 three 时也会把后面的给修改掉（因为都是堆内存中的同一份数据），所以你看到的结果是后面的数据都是重复的，对应到页面上也就是最后一节的元素都是覆盖在一起的。测试代码如下： 12345678910var one = &#123;x: 26, y: 14, color: "red"&#125;;var two = &#123;x: 25, y: 14, color: "blue"&#125;;var three = &#123;x: 24, y: 14, color: "blue"&#125;;var arr = [one, two, three, three];for (var i = arr.length - 1; i &gt; 0; i--) &#123; arr[i].x = arr[i - 1].x; arr[i].y = arr[i - 1].y;&#125;console.log(arr); 该如何解决12345678910111213141516171819var arr = [ &#123;x: 26, y: 14, color: "red"&#125;, &#123;x: 25, y: 14, color: "blue"&#125;, &#123;x: 24, y: 14, color: "blue"&#125;];var last = arr[arr.length - 1];// 每次造一个全新的对象var newObj = &#123; x: last.x, y: last.y, color: last.color &#125;;// 或者拷贝原来的对象// var newObj = JSON.parse(JSON.stringify(last));arr.push(newObj);for (var i = arr.length - 1; i &gt; 0; i--) &#123; arr[i].x = arr[i - 1].x; arr[i].y = arr[i - 1].y;&#125;console.log(arr);]]></content>
      <categories>
        <category>JS 高级</category>
      </categories>
      <tags>
        <tag>贪吃蛇</tag>
        <tag>引用类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS 中的隐式转换]]></title>
    <url>%2F2019%2F05%2F24%2Finvisible-transform%2F</url>
    <content type="text"><![CDATA[JS 中有个“经典”的面试题：请问 [] == ![] 的结果是什么？一眼看上去肯定是 false，但结果却是 true，要清楚为什么是这样，就要了解 JS 在进行数据比较时的隐式转换规则是怎样的？ 注：除了对本问题的解释部分，其他都来自 JavaScript 高级程序设计，建议看书！我这里摘出了其中两点，来作为对常见问题的解释，其实还有其他细节或特殊注意的地方，建议在精力充沛的情况下可以自己去探索！ 相等操作符规则在转换不同的数据类型时，相等和不相等操作符遵循下列基本规则： 1 . 如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值，false 转换为 0，而 true 转换为 12 . 如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值3 . 如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf()方法，用得到的基本类型值按照前面的规则进行比较 这两个操作符在进行比较时又要遵循下列特殊的情况： 1 . null 和 undefined 是相等的2 . 要比较相等性之前，不能将 null 和 undefined 转换成其他任何值3 . 如果有一个操作数是 NaN，则相等操作符返回 false，而不相等操作符返回 true。重要提示：即使两个操作数都是 NaN，相等操作符也返回 false；因为按照规则，NaN 不等于 NaN4 . 如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回 true；否则，返回 false 关系操作符规则当关系操作符的操作数使用了非数值时，也要进行数据转换或完成某些奇怪的操作。以下就是相应的规则： 1 . 如果两个操作数都是数值，则执行数值比较2 . 如果两个操作数都是字符串，则比较两个字符串对应的字符编码值3 . 如果一个操作数是数值，则将另一个操作数转换为一个数值，然后执行数值比较4 . 如果一个操作数是对象，则调用这个对象的 valueOf()方法，用得到的结果按照前面的规则执行比较。如果对象没有 valueOf()方法，则调用 toString()方法，并用得到的结果根据前面的规则执行比较5 . 如果一个操作数是布尔值，则先将其转换为数值，然后再执行比较 解释 [] == ![]1[] == ![] Step1: ! 的优先级比 == 高，先执行 ![]，除了 null、undefined、’’、NaN、0 都是 true，所以 ![] 是 false 1[] == false Step2: 参考相等操作符比较的第 1 条规则，如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值，故结果如下： 1[] == 0 Step3: 参考相等操作符比较的第 3 条规则，调用对象的 valueOf() 方法得到原始值，并将原始值转换为数字结果如下： 1Number([].valueOf()) == 0]]></content>
      <categories>
        <category>JS 基础</category>
      </categories>
      <tags>
        <tag>隐式转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[触发全选按钮的几种思路]]></title>
    <url>%2F2019%2F05%2F22%2Fselect-all%2F</url>
    <content type="text"><![CDATA[需求：点击全选，选中上面所有的列表项；点击列表项中的每一个水果，如果有未选中则取消全选按钮，如果都选中了则激活全选按钮。 常规操作点击每个列表选项时，遍历所有列表选项并检查是否有未选中的，如果有则可以确定全选按钮的状态为未选中，否则全选按钮置为选中。 1234567891011121314151617181920212223242526272829303132var oAllInput = document.querySelector('#all');var aInput = document.querySelectorAll('ul input');// 点击全选 input 时根据自己的状态来控制其他列表项的 inputoAllInput.onchange = function() &#123; for(var i = 0; i &lt; aInput.length; i ++) &#123; aInput[i].checked = this.checked; &#125;&#125;;// 每次点击每一个列表项的 input 时，判断全选的 input 是否需要被选中for(var i = 0; i &lt; aInput.length; i ++) &#123; aInput[i].onclick = function() &#123; if (!this.checked) &#123; // 如果当前点击的按钮未选中，那就可以直接确定全选按钮的状态了 oAllInput.checked = false; // 也就没有必要进行下去了 return; &#125; var bBar = true; for(var i = 0; i &lt; aInput.length; i ++) &#123; // 发现有一个没选中的 if(!aInput[i].checked) &#123; bBar = false; // 发现有一个没选中的也就可以断定 oAllInput 的状态了，就没有必要再进行下去了 // 当然你不写 break 逻辑上也是对的，只是存在性能浪费 break; &#125; &#125; oAllInput.checked = bBar; &#125;;&#125; 注意细节思路和上面一样，下面的写法也是可以的，但有一点需要注意：点击列表中的每一项进行循环时，碰到未选中的一定要跳出循环，不然前面全选按钮的状态都会被最后一个按钮的状态所覆盖。 12345678910111213141516171819for (var i = 0; i &lt; aInput.length; i++) &#123; aInput[i].onclick = function () &#123; if (!this.checked) &#123; // 如果当前点击的按钮未选中，那就可以直接确定全选按钮的状态了 oAllInput.checked = false; // 也就没有必要进行下去了 return; &#125; for (var i = 0; i &lt; aInput.length; i++) &#123; if (!aInput[i].checked) &#123; oAllInput.checked = false; // 这里的 break 是必须要加的！不然全选按钮的状态永远是以最后一个的选中状态为准，这并不是我们所希望的 break; &#125; else &#123; oAllInput.checked = true; &#125; &#125; &#125;;&#125; 其他方法每次点击列表中的按钮时，获取所有已选中 input 的长度，并判断已选中 input 的 length 是否等于所有 input 的 length，如果相等，就可以激活全选按钮啦，否则则取消全选。 1234567891011for (var i = 0; i &lt; aInput.length; i++) &#123; aInput[i].onclick = function () &#123; var aInputChecked = document.querySelectorAll('ul input:checked'); // 已选中 length 等于所有 length 就证明全选中了，也就可以激活全选按钮啦 if (aInputChecked.length === aInput.length) &#123; oAllInput.checked = true; &#125; else &#123; oAllInput.checked = false; &#125; &#125;;&#125;]]></content>
      <categories>
        <category>Web API</category>
      </categories>
      <tags>
        <tag>全选</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排他思想]]></title>
    <url>%2F2019%2F05%2F21%2Fkill-other%2F</url>
    <content type="text"><![CDATA[上课我们在做点击当前按钮高亮，其他按钮重置为默认颜色的需求时，用到了“排他思想”，思路是：第一步，先干掉所有的；第二步，再操作自己的，简单明了，相信大家都比较清楚了！这里我再给大家做个总结，顺便再拓展一下其他的实现思路 ~ 排完思想需求：有 5 个按钮，点击当前按钮变红，其他按钮恢复默认颜色 123456&lt;!-- HTML 结构 --&gt;&lt;button&gt;1&lt;/button&gt;&lt;button&gt;2&lt;/button&gt;&lt;button&gt;3&lt;/button&gt;&lt;button&gt;4&lt;/button&gt;&lt;button&gt;5&lt;/button&gt; 123456789101112var aBtn = document.querySelectorAll('button');for(var i = 0; i &lt; aBtn.length; i ++) &#123; aBtn[i].onclick = function() &#123; // Step1: 先干掉所有人，“排完” for(var i = 0; i &lt; aBtn.length; i ++) &#123; aBtn[i].style.backgroundColor = ''; &#125; // Step2: 再操作自己的 this.style.backgroundColor = 'red'; &#125;;&#125; 排兄思想1234567&lt;script src="https://cdn.bootcss.com/jquery/3.4.0/jquery.min.js"&gt;&lt;/script&gt;&lt;script&gt;$("button").on("click", function() &#123; // 先操作自己的，再干掉所有的兄弟，“排兄” $(this).css("background", "red").siblings().css("background", "");&#125;);&lt;/script&gt; 排上思想1234567891011121314var aBtn = document.querySelectorAll('button');var prev = 0;for (var i = 0; i &lt; aBtn.length; i++) &#123; aBtn[i].index = i; aBtn[i].onclick = function () &#123; // Step1: 先干掉上一个，“排上” aBtn[prev].style.backgroundColor = ""; // Step2: 再操作自己的 this.style.backgroundColor = 'red'; // Step3: 操作完别忘了把自己也变成“上一个” prev = this.index; &#125;;&#125;]]></content>
      <categories>
        <category>Web API</category>
      </categories>
      <tags>
        <tag>排他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[认清 Node.appendChild()]]></title>
    <url>%2F2019%2F05%2F19%2FappendChild%2F</url>
    <content type="text"><![CDATA[Node.appendChild() 方法用于将一个节点添加到指定父节点的子节点列表的末尾，但在具体使用时还有其他一些需要我们关注的细节，以及对应的应用场景。 常规操作大家都清楚 appendChild 可以把创建好的元素插入到另一个元素内容的最后面，常规操作如下： 123456// 创建元素var oDiv = document.createElement('div');// 给创建好的元素加点内容oDiv.innerHTML = 'hello world';// 添加到 body 里面document.body.appendChild(oDiv); 需要注意上面代码必然没有任何问题，但这里还有一点需要大家注意的是，appendChild 在插入已存在元素的时候其实是做了两件事的： 先把原来已存在的元素删除 再进行后续的添加操作 具体是什么意思呢？大家看下面的例子就清楚了。需求：每次点击按钮把上面 ul 中的第一个元素移动到下面的 ul 中： 1234567891011121314151617181920&lt;ul id="ul1"&gt; &lt;li&gt;aaa&lt;/li&gt; &lt;li&gt;bbb&lt;/li&gt; &lt;li&gt;ccc&lt;/li&gt; &lt;li&gt;ddd&lt;/li&gt;&lt;/ul&gt;&lt;button id="btn"&gt;插入下面&lt;/button&gt;&lt;ul id="ul2"&gt;&lt;/ul&gt;&lt;script&gt;// 选择元素var oUl1 = document.querySelector('#ul1');var oBtn = document.querySelector('#btn');var oUl2 = document.querySelector('#ul2');oBtn.onclick = function() &#123; var oLi = oUl1.children[0]; // 每次点击按钮确实在 oUl2 中添加了一个新的元素，但同时 oUl1 中也相应少了这个元素 // 所以 appendChild 时相当于偷偷帮我们做了这么一步操作：oUl1.removeChild(oLi); oUl2.appendChild(oLi);&#125;;&lt;/script&gt; 实际应用好，现在我们清楚了当用 appendChild 插入已存在元素时会先删除之前再进行插入，那明白这个特性有什么实际的用处吗？答案是肯定的。例如下面一个需求，点击按钮，根据元素中的数字大小对这组元素进行排序： 123456789&lt;!-- HTML 结构 --&gt;&lt;ul id="ul1"&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;4&lt;/li&gt;&lt;/ul&gt;&lt;button id="btn"&gt;点击&lt;/button&gt; 123456789101112131415161718192021222324252627282930313233// 选择元素var oUl1 = document.querySelector('#ul1');var aLi = oUl1.querySelectorAll('li');var oBtn = document.querySelector('#btn');// 把伪数组 aLi 中的每一项都放到数组里面，目的是为了进行排序var arr = [];for(var i = 0; i &lt; aLi.length; i ++) &#123; arr.push(aLi[i]);&#125;oBtn.onclick = function () &#123; // 这就是我们熟悉的冒泡排序，你还记得吗 for (var i = 0; i &lt; arr.length - 1; i++) &#123; // 需要走 arr.length - 1 轮 for (var j = 0; j &lt; arr.length - i - 1; j++) &#123; // 每轮比较 arr.length - i - 1 次 var prevNum = parseFloat(arr[j].innerText); var nextNum = parseFloat(arr[j + 1].innerText); if (prevNum &gt; nextNum) &#123; // 不能对伪数组中其中一些直接赋值，例如：aLi[j] = aLi[j+1]，所以需要把伪数组转换成数组后再进行排序 var temp = null; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125; // 此时 arr 中装的已经是排好序的一堆 li 元素了 for(var i = 0; i &lt; arr.length; i ++) &#123; // 分别把排好序的数组中的每个元素插入到 oUl1 内容的最后 // 注意每次插入的同时也会把 oUl1 中那个相同的元素先给干掉，所以 oUl1 中也就不会存在重复元素的问题 oUl1.appendChild(arr[i]); &#125;&#125;; 优化代码这里优化相关的代码我们并没有学（不建议查看），我这里也提供一种较佳实战，是给你们以后看的（甚至是工作后），优化后的 JS 代码如下： 123456789101112const oUl1 = document.querySelector('#ul1');const aLi = oUl1.querySelectorAll('li');const oBtn = document.querySelector('#btn');oBtn.addEventListener('click', () =&gt; &#123; // Array.from 可以把伪数组转成数组，sort 的原理就是上面写的冒泡排序 Array.from(aLi).sort((li1, li2) =&gt; &#123; return parseFloat(li1.innerText) - parseFloat(li2.innerText); &#125;).forEach(li =&gt; &#123; oUl1.appendChild(li); &#125;)&#125;);]]></content>
      <categories>
        <category>Web API</category>
      </categories>
      <tags>
        <tag>appendChild</tag>
      </tags>
  </entry>
</search>
