<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[React 必知必会]]></title>
    <url>%2F2019%2F08%2F01%2Freact-base%2F</url>
    <content type="text"><![CDATA[努力更新中… 常见绑定事件的操作查看代码 结论：应尽量避免 render 中使用箭头函数或 bind 绑定！ bind 的形式 123handleClick() &#123; this.setState((prevState, props) =&gt; (&#123;num: prevState.num+1&#125;));&#125; 1&lt;Button type="primary" onClick=&#123;this.handleClick.bind(this)&#125;&gt;点击&lt;/Button&gt; 定义实例方法时采用箭头函数的形式，推荐！ 123handleClick = () =&gt; &#123; this.setState((prevState, props) =&gt; (&#123;num: prevState.num+1&#125;));&#125; 1&lt;Button type="primary" onClick=&#123;this.handleClick&#125;&gt;点击&lt;/Button&gt; 绑定事件时采用箭头函数的形式 123handleClick() &#123; this.setState((prevState, props) =&gt; (&#123;num: prevState.num+1&#125;));&#125; 1&lt;Button type="primary" onClick=&#123;() =&gt; this.handleClick()&#125;&gt;点击&lt;/Button&gt; 实例方法和绑定事件都采用箭头函数的形式 123handleClick = () =&gt; &#123; this.setState((prevState, props) =&gt; (&#123;num: prevState.num+1&#125;));&#125; 12// 方便值的传递&lt;Button type="primary" onClick=&#123;() =&gt; this.handleClick()&#125;&gt;点击&lt;/Button&gt; constructor 中就扭正 this 的指向 1234567constructor(props) &#123; super(props); this.state = &#123; num: 0 &#125;; this.handleClick = this.handleClick.bind(this);&#125; 123handleClick() &#123; this.setState((prevState, props) =&gt; (&#123;num: prevState.num+1&#125;));&#125; 1&lt;Button type="primary" onClick=&#123;this.handleClick&#125;&gt;点击&lt;/Button&gt; Error Boundaries部分 UI 的 JavaScript 错误不应该导致整个应用崩溃，为了解决这个问题，React 16 引入了一个新的概念 —— 错误边界。查看代码 123456789export default class App extends Component &#123; render() &#123; return ( &lt;ErrorBoundary&gt; &lt;Test/&gt; &lt;/ErrorBoundary&gt; ); &#125;&#125; 12345678910111213141516171819202122export class ErrorBoundary extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; error: false &#125;; &#125; componentDidCatch(error, info) &#123; this.setState(&#123; error, info &#125;); &#125; render() &#123; if(this.state.error) &#123; return ( &lt;h1&gt;出错啦！&lt;/h1&gt; ); &#125; return this.props.children; &#125;&#125; Portals查看代码 可以将子节点渲染到存在于父组件以外的 DOM 节点，常用于弹框、对话框等。 123456789101112131415161718192021class Modal extends Component &#123; constructor(props) &#123; super(props); this.container = document.createElement('div'); document.body.appendChild(this.container); &#125; componentWillUnmount() &#123; document.body.removeChild(this.container); &#125; render() &#123; return ReactDOM.createPortal( &lt;div className="modal"&gt; &lt;span className="close" onClick=&#123;this.props.onClose&#125;&gt;&amp;times;&lt;/span&gt; &lt;div className="content"&gt; &#123;this.props.children&#125; &lt;/div&gt; &lt;/div&gt;, this.container ) &#125;&#125; 123456789101112131415161718192021222324252627export default class Test extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; showModal: true &#125;; &#125; closeModal = () =&gt; &#123; this.setState(&#123; showModal: false &#125;); &#125; render() &#123; return ( &lt;&gt; &lt;h2&gt;标题&lt;/h2&gt; &#123; this.state.showModal &amp;&amp; ( &lt;Modal onClose=&#123;this.closeModal&#125;&gt; Modal Dialog &lt;/Modal&gt; ) &#125; &lt;/&gt; ); &#125;&#125; Fragments查看代码 Fragments 允许你将子列表分组，而无需向 DOM 添加额外节点 1234567891011export default class Fragment extends Component &#123; render() &#123; return ( &lt;React.Fragment&gt; &lt;p&gt;1&lt;/p&gt; &lt;p&gt;2&lt;/p&gt; &lt;p&gt;3&lt;/p&gt; &lt;/React.Fragment&gt; ); &#125;&#125; 原理实现如下 12345678910111213// const Fragment = (&#123;children&#125;) =&gt; children;const Fragment = (props) =&gt; props.children;export default class Fragment extends Component &#123; render() &#123; return ( &lt;Fragment&gt; &lt;p&gt;1&lt;/p&gt; &lt;p&gt;2&lt;/p&gt; &lt;p&gt;3&lt;/p&gt; &lt;/Fragment&gt; ); &#125;&#125; Ref 获取元素/组件需求：打开页面使 Input 获取焦点，查看代码 通过 this.refs.xxx 1&lt;input type="text" ref="inputRef"/&gt; 1234// 注意是 componentDidMountcomponentDidMount() &#123; this.refs.inputRef.focus();&#125; 通过 ref 接受一个函数进行处理 1&lt;input type="text" ref=&#123;ele =&gt; ele.focus()&#125;/&gt; 或者 1234componentDidMount() &#123; this.inputRef.focus();&#125;&lt;input type="text" ref=&#123;ele =&gt; this.inputRef=ele&#125;/&gt; 利用 React.createRef() 1234constructor(props) &#123; super(props); this.inputRef = React.createRef();&#125; 123componentDidMount() &#123; this.inputRef.current.focus();&#125; 1&lt;input type="text" ref=&#123;this.inputRef&#125;/&gt; 如何自取子组件（函数）中的 DOM 节点？ 12345678910111213141516171819202122232425262728293031323334import React, &#123;Component&#125; from 'react';export default class AboutRef extends Component &#123; constructor(props) &#123; super(props); this.inputRef = React.createRef(); &#125; handleClick = () =&gt; &#123; // this.inputRef.current.refs.test.style.backgroundColor = 'red'; this.inputRef.current.style.backgroundColor = 'red'; &#125; render() &#123; return ( &lt;div&gt; &lt;Test ref=&#123;this.inputRef&#125;/&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;改变组件&lt;/button&gt; &lt;/div&gt; ); &#125;&#125;/* class Test extends Component &#123; render() &#123; return ( &lt;div ref="test"&gt;hello world&lt;/div&gt; ); &#125;&#125; */const Test = React.forwardRef((props, ref) =&gt; &#123; return ( &lt;div ref=&#123;ref&#125;&gt;hello world&lt;/div&gt; );&#125;); 新增生命周期v16.3 新增，v16.4 再次更新了 getDerivedStateFromProps，查看代码 12345static getDerivedStateFromProps(nextProps, prevState) &#123; // 将传入的 props 映射到 state 上面，props 更新 和 setState 时都会触发 const &#123; number &#125; = nextProps; return number % 2 === 0 ? &#123; num: number + 1 &#125; : &#123; num: number + 3 &#125;;&#125; 123456789getSnapshotBeforeUpdate() &#123; // 发生于 render 之后，但并没有渲染完毕，可以从 DOM 中捕获一些信息（例如滚动之前的高度） // 返回值会作为 componentDidUpdate 的第三个参数 console.log(2); return this.ulRef.current.offsetHeight&#125;componentDidUpdate(prevProps, prevState, snapshot) &#123; console.log(snapshot);&#125; 跨组件传值查看代码 旧版 Context API12345// Step1: 父static childContextTypes=&#123; color: PropTypes.string, changeColor:PropTypes.func&#125; 123456789// Step2: 父getChildContext() &#123; return &#123; color: this.state.color, changeColor:(color)=&gt;&#123; this.setState(&#123;color&#125;) &#125; &#125;&#125; 12345// step3: 子孙static contextTypes=&#123; color: PropTypes.string, changeColor:PropTypes.func&#125; 12// step4: 子孙&lt;button onClick=&#123;() =&gt; this.context.changeColor('pink')&#125;&gt;改变孙子的颜色&lt;/button&gt; 新版 Context APIReact 16.3 12// Step1: 全局const ThemeContent = React.createContext(); 123456789101112// Step2: 父const ctx = &#123; color: this.state.color, changeColor: this.changeColor&#125;;&lt;ThemeContent.Provider value=&#123;ctx&#125;&gt; &lt;div style=&#123;&#123; border: '3px solid red' &#125;&#125;&gt; &lt;h1&gt;父&lt;/h1&gt; &lt;Large1 /&gt; &lt;Large2 /&gt; &lt;/div&gt;&lt;/ThemeContent.Provider&gt; 1234567891011// Step3: 子孙&lt;ThemeContent.Consumer&gt;&#123; value =&gt; ( &lt;div style=&#123;&#123; border: '3px solid red', margin: 10, color: value.color &#125;&#125;&gt; &lt;h4&gt;孙子2&lt;/h4&gt; &lt;button onClick=&#123;() =&gt; value.changeColor('pink')&#125;&gt;改变孙子的颜色&lt;/button&gt; &lt;/div&gt; )&#125;&lt;/ThemeContent.Consumer&gt; 上面的 Step3 也可以改写如下： React16.6 提供的 API 1static contextType = ThemeContent; 1&lt;button onClick=&#123;() =&gt; this.context.changeColor('pink')&#125;&gt;改变孙子的颜色&lt;/button&gt; PureComponent浅比较新旧 props 和 state，发生变化时才会更新组件，提高效率！查看代码 React.memo()查看代码 PureComponent 要和 class component 配合使用，而 React.memo() 可以和 function component 一起使用，例如： 123456789function Child(props) &#123; console.log('res 没有变化时我不会 render ~~'); return ( &lt;div&gt; 结果是：&#123;props.res&#125; &lt;/div&gt; )&#125;Child = React.memo(Child); React.lazy()可以实现基于路由的代码分割/懒加载，查看代码 1234567891011121314151617181920212223import React, &#123; Suspense, lazy, Component &#125; from 'react';import &#123; HashRouter as Router, Route, Switch, Link &#125; from 'react-router-dom';const Home = lazy(() =&gt; import('./Home'));const News = lazy(() =&gt; import('./News'));// render 时需要 return 的内容如下&lt;Router&gt; &lt;Suspense fallback=&#123;&lt;div&gt;loading...&lt;/div&gt;&#125;&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to="/"&gt;Home&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to="/news"&gt;News&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;Switch&gt; &lt;Route exact path="/" component=&#123;Home&#125; /&gt; &lt;Route path="/news" component=&#123;News&#125; /&gt; &lt;/Switch&gt; &lt;/Suspense&gt;&lt;/Router&gt; 高阶组件及应用高阶组件是一个函数，能对接收过来的组件进行加工后再返回！查看代码 12345678910111213141516// 基本操作const Logger = (Com) =&gt; &#123; return class extends Component &#123; render() &#123; return &lt;Com &#123;...this.props&#125;/&gt;; &#125; &#125;&#125;const Hello = Logger((props) =&gt; &#123; return ( &lt;p&gt;Hello &#123;props.name&#125;&lt;/p&gt; )&#125;);&lt;Hello name="Ifer"/&gt; 123456789101112131415161718192021222324252627// 案例const withFetch = url =&gt; View =&gt; &#123; return class extends Component &#123; constructor() &#123; super(); this.state = &#123; loading: true, data: null &#125;; &#125; async componentDidMount() &#123; const res = await fetch(url); const data = await res.json(); this.setState(&#123; loading: false, data &#125;); &#125; render() &#123; if(this.state.loading) &#123; return &lt;div&gt;loading...&lt;/div&gt; &#125; else &#123; return &lt;View data=&#123;this.state.data&#125;&gt;&lt;/View&gt; &#125; &#125; &#125;&#125;; Render Props]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React 技巧</tag>
        <tag>React 必知必会</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个栗子认识正则]]></title>
    <url>%2F2019%2F07%2F28%2Fregexp-case%2F</url>
    <content type="text"><![CDATA[需求：取出字符串 &#39;张三工资：10000，李四工资：20000，我：30000&#39; 中的所有工资放到数组中。 分别用字符串下的 match、split、replace、search 和正则下的 exec、test 实现，希望大家对正则配合 JS 的使用有一个基础的认识！ Match 匹配123const str = '张三工资：10000，李四工资：20000，我：30000';let reg = /\d+/g;console.log(str.match(reg)); // ["10000", "20000", "30000"] Match 通过改变正则分组捕获12345const str = '张三工资：10000，李四工资：20000，我：30000';let reg = /(\d+)，[\u4e00-\u9fa5]+：(\d+)，[\u4e00-\u9fa5]+：(\d+)/; // 加不加 g 无所谓str.match(reg);console.log([RegExp.$1, RegExp.$2, RegExp.$3]); // ["10000", "20000", "30000"] Split 分组str.split(/xxx/)，以 xxx 把字符串拆分成数组，并且把 xxx 干掉。str.split(/(xxx)/)，这样拆分后的结果也会保留 (xxx) 分组！ 12345678910let str = '张三工资：10000，李四工资：20000，我：30000';let reg = /(\d+)/g;let arr = str.split(reg);console.log(arr); // ["张三工资：", "10000", "，李四工资：", "20000", "，我：", "30000", ""]let newArr = [];for(let i = 1; i &lt; arr.length; i +=2) &#123; newArr.push(arr[i]);&#125;console.log(newArr); // ["10000", "20000", "30000"] Split 通过改变正则分组捕获12345const str = '张三工资：10000，李四工资：20000，我：30000';let reg = /(\d+)，[\u4e00-\u9fa5]+：(\d+)，[\u4e00-\u9fa5]+：(\d+)/; // 加不加 g 无所谓str.split(reg);console.log([RegExp.$1, RegExp.$2, RegExp.$3]); // ["10000", "20000", "30000"] Replace 匹配123456789let str = '张三工资：10000，李四工资：20000，我：30000';let reg = /\d+/g;let arr = [];// 正则对象匹配到的字符串，分组1，分组2，匹配到的字符串在元字符中的偏移量，被匹配的原字符串str.replace(reg, function(regExpStr, p1, offset,) &#123; arr.push(regExpStr);&#125;);console.log(arr); Replace 分组捕获123456789let str = '张三工资：10000，李四工资：20000，我：30000';let reg = /(\d+)/g;let arr = [];// 正则对象匹配到的字符串，分组1，分组2，匹配到的字符串在元字符中的偏移量，被匹配的原字符串str.replace(reg, function(regExpStr, p1, offset,) &#123; arr.push(p1);&#125;);console.log(arr); Replace 通过改变正则分组捕获12345const str = '张三工资：10000，李四工资：20000，我：30000';let reg = /(\d+)，[\u4e00-\u9fa5]+：(\d+)，[\u4e00-\u9fa5]+：(\d+)/; // 加不加 g 无所谓str.replace(reg);console.log([RegExp.$1, RegExp.$2, RegExp.$3]); // ["10000", "20000", "30000"] Search 通过改变正则分组捕获123456let str = '张三工资：10000，李四工资：20000，我：30000';let reg = /(\d+)，[\u4e00-\u9fa5]+：(\d+)，[\u4e00-\u9fa5]+：(\d+)/;str.search(reg);console.log([RegExp.$1, RegExp.$2, RegExp.$3]); Exec 匹配12345678910111213141516171819const str = '张三工资：10000，李四工资：20000，我：30000';RegExp.prototype.execAll = function () &#123; let str = arguments[0] || '', result = []; // 如果没有加 g 永远匹配的都是第一项是死循环，我们只让执行一次就行 if (!this.global) return this.exec(str); let arr = this.exec(str); // 匹配不上时 arr 就是 null while (arr) &#123; // 第 0 项就是全局匹配的结果 result.push(arr[0]); arr = this.exec(str); &#125; return result;&#125;;let reg = /\d+/g;console.log(reg.execAll(str)); // ["10000", "20000", "30000"] Exec 分组捕获12345678910111213141516const str = '张三工资：10000，李四工资：20000，我：30000';RegExp.prototype.execAll = function () &#123; let str = arguments[0] || '', result = []; if (!this.global) return this.exec(str); let arr = this.exec(str); while (arr) &#123; // 第 1 个分组 result.push(arr[1]); arr = this.exec(str); &#125; return result;&#125;;let reg = /(\d+)/g;console.log(reg.execAll(str)); // ["10000", "20000", "30000"] Exec 通过改变正则分组捕获12345const str = '张三工资：10000，李四工资：20000，我：30000';let reg = /(\d+)，[\u4e00-\u9fa5]+：(\d+)，[\u4e00-\u9fa5]+：(\d+)/;reg.exec(str);console.log([RegExp.$1, RegExp.$2, RegExp.$3]); // ["10000", "20000", "30000"] Test 分组捕获123456789let str = '张三工资：10000，李四工资：20000，我：30000';let reg = /(\d+)/g;let arr = [];while(reg.test(str)) &#123; // 每次 test lastIndex 的值都会变成下次开始查找的位置 arr.push(RegExp.$1);&#125;console.log(arr); // ["10000", "20000", "30000"] Test 通过改变正则分组捕获12345let str = '张三工资：10000，李四工资：20000，我：30000';let reg = /(\d+)，[\u4e00-\u9fa5]+：(\d+)，[\u4e00-\u9fa5]+：(\d+)/;reg.test(str);console.log([RegExp.$1, RegExp.$2, RegExp.$3]); // ["10000", "20000", "30000"]]]></content>
      <categories>
        <category>JS 高级</category>
      </categories>
      <tags>
        <tag>RegExp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES2015(ES6)]]></title>
    <url>%2F2019%2F07%2F15%2Fes5ores6%2F</url>
    <content type="text"><![CDATA[主要是 ES6 的知识梳理 ~ let/const12345// 有代码块的概念&#123; let a = 12;&#125;console.log(a);// ReferenceError: a is not defined 123// 不允许重复声明let a = 12;let a = 5; 123456let f = 10;function fn() &#123; f = 7; // 暂时性死去，报错 let f = 2;&#125;fn(); 123// 不支持预解析（变量提升）了console.log(a); // ReferenceError: a is not definedlet a = 1; 123456// 循环语句之内是一个父作用域，循环体之中是一个子作用域for(let i = 0; i &lt; 3; i ++) &#123; let i = 10; console.log(i);&#125;console.log(i); // 报错，i is not defined 1234567// const 必须给初始值，且一旦赋值，终身不变// const 对象的话是可以修改内部的值的const a = &#123; name: 'yangk'&#125;;a.name = 'momo';console.log(a.name); 关于字符串模板字符串1234// 基础套路let name = "yangk"let age = 22;let str = `my name is $&#123;name&#125;, age $&#123;age&#125;.`; 12345678// 尝试替换 $&#123;xxx&#125;let name = 'yangk';let age = 22;let str = 'my name is $&#123;name&#125;, age $&#123;age&#125;.';str = str.replace(/\$\&#123;([^&#125;]+)\&#125;/g, function() &#123; return eval(arguments[1]);&#125;); 12345// 标签函数function fn(args) &#123; console.log(args);&#125;fn`aaa`; 12345678910111213141516171819// 自定义模板let name = 'yangk';let age = 22;function fn() &#123; // console.log(arguments);// [["my name is ", ", age ", "."], "yangk", 22] let strings = arguments[0]; // 把第一项后面的变成数组 let values = [].slice.call(arguments, 1); let res = ''; for(let i = 0; i &lt; values.length; i ++) &#123; res += `$&#123;strings[i]&#125;~$&#123;values[i]&#125;~`; &#125; res += strings[strings.length - 1]; return res;&#125;let str = fn`my name is $&#123;name&#125;, age $&#123;age&#125;.`;console.log(str); 新增方法123// includes 代替 indexOflet str = 'hello world';console.log(str.includes('hello')); 1234// startWith/endsWithlet str = 'hello world';console.log(str.startsWith('hello'));// trueconsole.log(str.endsWith('world'));// true 123// repeatlet str = 'hello world';console.log(str.repeat(3)); // hello worldhello worldhello world 123456// padStart/padEndlet str = 'hello world';// 长度，要往前填充的内容console.log(str.padStart(20, 'x')); // xxxxxxxxxhello world// 长度，要往后填充的内容console.log(str.padEnd(20, 'x')); // hello worldxxxxxxxxx 解构赋值解构普通数组1let [a,b,c] = [12,54,74]; 12let [a, [b, c], d] = [12, [1, 2], 6];let [&#123;a, e&#125;, [b, c], d] = [&#123;a: 'haha',e: 'xixi'&#125;, [1, 2], 6]; 解构 JSON 对象12// 解构一个对象，与顺序无关let &#123;a,b,c&#125; = &#123;b: 5, c: 7, a: 12&#125; 123// 解构 [] 对象的 length 属性let &#123;length&#125; = ['哈', 9];console.log(length); // 2 12// 使用别名，不然直接使用 default 关键字会报错let &#123;default: d&#125; = &#123;default: 2&#125;; 123// 默认值let &#123;time=12,id=0&#125; = &#123;time:33&#125;;console.log(time); // 33 解构字符串12let [a, b, c, d] = '1234';console.log(a, b, c, d); 12let &#123;length: len&#125; = 'test';console.log(len); // 4 其他解构赋值12345let &#123;toString: ts&#125; = 1;let &#123;toString: bs&#125; = true;console.log(ts === Number.prototype.toString);console.log(bs === Boolean.prototype.toString); 注：null 和 undefined 是不能进行解构赋值的 Iterator 和 for ofIterator 可以为各种不同的数据结构提供统一的访问机制，任何数据结构只要部署 Iterator 接口，就可以完成遍历操作，而且这种遍历是依次进行的 为各种数据结构，提供一个统一的、简便的访问接口 使得数据结构的成员能够按某种次序排列 Iterator 结构主要供 for of 循环来消费 123456789101112131415161718192021222324252627// Iterator 遍历过程：// - 创建一个指针对象，指向当前数据结构的起始位置// - 第一次调用指针对象的 next 方法，将指针对象指向数据结构的第一个成员// - ...const arr = [1, 2, 3];function iterator(arr) &#123; let index = 0; return &#123; next: function() &#123; return index &lt; arr.length ? &#123; value: arr[index++], done: false &#125; : &#123; value: undefined, done: true &#125;; &#125; &#125;;&#125;let it = iterator(arr);console.log( it.next() );console.log( it.next() );console.log( it.next() );console.log( it.next() ); 有些数据结构本身就具备了 Iterator 接口，例如数组、字符串、set、map，对象就没有 Iterator 接口，凡是具有 Symbol.iterator 属性的数据结构都具有 Iterator 接口 12345678910111213141516const arr = [1, 2, 3];const set = new Set(['a', 'b', 'c']);const map = new Map([ ['name', 'aaayang']]);const itArr = arr[Symbol.iterator]();const itSet = set[Symbol.iterator]();const itMap = map[Symbol.iterator]();console.log(itArr, itSet, itMap); // 打印 Iterator 的对象指针console.log(itSet.next()); // &#123;value: 'a', done: false&#125;console.log(itSet.next());console.log(itSet.next());console.log(itSet.next()); 12const obj = &#123;&#125;;console.log(obj[Symbol.iterator]); // undefined，说明对象并不具备 Iterator 接口 具备 iterator 接口的数据结构都可以进行结构赋值、扩展运算符、for of 123const set = new Set(['a', 'b', 'c']);let [x, y] = set;console.log(x, y); 1234let str = 'test'; // 类数组，也具备 Iterator 接口let arrStr = [...str];console.log(arrStr); // ['t', 'e', 's', 't'] 1234// 数组去重let arr = [1, 1];let newArr = [...new Set(arr)];console.log(newArr); 12345let arr = ['a', 'b', 'c'];for (let i of arr) &#123; console.log(i); // a, b, c&#125; 123456const m = new Map();m.set('a', 1).set('b', 2).set('c', 3);for(let i of m) &#123; console.log(i); // ['a', 1], ['b', 2], ['c', 3]&#125; 123456const m = new Map();m.set('a', 1).set('b', 2).set('c', 3);// 也可以在循环的时候对数组进行解构for(let [k, v] of m) &#123; console.log(k, v); // a 1, b 2, c 3&#125; 给一个不具备 Iterator 接口的对象部署一个 Iterator 接口 123456789101112131415161718192021222324252627let obj = &#123; name: 'aaayang', age: 18&#125;;obj[Symbol.iterator] = function() &#123; let keys = Object.keys(obj); let len = keys.length; let i = 0; // 该函数必须返回一个对象 return &#123; // 返回对象中必须包含 next 方法，这个 next 方法就是给迭代进行调用的，比如 for of，每次迭代就是调用这个 next() next() &#123; return i &lt; len ? &#123; value: obj[keys[i++]], done: false &#125; : &#123; value: undefined, done: true &#125;; &#125; &#125;;&#125;;for(let i of obj) &#123; console.log(i);&#125; 展开和收缩主要针对的是数组（ES2018对象也可以了），既可以扩展，也可以收缩，也可以剩余（写在函数参数中） 扩展成多个（值）可以用来拷贝对象，并且对新对象的修改不会影响到原对象 123456let arr1 = [1, 2, 3];let arr2 = [];// 先扩展数组，在放进数组arr2 = [...arr1]; // 也可以 Array.from(arr1)arr2.pop();console.log(arr1); 12345let aDiv = document.getElementsByTagName('div');// let aEle = [].slice.call(aDiv);// Array.fromlet aEle = [...aDiv];console.log(aEle); 12345// 之前的做法function show(a,b,c,d) &#123; console.log(a,b,c,d);&#125;show.apply(null, [1, 2, 3, 4]); 12345// 现在的做法function show(a,b,c,d) &#123; console.log(a,b,c,d);&#125;show(...[1, 2, 3, 4]); 收缩为一个（数组）之前的做法是：Array.prototype.slice.call(arguments)，现在可以用 Array.from 或扩展运算符 12345function show(...args)&#123; args.push(5);// args 就是一个数组，直接可以push console.log(...args);&#125;show(1,2,3,4); 对象的收缩和展开12let &#123; x, y, ...z &#125; = &#123; x: 1, y: 2, z: 3, m: 4 &#125;;console.log(z); // &#123;z: 3, m: 4&#125; 1234// 常用来复制一个对象let json1 = &#123; x: 1, y: 2, z: 3, m: 4 &#125;;let json2 = &#123;...json1&#125;;console.log(json2); 关于数组reduce1234567// 求和，因为没有默认值，第一次 prev 是 1，next 是 2，nextIndex 就是 1let arr = [1, 2, 3, 4];let res = arr.reduce((prev, next, nextIndex, arr) =&gt; &#123; // 返回结果会作为下一次循环的 prev return prev + next;&#125;);console.log(res); 12345// 加默认值就多循环了一次，第一次 prev 是 0，next 是1，nextIndex 在数组中的索引也就是 0let arr = [1, 2, 3, 4];let res = arr.reduce((prev, next, nextIndex, arr) =&gt; &#123; return prev + next;&#125;,0); 123456789// 求平均数let arr = [1, 2, 3, 4];let res = arr.reduce((prev, next, nextIndex, arr) =&gt; &#123; if(arr.length -1 === nextIndex) &#123; return (prev + next)/arr.length; &#125; return prev + next;&#125;);console.log(res); 123456789101112131415161718// 默认值的使用let arr = [&#123; count: 1&#125;,&#123; count: 2&#125;,&#123; count: 3&#125;];/* let res = arr.reduce((prev, next, nextIndex, arr) =&gt; &#123; // 第一次没问题，第二次返回的结果 3 会作为下一次的 prev，3.count 这是什么鬼 return prev.count + next.count;&#125;); */let res = arr.reduce((prev, next, nextIndex, arr) =&gt; &#123; // 第一次 prev 为 0，next.count 就是 1，它们的和作为下一次的 prev，下一次的 next.count 又是 2 return prev + next.count;&#125;,0); 123456789101112// 实现 reduceArray.prototype.myReduce = function (fn, prev) &#123; for (let i = 0; i &lt; this.length; i++) &#123; if (typeof prev === 'undefined') &#123; prev = fn(this[i], this[i + 1], i + 1, this); // ++i; &#125; else &#123; prev = fn(prev, this[i], i, this); &#125; &#125; return prev;&#125;; 12345678910// 没有默认值，reduce 回调只执行了一次，只能展开二维数组let arr = [ [1,2,3], [4,5,6]];arr = arr.reduce((prev,next, nextIndex,ary) =&gt; &#123; return [...prev,...next];&#125;);console.log(arr); forEachforEach 可以完全代替 for 1234// ['a', 'b', 'c', 'd'].forEach(console.log);['a', 'b', 'c', 'd'].forEach(function (value, index, array) &#123; console.log(this,value); // this 默认 window，现在改成了 'xxx'&#125;, 'xxx'); 123['a', 'b', 'c', 'd'].forEach( (value, index, array) =&gt; &#123; console.log(this,value); // 用箭头函数第二个参数就凉了&#125;, 'xxx'); 1234// 注意 jQuery 中的第一个参数是 index ...$.each([], function(index, value, array) &#123; // ...&#125;); 1234567// 应用let sum = 0;[1, 2, 3, 4].forEach(function(value,index,array)&#123; // console.log(array[index] == value); sum += value;&#125;);console.log(sum);// 10 map123456// map 对元素重新组装，生成新数组let arr = [1, 2, 3, 4];let arrNew = arr.map(function (item) &#123; return item * item;// 一般配合return使用&#125;);console.log(arrNew); // 1, 4, 9, 16 filter12345678let arr = [1, 2, 3, 4];// filter 筛选出符合条件的元素，返回新数组let result3 = arr.filter(function(item, index) &#123; if(item &gt;= 2) &#123; return true; &#125;&#125;);console.log(result3); find123456// 返回数组中符合条件的第一个元素let array1 = [5, 12, 8, 130, 44];let found = array1.find(function (element) &#123; return element &gt; 10;&#125;);console.log(found); // 12 findIndex123456// 返回数组中符合的第一个元素的索引let array1 = [5, 12, 8, 130, 44];let found = array1.findIndex(function (element) &#123; return element &gt; 10;&#125;);console.log(found); // 1 some123456789let arr = [1, 2, 3, 4];// some 判断是否有至少一个元素符合条件，返回true or falselet result2 = arr.some(function (item, index) &#123; /* if (item &lt; 4) &#123; return true; &#125; */ return item &lt; 4;&#125;);console.log(result2); // true every123456789// every 判断所有元素是否都符合条件，返回true or falselet arr = [1, 2, 3, 4];let result = arr.every(function(item, index) &#123; /* if(item &lt; 4) &#123; return true; &#125; */ return item &lt; 4;&#125;);console.log(result); // false fill123let arr = new Array(5);arr.fill('xxx');console.log(arr); // ["xxx", "xxx", "xxx", "xxx", "xxx"] includes数组也有 includes，和字符串的一样的意思 from类数组转数组 复制一份对新赋值对象的修改不会影响原来的对象 12345let arr1 = [1, 2, 3];let arr2 = [];arr2 = Array.from(arr1);arr2.pop();console.log(arr1); 类数组转数组1234let aDiv = document.getElementsByTagName('div');// let aEle = [].slice.call(aDiv);let aEle = Array.from(aDiv);// 类数组转数组console.log(aEle); 12345678910// 一般有 length 就是类数组，就可以转let json = &#123; 0: 'xxx', 1: 'yyy', 2: 'zzz', length: 2&#125;;let arr = Array.from(json);console.log(arr); // ['xxx', 'yyy'] 字符串拆分成数组123let name = 'yangk';let arrName = Array.from(name);console.log(arrName); // ["y", "a", "n", "g", "k"] of也可以把一堆参数组合成数组 12let arr = Array.of(1,2,3,4,5);console.log(arr); // [1, 2, 3, 4, 5] flat会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回 12// depth 默认1var newArray = arr.flat(depth) 123var arr1 = [1, 2, [3, 4]];arr1 = arr1.flat();console.log(arr1); // [1, 2, 3, 4] 1234var arr = [1, 2, [3, 4, [5, 6]]];// 使用 Infinity 作为深度，展开任意深度的嵌套数组arr = arr.flat(Infinity);console.log(arr); 1234// 去重扁平化后的数组并排序var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10];arr = Array.from(new Set(arr.flat(Infinity))).sort((a,b) =&gt; a-b);console.log(arr); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14] 函数变更默认参数1234function show(a='hello', b='world') &#123; console.log(a,b);&#125;show(); 12345function show(&#123;x=0,y=1&#125;=&#123;&#125;) &#123; console.log(x,y);&#125;show(&#123;x:8&#125;); 箭头函数1234document.onclick = () =&gt; &#123; // this =&gt; window document.body.style.background = "red";&#125;; this 指向123456789let json = &#123; a: 1, b: 2, show: () =&gt; &#123; // this =&gt; window console.log(this.a); &#125;&#125;;json.show();// undefined 12345678910let json = &#123; a: 1, b: 2, show: () =&gt; &#123; setTimeout(() =&gt; &#123; console.log(this.a); &#125;, 1000); &#125;&#125;;json.show();// undefined 1234567891011let json = &#123; a: 1, b: 2, show: function() &#123; setTimeout(() =&gt; &#123; // 取决于父级中的 this console.log(this.a); &#125;, 1000); &#125;&#125;;json.show();// 1 arguments箭头函数中没有 arguments 1234let show = ()=&gt;&#123; console.log(arguments);// arguments is not defined&#125;;show(1,2,3); 12345// 常用let show = (...args) =&gt; &#123; console.log(args); // [1,2,3]&#125;;show(1, 2, 3); 简便写法1234567891011let name = "yangk";let age = 18;let person = &#123; name, age, showName()&#123; // this =&gt; window console.log(this.name); &#125;&#125;;person.showName(); 箭头函数不能当构造函数使用12345// 错误姿势let Show = (name) =&gt; &#123; this.name = name;&#125;let show = new Show('xxx'); 对象简洁语法12345678910111213let name = 'aaa';let age = 18;let json = &#123; name, age, // 里面的方法不要用箭头函数，不然自找蛋疼 showName() &#123; console.log(this.name); &#125;&#125;;json.showName(); // aaa ObjectObject.assign只会拷贝源对象自身的并且可枚举的属性到目标对象，注意是浅拷贝 12345678910111213let json1 = &#123; name: 'xxx'&#125;;let json2 = &#123; name: 'yyy', age: 18&#125;;let json3 = &#123; hobby: '足球'&#125;;// 目标用新的空对象，假如去掉会对原来的 json1 造成影响let obj = Object.assign(&#123;&#125;, json1, json2, json3); 1234// 也可以对数组进行复制操作let arr1 = ['a', 'b', 'c'];let arr2 = Object.assign([],arr1);console.log(arr2); Object.keys1234567let json = &#123; name: 'aaayang', age: 18&#125;;for(let key of Object.keys(json)) &#123; console.log(key); // name, age, for in 循环得到的是 0, 1&#125; Object.valuesObject.entriesObject.is1Object.is(NaN, NaN); // true 12console.log(+0 === -0); // trueconsole.log(Object.is(+0, -0)); // false setPrototypeOf1234567891011// 设let obj1 = &#123; name: 'aaayang'&#125;;let obj2 = &#123; age: 18&#125;;// 链：__proto__，任何东西都有obj1.__proto__ = obj2;// 先找自己的，找不到通过链找console.log(obj1.age); 1234// 取// console.log(obj1.__proto__); // &#123;age: 18&#125;Object.getPrototypeOf(obj1); // &#123;age: 18&#125; 12345678910111213// 可以通过 super 找到父let obj1 = &#123; name: 'aaayang'&#125;;let obj2 = &#123; name: 'bbb', getPName() &#123; return super.name; &#125;, __proto__: obj1&#125;;console.log(obj2.name); // bbbconsole.log(obj2.getPName()); // aaayang 异步的发展回调函数函数返回函数高阶函数：函数返回函数，或函数当做参数传递 1234567// 简单判断类型的需求function isType(type, content) &#123; return Object.prototype.toString.call(content) === `[object $&#123;type&#125;]`;&#125;// 麻烦isType('String', 'hello')isType('String', 'world') 1234567891011121314function isType(type) &#123; return function(content) &#123; return Object.prototype.toString.call(content) === `[object $&#123;type&#125;]`; &#125;&#125;let arr = ['String', 'Number', 'Array', 'Object', 'Null'];let util = &#123;&#125;;arr.forEach(item =&gt; &#123; util['is'+item] = isType(item);&#125;);console.log(util.isString('hello')); 函数当做参数高阶函数：函数返回函数，或函数当做参数传递 123456789101112131415161718// 调用 3 次 fn 才执行回调let fn = after(3, function() &#123; console.log('done');&#125;);// 当达到某个条件时执行 callbackfunction after(times, callback) &#123; return function() &#123; // 这里可以写一些逻辑 xxx // xxx if(--times === 0) &#123; callback(); &#125; &#125;&#125;fn();fn();fn(); // done 能干什么1234567891011121314151617// 把两个文件读取的结果同时打印出来let fs = require('fs');fs.readFile('./a.txt', 'utf-8', function(err, data) &#123; out(data);&#125;);fs.readFile('./b.txt', 'utf-8', function (err, data) &#123; out(data)&#125;);let arr = [];function out(data) &#123; arr.push(data); if (arr.length === 2) &#123; console.log(arr); &#125;&#125; 1234567891011121314151617181920212223// 改进上面的代码let fs = require('fs');function after(times, callback) &#123; // 可以缓存函数，当达到条件时执行回调函数 let arr = []; return function (data) &#123; arr.push(data); if (--times === 0) &#123; callback(arr); &#125; &#125;&#125;fs.readFile('./a.txt', 'utf-8', function (err, data) &#123; out(data);&#125;);fs.readFile('./b.txt', 'utf-8', function (err, data) &#123; out(data)&#125;);let out = after(2, function (arr) &#123; console.log(arr);&#125;); Promise12345678910let promise = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve('success'); &#125;, 1000);&#125;);promise.then(res =&gt; &#123; console.log(res);&#125;, err =&gt; &#123; console.log(err);&#125;); generator预热12345678910111213// 有索引，有长度，是一个类数组let obj = &#123; 0: 'hello', 1: 'world', length: 2&#125;;// 默认不可被迭代// let arr = [...obj];// 可以使用 Array.fromlet arr = Array.from(obj);console.log(arr); 12345678910111213141516171819202122// 模拟迭代let obj = &#123; 0: 'hello', 1: 'world', length: 2, // 迭代器函数，会返回一个对象，对象中必须有一个 next 方法 [Symbol.iterator]: function() &#123; let index = 0; let that = this; return &#123; next() &#123; return &#123; value: that[index], // 是否迭代完成 done: index++ === that.length &#125; &#125; &#125; &#125;&#125;;let arr = [...obj]; 123456789101112131415161718// 模拟迭代器function read(arr) &#123; let index = 0; return &#123; next() &#123; return &#123; value: arr[index], done: index++ &gt;= arr.length &#125;; &#125; &#125;;&#125;let it = read(['vue', 'react', 'angular']);console.log(it.next());console.log(it.next());console.log(it.next());console.log(it.next()); // &#123; value: undefined, done: true &#125; 正式开始generator 是一个生成器，生成的是上面我们模拟的迭代器，它可以把一个函数拆分成若干个部分执行。 123456function *gen() &#123; return 1000;&#125;let a = gen();// 碰到 return 认为迭代完成了console.log(a.next()); // &#123; value: 1000, done: true &#125; 123456function *gen() &#123; yield 1000;&#125;let a = gen();// yield 并不认为迭代完成console.log(a.next()); // &#123; value: 1000, done: false &#125; 12345678910111213// 第一次调用迭代器 next 传递的参数没有意义，想穿在调用生成器的时候穿// 第二次 next 传递的参数是上次 yield 的返回值 ...function *gen(xxx) &#123; let a = yield xxxx; let b = yield a; return b;&#125;let a = gen('买菜');console.log(a.next());console.log(a.next('买好的菜')); // 赋值给了 aconsole.log(a.next('做菜')); 12345678910111213141516171819202122232425262728293031323334/* const read = function(filename) &#123; return new Promise((resolve, reject) =&gt; &#123; fs.readFile(filename, (err, data) =&gt; &#123; if(err) reject(err); resolve(data.toString()); &#125;); &#125;);&#125;; */// 读取依赖文件，手工迭代let fs = require('fs');let &#123;promisify&#125; = require('bluebird');let read = promisify(fs.readFile);function * gen() &#123; // read 返回的是个 promise let b = yield read('a.txt', 'utf8'); let c = yield read(b, 'utf8'); let res = yield read(c, 'utf8'); return res;&#125;let it = gen();// it.next() 的 read 的返回结果，结果的value 是个 promiseit.next().value.then(data =&gt; &#123; // data =&gt; b.txt =&gt; 传递给上面的 b it.next(data).value.then(data =&gt; &#123; // data =&gt; c.txt =&gt; 传递给上面的 c it.next(data).value.then(data =&gt; &#123; // data =&gt; hello world =&gt; 传递给上面的 res console.log(it.next(data).value) &#125;); &#125;);&#125;); 12345678910111213141516// 用 co 帮我们执行上面的迭代，yield 后要求返回的是一个 promiselet fs = require('fs');let co = require('co');let &#123;promisify&#125; = require('bluebird');let read = promisify(fs.readFile);function * gen() &#123; let b = yield read('a.txt', 'utf8'); let c = yield read(b, 'utf8'); let res = yield read(c, 'utf8'); return res;&#125;co(gen()).then(data =&gt; &#123; console.log(data);&#125;); 123456789101112131415function *a() &#123; yield '1'; yield '2';&#125;// 如果在 generator 中调用另一个 generator，加个 *function *b() &#123; yield '3'; yield * a(); yield '4';&#125;let it = b();console.log(it.next());console.log(it.next()); asyncasync 是 generator 的语法糖 await 后面可以是 promise，也可以是数字、字符串 只要 await 语句后面的 Promise 状态变成 reject，那么整个 async 函数都会中断执行，所以建议任何有 await 的地方都要 try catch，或者用 promise 本身的 catch，比较累 123456789101112131415let &#123;promisify&#125; = require('bluebird');let fs = require('fs');let read = promisify(fs.readFile);// async 返回的是个 promiseasync function r() &#123; let b = await read('./a.txt', 'utf8'); let c = await read(b, 'utf8'); let res = await read(c, 'utf8'); return res;&#125;r().then(data =&gt; &#123; console.log(data);&#125;); 123456789async function fn() &#123; let [a,b,c] = await Promise.all([ readFile('./a.txt'), readFile('./b.txt'), readFile('./c.txt') ]); console.log(a,b,c);&#125;fn(); 模块化 CommonJS，服务端，同步的 AMD，requireJS CMD，seaJS ES规范，统一客户端和服务端 一般套路服务器环境下运行，默认严格模式 12// mod.jsexport const name = 'aaa'; 12345// 可以相对路径&lt;script type="module"&gt;import &#123;name&#125; from './mod.js';console.log(name);&lt;/script&gt; 123456789// 也可以绝对路径&lt;script type="module"&gt;import 'https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js';setTimeout(() =&gt; &#123; $('body').css(&#123; background: 'red' &#125;);&#125;);&lt;/script&gt; 12// 只有 export default 在引入时不需要解构// 其他情况在引入时要么解构，要么 import * as xxx from './mod' 动态加载123456789101112&lt;script type="module"&gt;let a = 'xxx';if (a === 'xxx') &#123; import('./mod1.js').then(res =&gt; &#123; console.log(res.name); &#125;);&#125; else &#123; import('./mod2.js').then(res =&gt; &#123; console.log(res.name); &#125;);&#125;&lt;/script&gt; 123456789&lt;script type="module"&gt;import('https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js').then(res =&gt; &#123; $(function() &#123; $('body').css(&#123; background: 'red' &#125;); &#125;);&#125;);&lt;/script&gt; 12345678910// await 后跟 promise，返回的是 promise 执行的结果&lt;script type="module"&gt;async function load() &#123; const mod1 = await import('./mod1.js'); const mod2 = await import('./mod2.js'); console.log(mod1.name); console.log(mod2.name);&#125;load();&lt;/script&gt; 12345678910&lt;script type="module"&gt;async function load() &#123; const [m1,m2] = await Promise.all([ import('./mod1.js'), import('./mod2.js') ]); console.log(m1.name, m2.name);&#125;load();&lt;/script&gt; ES6 中的类class 没有预解析，必须先定义后调用 ES5和ES6 对比12345678910111213141516const Test = function(a, b) &#123; this.a = a; this.b = b; return this;&#125;;Test.prototype = &#123; constructor: Test, print: function() &#123; console.log(this.a + ' ' + this.b); &#125;&#125;;let t = new Test('hello', 'world');t.print(); 123456789101112class Test &#123; constructor(a, b) &#123; this.a = a; this.b = b; return this; &#125; print() &#123; console.log(this.a + ' ' + this.b); &#125;&#125;new Test('hello', 'world').print(); 基本套路12345678910111213class Person &#123; // 调用 new 自动执行，默认也会添加 contructor constructor(name, age) &#123; this.name = name; this.age = age; &#125; // 定义在类中方法都是不可以被枚举的，Object.keys(Person.prototype) 搞不出来 showName() &#123; console.log(this.name); &#125;&#125;let p1 = new Person('aaayang', 18);p1.showName(); 方法可以是变量12345678910let hobby = 'hobbyFn';class Person &#123; [hobby]() &#123; console.log('hello world'); &#125;&#125;let p1 = new Person();p1[hobby]();p1.hobbyFn(); 关于 this一般定义妥妥的 1234567891011class Person &#123; constructor(name) &#123; this.name = name; &#125; sayName() &#123; console.log(this.name); &#125;&#125; let p1 = new Person('aaayang');p1.sayName(); // ok 解构后再使用，this 就是 undefined 了 1234567891011class Person &#123; constructor(name) &#123; this.name = name; &#125; sayName() &#123; console.log(this.name); &#125;&#125;let p1 = new Person('aaayang');let &#123;sayName&#125; = p1;sayName(); // this 是 undefined 矫正 this 1234567891011121314class Person &#123; constructor(name) &#123; this.name = name; // call 和 apply 也可以矫正 this，但会调用函数 // bind 只管矫正，并不调用函数 this.sayName = this.sayName.bind(this); &#125; sayName() &#123; console.log(this.name); &#125;&#125;let p1 = new Person('aaayang');let &#123;sayName&#125; = p1;sayName(); // aaayang 静态方法123456class Person &#123; static sayName() &#123; console.log('hello world'); &#125;&#125;Person.sayName(); 继承1234567891011121314class Person &#123; constructor(name) &#123; this.name = name; &#125; sayName() &#123; console.log(this.name); &#125;&#125;class Student extends Person &#123;&#125;let stu = new Student('xxx');stu.sayName(); // xxx 123456789101112131415161718class Person &#123; constructor(name) &#123; this.name = name; &#125; sayName() &#123; console.log(this.name); &#125;&#125;class Student extends Person &#123; constructor(name, age) &#123; super(name); // 想有自己的属性，必须先继承父级的属性 this.age = age; &#125;&#125;let stu = new Student('xxx', 18);console.log(stu.name, stu.age); 执行父的方法 1234567891011121314151617181920212223class Person &#123; constructor(name) &#123; this.name = name; &#125; sayName() &#123; console.log(this.name); &#125;&#125;class Student extends Person &#123; constructor(name) &#123; super(name); &#125; sayName() &#123; // 执行父的方法，也可以是父类的静态方法 // super 指的是父类的原型对象 super.sayName(); console.log(this.name); &#125;&#125;let stu = new Student('xxx');stu.sayName(); 总结 子类继承父类用 extends 关键字 为父类指定静态方法，使用 static 方法名字 super 在构造函数中可以当一个函数来使用，相当于调用父类的构造函数 super 在原型方法中可以当一个对象来使用，相当于父类的原型对象，并且会自动绑定 this 到子类上 一个例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; canvas &#123; box-shadow: 2px 2px 12px rgba(0, 0, 0, 0.5); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id="canvas"&gt;&lt;/canvas&gt; &lt;script&gt; const canvas = document.querySelector('#canvas'); const ctx = canvas.getContext('2d'); canvas.width = 600; canvas.height = 400; class Ball &#123; constructor(x, y, r) &#123; this.x = x; this.y = y; this.r = r; // ~~ 代表去掉小数部分 this.color = `rgba($&#123;~~Ball.rpFn([55, 255])&#125;, $&#123;~~Ball.rpFn([55, 255])&#125;, $&#123;~~Ball.rpFn([55, 255])&#125;)`; return this; // 可以在实例化后继续调用其他的方法 &#125; render(ctx) &#123; ctx.save(); ctx.translate(this.x, this.y); ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(0, 0, this.r, 0, 2*Math.PI); ctx.fill(); ctx.restore(); return this; &#125; static rpFn(arr) &#123; // Ball.rpFn([1, 10]) let max = Math.max(...arr), min = Math.min(...arr); return Math.random() * (max - min) + min; &#125; &#125; class SuperBall extends Ball &#123; constructor(x, y, r) &#123; // 继承父类构造函数中所有的属性 super(x, y, r); // 调用父类的构造函数，相当于之前的 Ball.call(this, x, y, r) // 继承时，没调 super 这里是没有 this 的 this.vy = SuperBall.rpFn([2, 4]); this.g = SuperBall.rpFn([0.2, 0.4]); this.a = 0; return this; &#125; move(ctx) &#123; // super(); // 不能在非构造函数中调用 this.y += this.vy; this.vy += this.g; let current = this.vy * -0.75; if(this.y + this.r &gt;= ctx.canvas.height) &#123; this.y = ctx.canvas.height - this.r; if(Math.abs(current - this.a) &lt; 0.01) return false; this.a = this.vy *= -0.75; &#125; ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height); // 注意这里的 super 指的是父类的原型对象 super.render(ctx); return true; &#125; &#125; let ball, timer; canvas.onclick = function(e) &#123; let x = e.offsetX, y = e.offsetY; let r = ~~Ball.rpFn([25, 55]); ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height); ball = new SuperBall(x, y, r).render(ctx); ballMove(); &#125;; function ballMove() &#123; timer = window.requestAnimationFrame(ballMove); if(!ball.move(ctx)) &#123; window.cancelAnimationFrame(timer); &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Symbol一般当做唯一的 key 使用，Symbol 不能使用 new 去调用 1234567891011121314let syml = Symbol('hello');let json = &#123; a: 'apple', b: 'bannana', [syml]: 'symbol'&#125;;// console.log(json[syml]); // symbol// 不能被 for in 出来for(let key in json)&#123; console.log(key); // a b&#125; 12345678910let obj = &#123; [Symbol()]: 123, name: 'aaayang'&#125;;let a = Object.getOwnPropertySymbols(obj);console.log(a); // [ Symbol() ]let b = obj[a[0]];// 可见即使不在外面把 Symbol 当做一个变量，也是可以得到它的值的console.log(b); // 123 123456// 转成字符串console.log( String(Symbol('test')) );console.log( Symbol('test').toString() );// 转布尔console.log( !!Symbol() ); generator执行 generator 函数返回的是什么？？ 1234567891011function* gen() &#123; yield 'hello'; yield 'world'; return 'last';&#125;let g1 = gen();console.log(g1.next());console.log(g1.next());// 最后一个的 done 是不是 true 取决于 generator 函数最后是 return 还是 yieldconsole.log(g1.next()); // &#123; value: "last", done: true &#125; for of 遍历 12345678910function * gen() &#123; yield 'hello'; yield 'world'; return 'last';&#125;let g1 = gen();for(let val of g1) &#123; console.log(val); // hello workd，return 的东西不会遍历&#125; 123456789function * gen() &#123; yield 'hello'; yield 'world'; return 'last';&#125;let [a,b] = gen();console.log(a,b); // hello worldconsole.log(...gen()); // hello world 1234567function* gen() &#123; yield 'hello'; yield 'world'; return 'last';&#125;console.log(Array.from(gen())); // ['hello', 'world'] 1234567891011function* gen() &#123; let val = yield 'aaayang'; yield axios.get(`https://api.github.com/users/$&#123;val&#125;`);&#125;let g1 = gen();let username = g1.next().value; // aaayangg1.next(username).value.then(res =&gt; &#123; console.log(res);&#125;); Set/MapSet 类似于数组，不重复，其实没有真正的 key，所有也就没有 get 方法，因为 get 要通过 key 获取的 Map 类似于 JSON，相对于 Set 多了个 get 方法，另外 key 可以是任意的值 Set相当于 Python 中的集合 1234// 数据结构// set: 类似数组，里面不能有重复的值let arr = ['a', 'b', 'c', 'a'];let set = new Set(arr); 12345// 方法set.add('xxx'); // 添加set.delete('xxx'); // 删除console.log(set.has('c')); // 检测set.clear(); // 清空 12// 属性console.log(set.size); // 长度 1234// 循环for(let item of set) &#123; console.log(item); // a, b, c&#125; 1234567891011121314// Set 的 keys 和 values 是一样的for (let item of set.keys()) &#123; console.log(item); // a, b, c&#125;// 默认是values()for(let item of set.values()) &#123; console.log(item); // a, b, c&#125;for(let item of set.entries()) &#123; console.log(item); // ["a", "a"], ["b", "b"] ...&#125;for(let [k, v] of set.entries()) &#123; console.log(k,v); // a a, b b ...&#125; 1234// set 有 forEachset.forEach((val, index) =&gt; &#123; console.log(val, index);// a a, b b, c c ...&#125;); 12// 可以链式操作 new set(arr).add().add()set.add('gg').add('bb'); 12345678// 去重let xxx = ['1', '1', '2', '3', '3'];// Set 数据结构变成数组通过 ...console.log([...new Set(xxx)]);// 使用数组中的方法let m = new Set([...new Set(xxx)].map(value =&gt; value * 2));console.log(m); 123456789101112// 正常Set里面放的数组// 也可以放对象，最好用weaksetlet j1 = &#123; name: 'aaa'&#125;;let j2 = &#123; age: 18&#125;;// 注意是 add 进去的let j3 = new Set().add(j1).add(j2);j3.forEach(val =&gt; console.log(val)); // &#123;name: "aaa"&#125; &#123;age: 18&#125; 123456789let wSet = new WeakSet();let json = &#123; name: 'aaa', age: 18&#125;;// 建议存 jsonwSet.add(json);// 没有 size 没有 clear，有add, has, deleteconsole.log(wSet.size); // undefined ... Map相当于 Python 中的字典 12345678910// 问题，为对象添加了两次 key(是个对象)，结果却只有只有let data1 = &#123;a:1&#125;;let data2 = &#123;b:2&#125;;let obj = &#123;&#125;;// 如果 key 的对象，会自动调用 toString()，而这两个对象 toString() 后是一样的obj[data1] = 1;obj[data2] = 2;console.log(obj); // &#123; '[object Object]': 2 &#125; Map 数据结构，键的范围不限于字符串，对象也可以，是一种更完善的 Hash 结构的实现 1234const map = new Map([ ['a', 1], // 键是a ，值是1 ['b', 2]]); 12345let map = new Map();// 设置// map.set(key, value)console.log(map.set('name', 'aaa')); 12// 可以链式map.set('name', 'aaayang').set('age', 18); 123456789// map 的 key 可以是任意类型let json = &#123; a: 1&#125;;// key 可以是对象console.log(map.set(json, 'aaa'));// 获取// set 没有获取，只能循环console.log(map.get(json)); 123456map.delete('name'); // 返回true or false// 判断console.log(map.has('name'));// 清空map.clear(); 123456789101112131415161718192021// 默认 valuesfor(let [key,val] of map) &#123; console.log(key, val); // name aaa&#125;for(let key of map.keys()) &#123; console.log(key);&#125;for(let key of map.values()) &#123; console.log(key);&#125;for(let key of map.entries()) &#123; console.log(key);&#125;map.forEach((val, key) =&gt; &#123; console.log(val, key); // aaa name&#125;); 12345// WeakMap key 只能是对象let obj = &#123; name: 'aaa'&#125;;let weakMap = new WeakMap().set(obj, 'xxx'); 细节1234// 会认为 NaN 是一个东西let map = new Map();let a = map.set(NaN, '1').set(NaN, '2');console.log(a); // &#123;NaN =&gt; '2'&#125; 1234// 两个空对象就不是一个东西了let map = new Map();let a = map.set(&#123;&#125;, '1').set(&#123;&#125;, '2');console.log(a); // &#123;&#123;&#125; =&gt; '1', &#123;&#125; =&gt; '2&#125; 1// map 里面 key 的排列顺序永远是按照添加的顺序进行的 数值变化进制123// 0b 代表二进制let a = 0b11;console.log(a); // 3 123// 八进制let a = 0o11;console.log(a); // 0 Number Number.isNaN Number.isFinite，是否是数字 Number.isInteger，是否是整数 Number.parseInt Number.parseFloat Number.isSafeInteger(253)，是否是安全整数【-(253-1) ~ (2**53-1)】 Number.MAX_SAFE_INTEGER，最大安全整数 Number.MAX_VALUE Math.trunc(1.23)，截取，只保留整数部分 Math.sign，整数返回1，负数返回-1，0返回0，-0返回-0 幂运算123// 2 的 3 次方console.log(Math.pow(2,3)); // 8console.log(2**3); // 8 关于正则命名捕获12345let str = '2018-08-25';let reg = /(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/;let arr = str.match(reg);let &#123;year, month, daty&#125; = arr.groups; 12345678let reg = /^(?&lt;aaayang&gt;welcome)-\k&lt;aaayang&gt;$/;// let reg = /^(?&lt;aaayang&gt;welcome)-\1$/;let str = 'a-a';let str2 = 'welcome-welcome';console.log(reg.test(str));console.log(reg.test(str2)); 123456let str = '2018-08-25';let reg = /(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/;// let a = str.replace(reg, '$2$1$3');let a = str.replace(reg, '$&lt;year&gt;/$&lt;month&gt;/$&lt;day&gt;');console.log(a); 12345678let str = '2018-08-25';let reg = /(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/;let a = str.replace(reg, (...args) =&gt; &#123; let &#123;year, month, day&#125; = args[args.length-1]; return `$&#123;year&#125;/$&#123;month&#125;/$&#123;day&#125;`;&#125;);console.log(a); 123// s 修饰符让 . 代表所有let reg = /^\w.\w$/s;console.log(reg.test('w\nx')); // false]]></content>
      <categories>
        <category>JS 高级</category>
      </categories>
      <tags>
        <tag>ES2015</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[再说事件绑定]]></title>
    <url>%2F2019%2F06%2F27%2FaddEventListener%2F</url>
    <content type="text"><![CDATA[大家都清楚，常用的事件绑定有两种形式，一种是传统绑定，例如 oBtn.onclick = fn; 还有一种是通过事件监听，例如 oBtn.addEventListener(&#39;click&#39;, fn, false); 两种绑定方式最大的差异我相信大家也比较清楚，就是传统方式给同一元素绑定多个事件处理程序时生效的是最后的那个（后面的覆盖前面的），事件监听的形式给同一元素绑定多个不同的事件处理程序时都会生效。但是在具体使用时用什么方式绑？绑定在谁身上（是点击的当前元素还是父元素）？什么时候绑（是点击的时候绑还是程序加载的时候绑）？都是你需要关注的细节，这里我举了一个例子来说明这三个问题！ 基本需求 需求：点击添加按钮，把 input 框中的内容放入新创建的 li，并给 li 中添加删除按钮可以删除当前行，最后把 li 添加到 ul 中，如上图 代码实现： 123&lt;input type="text"&gt;&lt;button&gt;添加&lt;/button&gt;&lt;ul style="width: 200px;"&gt;&lt;/ul&gt; 123456789101112131415161718192021222324252627var oInput = document.querySelector('input');var oBtn = document.querySelector('button');var oUl = document.querySelector('ul');oBtn.onclick = function() &#123; // 创建 li var oLi = document.createElement('li'); // 给 li 添加内容 oLi.innerHTML = oInput.value; // 添加 li 到 ul oUl.appendChild(oLi); // 创建删除按钮 span var oBtn = document.createElement('span'); // 添加文字 oBtn.innerHTML = '删除'; // 添加删除按钮到 li oLi.appendChild(oBtn); // 每次点击时选择所有按钮，并绑定点击事件做删除操作 var aBtn = document.querySelectorAll('span'); for(var i = 0; i &lt; aBtn.length; i ++) &#123; aBtn[i].onclick = function() &#123; oUl.removeChild(this.parentNode); &#125;; &#125;&#125;; 问题重现上面删除当前列表的功能，我们是用普通的事件绑定形式(onclick)去做的，没有什么问题。有同学尝试用事件监听的形式(addEventListener)改写代码如下： 123456var aBtn = document.querySelectorAll('span');for(var i = 0; i &lt; aBtn.length; i ++) &#123; aBtn[i].addEventListener('click', function() &#123; oUl.removeChild(this.parentNode); &#125;);&#125; 点击添加按钮，增加了 2 个或大于 2 个元素，此时再删除非最后一个列表时（非最后一个还是非第一个取决于是用 appendChild 还是 insertBefore 插入的），却发现出现了错误！打开控制台报错信息如下（删除了一个不是 oUl 子元素的节点）： 问题分析第 1 次点击按钮添加完成后，会通过 var aBtn = document.querySelectorAll(&#39;span&#39;); 选择所有的删除按钮，绑定事件 第 2 次点击添加按钮完成后，会通过 var aBtn = document.querySelectorAll(&#39;span&#39;); 选择所有的删除按钮，绑定事件。问题就出在这里，选择所有删除按钮并绑定事件的操作，其实又会把之前已经绑定事件的元素再次绑定了一次。所以点击删除按钮时会发现 oUl.removeChild(this.parentNode); 执行了多次（取决于重复绑定了多少次），第 1 次执行时已经把当前 li 从 ul 中移除，下次再执行 oUl.removeChild(this.parentNode); 时其实 ul 中已经没有了这个 li，删除一个不存在的子节点就会报错！ 第 3 次点击添加按钮完成后，同理… 解决方案Way1: 使用普通的事件绑定形式（onclick） Way2: 对于同样的事件处理程序独立出去变成同一个函数，每次保证绑定的是同一个（函数），例如： 123456789var aBtn = document.querySelectorAll('span');for(var i = 0; i &lt; aBtn.length; i ++) &#123; // aBtn[i].removeEventListener('click', rm); // 这里就没有必要进行先解绑了，因为每次绑定的是同一个 rm，会覆盖掉之前的 aBtn[i].addEventListener('click', rm);&#125;function rm(e) &#123; // 这里也可以用 this.parentNode oUl.removeChild(e.target.parentNode);&#125; Way3: 其实前面每次添加列表就通过 querySelectorAll 重新选择所有删除按钮并绑定事件，本身就是一个糟糕的思路！其实只需要找到最新添加的那一个进行事件绑定就可以了，往前插入的话可以直接通过 var oBtn = document.querySelector(&#39;span&#39;); 找到最新添加的那个，往后插入的话代码如下： 1234var oBtn = document.querySelectorAll('span')[oUl.children.length-1];oBtn.addEventListener('click', function() &#123; oUl.removeChild(this.parentNode);&#125;); 除了上面通过元素选择的方式查找最新添加的那一个，最正确的方式其实是根本不用查找，它就在那里！每次添加列表的时候，当前创建的删除按钮就是最新的，直接给其绑定事件即可，这样无论是从效率，还是代码简洁度上都最佳，代码如下： 1234567var oBtn = document.createElement('span');// 给一个创建的元素单独绑定事件，而不是每次点击通过 querySelectorAll 选择的形式oBtn.addEventListener('click', function() &#123; oUl.removeChild(this.parentNode);&#125;);oBtn.innerHTML = '删除';oLi.appendChild(oBtn); Way4: 使用事件委托，推荐！ 1234567// 把事件绑定在父级上oUl.addEventListener('click', function(e) &#123; // 根据点击当前元素的名字（或其他）来判断是否是 span（即删除按钮），然后做相应的操作 if(e.target.nodeName.toLowerCase() === 'span') &#123; e.currentTarget.removeChild(e.target.parentNode); &#125;&#125;);]]></content>
      <categories>
        <category>Web API</category>
      </categories>
      <tags>
        <tag>addEventListener</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于数组塌陷]]></title>
    <url>%2F2019%2F06%2F23%2Fsplice%2F</url>
    <content type="text"><![CDATA[关于数组的方法有很多，splice 算是比较强大的一个，它能用来删除、添加、替换数组中的元素，实际开发中非常实用！ 基本语法123456// start: 从哪里开始，也支持负值，-n 相当于 arr.length - n// deleteCount: 要删除几个（可选）// item1, item2: 要添加进数组的元素（可选）// 返回值: 以数组的形式返回删除的那些元素array.splice(start, deleteCount, item1, item2); 代码演练删除：从第 2 位开始，删除 2 个 123var arr = ['apple', 'orange', 'banana', 'watermelon'];arr.splice(2, 2);console.log(arr); // ['apple', 'orange'] 添加：从第 2 位开始，删除 0 个，添加 🤣😎 123var arr = ['apple', 'orange', 'banana', 'watermelon'];arr.splice(2, 0, '🤣', '😎');console.log(arr); // ["apple", "orange", "🤣", "😎", "banana", "watermelon"] 替换：从第 2 项开始，删除 2 项并添加🍌和🍉 123var arr = ['apple', 'orange', 'banana', 'watermelon'];arr.splice(2, 2, '🍌', '🍉');console.log(arr); // ["apple", "orange", "🍌", "🍉"] 数组塌陷需求：利用 splice 删除数组中的指定元素 1234var arr = ['apple', 'orange', 'banana', 'watermelon'];// 从 0 开始删到最后，并不能指定删除某个元素arr.splice(0);console.log(arr); // [] 1234567// 删除指定的某个元素时就需要遍历，但最终的结果和我们想的不一样！var arr = ['apple', 'orange', 'banana', 'watermelon'];for(var i = 0; i &lt; arr.length; i ++) &#123; // 从第 i 个开始，删除 1 个 arr.splice(i, 1);&#125;console.log(arr); // ["orange", "watermelon"] 上面的写法删不干净，因为 splice 每删除一个元素就会改变原来数组的索引以及长度，而 i 的值永远是个递增的状态，代码分析如下（建议断点调试）： 第 1 次 i 等于 0， arr.splice(0, 1) 后的结果是 [‘orange’, ‘banana’, ‘watermelon’]，arr 的 length 变为了 3； 第 2 次 i 等于 1，arr.splice(1, 1) 后的结果是 [‘orange’, ‘watermelon’]，arr 的 length 变为了 2； 第 3 次 i 等于 2， i &lt; arr.length 条件为假，结束循环； 解决方法需求：解决上面利用 splice 删除不干净的问题！ 每次删除数组的第一个元素 1234567var arr = ['apple', 'orange', 'banana', 'watermelon'];for(var i = 0; i &lt; arr.length; i ++) &#123; arr.splice(i, 1); // 每次删除后进行 i--，这样就能保证删除的永远都是数组的第一个元素（说第一个元素不太准确，取决于i的值变化到哪里了） i --;&#125;console.log(arr); // [] 1234// 原理和上面一样，永远删除数组最前面那个元素while(arr.length) &#123; arr.splice(0, 1);&#125; 倒着删 123456// 可以通过断点调试查看代码执行过程var arr = ['apple', 'orange', 'banana', 'watermelon'];for(var i = arr.length - 1; i &gt;= 0; i --) &#123; arr.splice(i, 1);&#125;console.log(arr); 使用场景数组去重：每次用当前元素和后面的所有元素进行比较，如果相同就利用 splice 删除掉后面相同的那个元素 j（或当前的 i） 12345678910var arr = ['apple', 'apple', 'apple', 'orange', 'apple'];for(var i = 0; i &lt; arr.length; i ++) &#123; for(var j = i + 1; j &lt; arr.length; j ++) &#123; if(arr[i] === arr[j]) &#123; arr.splice(j, 1); // 解决 splice 后带来的数组塌陷问题 j --; &#125; &#125;&#125; 题目测试需求：在数组 var arr = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]; 每一项的前面添加 @ 字符 123456// Way1for(var i = arr.length - 1; i &gt;= 0; i --) &#123; arr.splice(i, 0, '@');&#125;console.log(arr); // ["@", "a", "@", "b", "@", "c", "@", "d"] 12345678// Way2for(var i = 0; i &lt; arr.length; i ++) &#123; arr.splice(i, 0, '@'); // ['@', 'a', 'b', 'c', 'd'] 下次 'b' 的索引已经是 2 了，需要再次进行 i++ i++;&#125;console.log(arr); // ["@", "a", "@", "b", "@", "c", "@", "d"] 1234567// Way3for(var i = 0; i &lt; arr.length; i ++) &#123; arr.splice(i, 1, '@'+arr[i]);&#125;arr = arr.join('').split('');console.log(arr); // ["@", "a", "@", "b", "@", "c", "@", "d"] 其他方法用 splice 删除指定元素的目的，换句话说无非是想得到想要的元素，其实数组也提供了 filter 方法，可以帮我们筛选出想要的数组元素！ 12345// 具体使用看文档，这里不再啰嗦了！var arr = ['apple', 'orange', 'banana', 'watermelon'];// 返回一个新的、由通过测试的元素组成的新数组var newArr = arr.filter(word =&gt; !word);console.log(newArr); // []]]></content>
      <categories>
        <category>JS 基础</category>
      </categories>
      <tags>
        <tag>数组塌陷</tag>
        <tag>splice</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[标记语句]]></title>
    <url>%2F2019%2F06%2F21%2Fjs-label%2F</url>
    <content type="text"><![CDATA[之前课上做过一个计算器的案例，选择 1、2、3、4 后会对后面填入的数字进行对应的运算并弹出结果，点击确定后又会回到初始界面。如果用户在初始界面输入的是数字 5，点击确定就会进行退出操作，不再回到初始界面了！ 可实现代码如下： 123456789101112131415161718192021222324252627282930313233343536373839// 输入内容并返回function inputValue() &#123; var num1 = parseFloat(prompt('请输入第一个数：')); var num2 = parseFloat(prompt('请输入第二个数：')); return [num1, num2];&#125;// 相当于创建了一个开关，默认开启状态var bBar = true;do &#123; var opration = prompt('请选择要进行的运算：\n1. 加法运算\n2. 减法运算\n3. 乘法运算\n4. 除法运算\n5. 退出'); opration = parseInt(opration); switch (opration) &#123; case 1: var arr = inputValue(); alert('相加的结果是：' + (arr[0] + arr[1])); break; case 2: var arr = inputValue(); alert('相减的结果是：' + (arr[0] - arr[1])); break; case 3: var arr = inputValue(); alert('相乘的结果是：' + (arr[0] * arr[1])); break; case 4: var arr = inputValue(); alert('相除的结果是：' + (arr[0] / arr[1])); break; case 5: alert('退出...'); // 如果用户输入的是 5，则关闭开关，那下次的循环 bBar 就是 false，while(bBar) 也就不会执行了 bBar = false; // 默认只会退出当前的 switch break; &#125;&#125; while (bBar); 其实上面退出循环的操作也可以使用标记语句来完成，感兴趣的同学可以点击链接进去学习下，修改后的代码如下： 123456789101112// Step1: 指定标记点loopPoint:do &#123; // ... switch (opration) &#123; // ... case 5: alert('退出...'); // Step2: 跳到标记点 break loopPoint; &#125;&#125; while (true); 下面是测试代码： 1234567891011121314var num = 0;for (var i = 0; i &lt; 6; i++) &#123; for (var j = 0; j &lt; 6; j++) &#123; // 当 i 等于 3 并且 j 等于 3 时，会直接 break 里面一层的 for 循环，继续外面的 for 循环 // 当 i 等于 3 时，导致 j 值为 [3,6) 之间的没有进行，num 少加了 3 次 // 所以最终的 num 值为 33 if (i == 3 &amp;&amp; j == 3) &#123; // 跳出当前循环 break; &#125; num++; &#125;&#125;console.log(num); // 打印结果是多少？ 1234567891011121314151617var num = 0;outerMark:for (var i = 0; i &lt; 6; i++) &#123; // 外层 for 循环，i 等于 0 时，里层执行完 6 次 // 外层 for 循环，i 等于 1 时，里层执行完 6 次 // 外层 for 循环，i 等于 2 时，里层执行完 6 次 // 外层 for 循环，i 等于 3 时，里层循环 j 执行了 3 次 [0, 3) // 最终的 num 值是 21 for (var j = 0; j &lt; 6; j++) &#123; if (i == 3 &amp;&amp; j == 3) &#123; // 跳出到 outerMark 标记的地方 break outerMark; &#125; num++; &#125;&#125;console.log(num); // 打印结果是多少？ 123456789101112var num = 0;outerMark:for (var i = 0; i &lt; 6; i++) &#123; for (var j = 0; j &lt; 6; j++) &#123; if (i == 3 &amp;&amp; j == 3) &#123; // 跳出外层的当前循环，继续下次 i++ continue outerMark; &#125; num++; &#125;&#125;console.log(num); // 打印结果是多少？]]></content>
      <categories>
        <category>JS 基础</category>
      </categories>
      <tags>
        <tag>标记语句</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端布局那点事]]></title>
    <url>%2F2019%2F06%2F07%2Fmobile-layout%2F</url>
    <content type="text"><![CDATA[作为前端，在今天来说，移动端布局必须是一件必知必会的事情，重要程度不言而喻！这里我总结了同一案例下不同布局的写法（原理就不再赘述，直接右键查看源代码即可），方便大家回忆。 百分比布局特点：宽度百分比、高度写死（750的设计稿下一般除以2）。缺点：高度或文字很难自适应。 举例 Flexible 布局特点：宽度弹性布局、高度写死。缺点：高度或文字还是很难自适应。优点：灵活、简洁。 举例 REM 布局原理：不同尺寸屏幕下给根元素设置不同的文字大小（利用媒体查询或JS），宽、高、间距…都统一使用 REM 单位。使用：量取到的设计稿尺寸除以根元素字体大小（基准值）即可，例如使用 flexible.js，150px 用 rem 表示就是 2rem。优点：高度和文字可以自适应。 注意 em 是相对于当前元素的字体大小（如果当前元素没有设置字体大小那就是继承过来的大小）的单位。 举例 响应式布局原理：利用 bootstrap 的栅格系统（核心还是媒体查询），不同尺寸下设置不同的样式，实现 PC 和移动端布局使用同一套代码！场景：适用于相对简单的页面，复杂页面下的响应式开发成本太高。]]></content>
      <categories>
        <category>移动 Web 开发</category>
      </categories>
      <tags>
        <tag>移动端布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[steps(number[, end | start])]]></title>
    <url>%2F2019%2F05%2F31%2Fsteps%2F</url>
    <content type="text"><![CDATA[缘起CSS3 中用于设置动画的 animation 语法如下： 1animation: name duration timing-function delay iteration-count direction; 其中，timing-function 取值如下： 1timing-function: linear / ease / ease-in / ease-out / ease-in-out / cubic-bezier() / steps() 上面 timing-function 的取值除了 steps() 都代表补间动画（线性动画），steps() 代表帧动画，有时候一些动画效果必须用它才能实现，例如上面图奔跑的动物是我们曾经做过的动画，就是通过 steps() 配合改变雪碧图（1600px宽）的位置实现的，代码如下： 12345678@keyframes aniSelf &#123; 0% &#123; background-position: 0 0; &#125; 100% &#123; background-position: -1600px 0; &#125;&#125; 123.wolf&#123; animation: aniSelf 1s steps(8) infinite;&#125; 上面代码确实能实现预期的效果，但不知道大家有没有这样一个疑问：当背景位置为 background-position: -1600px 0; 时，图片在盒子中应该是看不到的才对（因为图片总共是1600px，这样刚好是图片的最右边卡到盒子的最左边），但为什么动画还能正常跑起来，而没有出现空白的问题呢？ 要解答上面的疑问，我们就要明白关于 steps(number[, end | start]) 参数的含义，第一个参数大家都知道是什么意思，第二个参数是可选的，表示在每个间隔的起点或是终点发生阶跃变化，如果忽略，默认是 end。 看完上面加粗部分的定义，我不知道你作何感想…😣 我的感性认识我的理解：steps() 第二个参数如果是 end 则代表忽略结束帧，如果是 start 则代表忽略开始帧，如何理解这句话呢？ 上面是一张 50 * 200 的图片，作为 50 * 50 盒子的背景图，我想实现在 hover 盒子的时候背景从 A 变化到 A 的逐帧动画。由于我们知道 steps(4, end) 时会忽略最后一帧，动画走完时没有 forwards，又会回到初始状态，故可以用以下方法来实现： 1234567891011121314151617181920.box &#123; border: 1px solid #333; width: 50px; height: 50px; background: url(./images/steps.png) no-repeat;&#125;.box:hover &#123; /* 分为 4 步来完成，会忽略最后一步 background-position: 0 -150px; 到 background-position: 0 -200px; 这个区间！ */ animation: way1 2s steps(4);&#125;@keyframes way1 &#123; 0% &#123; background-position: 0 0; &#125; 100% &#123; background-position: 0 -200px; &#125;&#125; 上面代码其实就是和我们课上实现动物运动的代码是一样的思路，那如果我把上面的代码改为 steps(4, start) 会怎样的，根据我们之前的结论，start 会忽略第一帧，也就是 hover 上的一刹那就会定位到 B，然后也会走 background-position: 0 -150px; 到 background-position: 0 -200px; 最后一帧这个区间，即会出现空白，最后又回到初始状态 A，可见，这并不是我们所需要的。 我就想用 start如果实在想用 start 可以改写代码如下： 1234567891011121314/* Step1: 分为 3 步走 */.box:hover &#123; animation: way1 2s steps(3, start);&#125;/* Step2: 最后一帧的位置改成严丝合缝的最后一样图片 */@keyframes way1 &#123; 0% &#123; background-position: 0 0; &#125; 100% &#123; background-position: 0 -150px; &#125;&#125; 注意：以上代码虽然能实现 hover 时背景从 A、B、C、D 到 A 的变换，但并不推荐这样做，因为 hover 的一刹那 A 到 B 的变换是没有动画的（逐帧动画也是动画） 其他写法注意看我的注释部分！ 123456789101112131415161718192021.box &#123; border: 1px solid #333; width: 50px; height: 50px; /* Step1: 背景重复！ */ background: url(./images/steps.png) repeat-y;&#125;.box:hover &#123; /* Step2: 这时候 steps 第二个参数是 start or end 只是开始时第一帧有没有动画的区别，并不会出现空白了，因为背景平铺了 */ animation: way1 2s steps(4);&#125;@keyframes way1 &#123; 0% &#123; background-position: 0 0; /* A */ &#125; 100% &#123; background-position: 0 -200px; /* A */ &#125;&#125; 123456789/* 设置是这样的写法 */@keyframes way1 &#123; 0% &#123; background-position: 0 200px; /* A */ &#125; 100% &#123; background-position: 0 0px; /* A */ &#125;&#125; 其他属性对 step 的影响当 steps() 第二个参数为 end 时会忽略结束帧，但 animation-fill-mode: forwards; 是会影响 steps() 的表现的，例如我想让一个盒子从 0 运动到 100，可写代码如下： 12345678910111213141516.box&#123; width: 100px; height: 100px; background-color: pink; position: absolute; top: 70px; animation: move 3s steps(5) forwards;&#125;@keyframes move &#123; 0%&#123; left: 0; &#125; 100%&#123; left: 100px; &#125;&#125; 结果如下： 说好的 steps() 第二个参数为 end 时会忽略最后一帧，但最后却停在了 100px 的位置上，说明 animation-fill-mode 为 forwards 时会对 steps() 帧动画造成影响，以 forwards 为准！当然你如果又设置了 infinite，那 forwards 也就“失效”了… 再来个小栗子点我去远方]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>steps()</tag>
        <tag>帧动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据类型检测的 N 中方式]]></title>
    <url>%2F2019%2F05%2F26%2Fjudge-type%2F</url>
    <content type="text"><![CDATA[从 JS 基础第一天开始，我们就学习了如何使用 typeof 去判断数据类型，学习构造函数时我们又说了 constructor 以及 instanceof 也可以去进行类型检测，到 JS 高级时还讲了 Object.prototype.toString() 方法也可以去判断数据类型，那么问题来了，这么多方法它们之间有什么异同吗？不同场景下该怎样使用才比较合适呢？ 数据类型知多少既然要检测数据类型，首先要明确 JS 中的数据类型有以下 7 种： 简单数据类型：Number、String、Boolean、Null、Undefined、Symbol（ES6） 复杂数据类型：Object（包括函数、数组、对象、正则、日期等） typeoftypeof 它的使用方法有两种： 1234// 可以不带括号，直接跟数据console.log(typeof 36);// 也可以带括号console.log(typeof(36)); typeof 的返回值永远是一个全小写字符串，例如： 1console.log(typeof (typeof (typeof 66))); // string typeof 的返回值除了上面 7 种数据类型外，还多了一个 function，例如： 12function test() &#123;&#125;console.log(typeof test); // function 总结： 除了 Null（返回 object），typeof 对于基本数据类型都能返回正确的结果 除了 Function（返回 function），typeof 对于复杂数据类型都返回 object 缺点： typeof 对于复杂数据类型的处理，只能返回处于原型链最顶端的 Object 类型，不能细分 constructor新建一个（构造）函数 Fn 时，JS 引擎会给自 Fn 添加一个 prototype 属性，prototype 下又有一个 constructor 指向 Fn 函数，可用如下代码表示： 12function Fn() &#123;&#125;console.log(Fn.prototype.constructor === Fn); // true 当我们执行 new Fn 来创建 Fn 的实例后，这个实例的 constructor 也就指向 Fn，如下： 1234function Fn() &#123;&#125;var f1 = new Fn;// f1 下本没有 constructor，自己没有则会通过原型链向上查找到 Fn.prototype 上console.log(f1.constructor === Fn); // true 如此一来我们就可以通过 constructor 来判断某个实例对象具体的类型（来源），例如上面代码从原型链的角度来说 f1 的类型（来源）就是 Fn。 同样的道理，其他数据的也可以通过 constructor 来判断具体的类型，它可以解决 typeof 对应复杂数据类型的判断无能为力的问题，测试如下： 1234567console.log([].constructor === Array); // trueconsole.log(new Date().constructor === Date); // trueconsole.log(new Function().constructor === Function);console.log(''.constructor === String);console.log(true.constructor === Boolean);console.log(new Error().constructor === Error);console.log(document.constructor === HTMLDocument); constructor 的小问题： null 和 undefined 上没有 constructor 这属性，不能通过 constructor 来判断 当 prototype 被不小心重写后，会导致 constructor 判断不准确的问题，例如： 1234567891011function Test() &#123;&#125;var t1 = new Test;console.log(t1.constructor === Test); // true// 重写原型会导致 Test.prototype.constructor 指向不正确// 当然对应的实例对象在用 constructor 去判断类型的时候也就会指向不正确Test.prototype = &#123; showAge: function() &#123;&#125;&#125;;var t2 = new Test();console.log(t2.constructor === Test); // false instanceof它主要用来判断一个对象是否能够通过原型链找到另一个对象的原型，什么意思呢？例如： 12// [] 可以通过 __proto__ 找到 Array.prototype，所以结果是 trueconsole.log([] instanceof Array); 123// [].__proto__.__proto__ === Object.prototype// 说明 [] 也是可以通过原型链找过 Object 的原型，所以下面结果也是 trueconsole.log([] instanceof Object); 所以大家也看到了，instanceof 并不能准确的找到某个实例的类型，但它相对于 constructor 有这样一个特点，即便构造函数的原型被重写后，实例也能通过 instanceof 去判断自己的类型，例如： 1234567function Test() &#123;&#125;Test.prototype = &#123; showAge: function() &#123;&#125;&#125;;var t1 = new Test();console.log(t1 instanceof Test); // trueconsole.log(t1 instanceof Object); // 当然对应顶级对象 Object 也是 true，还是不能准确判断就是 Test 类型 instanceof 还有另外一个问题需要你注意的，当页面中引入 iframe 时，实例化 iframe 窗口下的对象和当前窗口下相对应的构造函数进行 instanceof 判断时也会出现问题。例如： 1234567891011var oFrame = document.createElement('iframe');document.body.appendChild(oFrame);// ifame 窗口下实例化的 arrvar arr = new window.frames[0].Array;console.log(arr instanceof window.frames[0].Array); // trueconsole.log(arr instanceof Array); // false// 针对上面的问题 ES5 提供了 Array.isArray() 这个方法进行判断console.log(Array.isArray(arr)); // true Object.prototype.toString他返回的信息格式是 [object Xxx]（注意第一个 X 是大写），对于 {} 直接调用 toString 既可以返回 [object Object]，其他类型需要借助 call/apply 方法去调用，例如： 12345678910111213// 也可以把 Object.prototype 替换成 &#123;&#125;// 因为调用 &#123;&#125; 下的 toString() 方法，自己没有会通过原型链去 Object.prototype 上面找console.log(Object.prototype.toString.call(233)); // [object Number]console.log(Object.prototype.toString.call('233')); // [object String]console.log(Object.prototype.toString.call(true)); // [object Boolean]console.log(Object.prototype.toString.call(null)); // [object Null]console.log(Object.prototype.toString.call(undefined)); // [object Undefined]console.log(Object.prototype.toString.call(Symbol())); // [object Symbol]console.log(Object.prototype.toString.call([])); // [object Array]console.log(Object.prototype.toString.call(new Function)); // [object Function]console.log(Object.prototype.toString.call(new Date)); // [object Date]console.log(Object.prototype.toString.call(new RegExp)); // [object RegExp] 可见 Object.prototype.toString() 简直太好用啦，推荐使用！]]></content>
      <categories>
        <category>JS 高级</category>
      </categories>
      <tags>
        <tag>判断数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据在内存中的存储形式]]></title>
    <url>%2F2019%2F05%2F25%2Fsnake-question%2F</url>
    <content type="text"><![CDATA[学习贪吃蛇时，往蛇身体增加最后一节，当时代码是直接这样写的 this.body.push({ x: last.x, y: last.y, color: last.color })，有些同学问 last 这个变量保存的数据和 { x: last.x, y: last.y, color: last.color } “长的一样”，为什么不能直接 this.body.push(last) 呢？ 基本数据类型存储要说清楚上面的问题，首先大家要明白不同数据类型在内存中的存储形式是怎样的。我们都知道 JS 中的数据类型分为 2 大类，分别是： 基本数据类型：Number、String、Boolean、Null、Undefined、Symbol(ES6) 复杂数据类型：Object(包括数组、对象、函数、正则) 其中基本数据类型存储在栈内存中，他们是按值存放的，例如： 1234var age1 = 18;var age2 = age1;age2 = 20;console.log(age1, age2); // 18 20 上面代码在内存中的表现形式如下： 复杂数据类型存储复杂数据类型的真实数据是存放在堆内存中的，变量保存的只是在栈内存中的一个地址，这个地址指向堆内存中数据。例如： 1234var obj1 = &#123; age: 18 &#125;;var obj2 = obj1;obj2.age = 20; // obj2 是改变堆内存中的同一份数据console.log(obj1.age); // 所以 obj1 的数据也被影响了，结果是 20 上面代码在内存中的表现形式如下： 解释贪吃蛇的问题讲贪吃蛇时，关于蛇如何吃到食物我们说了这么一段话：在蛇运动时，判断蛇头的坐标是否与食物的坐标吻合，如果吻合，则往蛇身体后增加一节，然后再随机食物的坐标即可，代码如下： 12345678if (headX === food.x &amp;&amp; headY === food.y) &#123; // Step1: 获取蛇的最后一节 var last = this.body[this.body.length - 1]; // Step2: 添加到身体的最后 this.body.push(&#123; x: last.x, y: last.y, color: last.color &#125;); // Step3: 随机随机食物坐标 food.render(map);&#125; 如果直接 this.body.push(last) 的话，相当于每次添加的还是堆内存中的同一个 last，那在下次 move 修改数据的时候就会相互影响，无论你往后面 push 多少项 last，在修改到最前面的 three 时也会把后面的给修改掉（因为都是堆内存中的同一份数据），所以你看到的结果是后面的数据都是重复的，对应到页面上也就是最后一节的元素都是覆盖在一起的。测试代码如下： 12345678910var one = &#123;x: 26, y: 14, color: "red"&#125;;var two = &#123;x: 25, y: 14, color: "blue"&#125;;var three = &#123;x: 24, y: 14, color: "blue"&#125;;var arr = [one, two, three, three];for (var i = arr.length - 1; i &gt; 0; i--) &#123; arr[i].x = arr[i - 1].x; arr[i].y = arr[i - 1].y;&#125;console.log(arr); 该如何解决12345678910111213141516171819var arr = [ &#123;x: 26, y: 14, color: "red"&#125;, &#123;x: 25, y: 14, color: "blue"&#125;, &#123;x: 24, y: 14, color: "blue"&#125;];var last = arr[arr.length - 1];// 每次造一个全新的对象var newObj = &#123; x: last.x, y: last.y, color: last.color &#125;;// 或者拷贝原来的对象// var newObj = JSON.parse(JSON.stringify(last));arr.push(newObj);for (var i = arr.length - 1; i &gt; 0; i--) &#123; arr[i].x = arr[i - 1].x; arr[i].y = arr[i - 1].y;&#125;console.log(arr);]]></content>
      <categories>
        <category>JS 高级</category>
      </categories>
      <tags>
        <tag>贪吃蛇</tag>
        <tag>引用类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS 中的隐式转换]]></title>
    <url>%2F2019%2F05%2F24%2Finvisible-transform%2F</url>
    <content type="text"><![CDATA[JS 中有个“经典”的面试题：请问 [] == ![] 的结果是什么？一眼看上去肯定是 false，但结果却是 true，要清楚为什么是这样，就要了解 JS 在进行数据比较时的隐式转换规则是怎样的？ 注：除了对本问题的解释部分，其他都来自 JavaScript 高级程序设计，建议看书！我这里摘出了其中两点，来作为对常见问题的解释，其实还有其他细节或特殊注意的地方，建议在精力充沛的情况下可以自己去探索！ 相等操作符规则在转换不同的数据类型时，相等和不相等操作符遵循下列基本规则： 1 . 如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值，false 转换为 0，而 true 转换为 12 . 如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值3 . 如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf()方法，用得到的基本类型值按照前面的规则进行比较 这两个操作符在进行比较时又要遵循下列特殊的情况： 1 . null 和 undefined 是相等的2 . 要比较相等性之前，不能将 null 和 undefined 转换成其他任何值3 . 如果有一个操作数是 NaN，则相等操作符返回 false，而不相等操作符返回 true。重要提示：即使两个操作数都是 NaN，相等操作符也返回 false；因为按照规则，NaN 不等于 NaN4 . 如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回 true；否则，返回 false 关系操作符规则当关系操作符的操作数使用了非数值时，也要进行数据转换或完成某些奇怪的操作。以下就是相应的规则： 1 . 如果两个操作数都是数值，则执行数值比较2 . 如果两个操作数都是字符串，则比较两个字符串对应的字符编码值3 . 如果一个操作数是数值，则将另一个操作数转换为一个数值，然后执行数值比较4 . 如果一个操作数是对象，则调用这个对象的 valueOf()方法，用得到的结果按照前面的规则执行比较。如果对象没有 valueOf()方法，则调用 toString()方法，并用得到的结果根据前面的规则执行比较5 . 如果一个操作数是布尔值，则先将其转换为数值，然后再执行比较 解释 [] == ![]1[] == ![] Step1: ! 的优先级比 == 高，先执行 ![]，除了 null、undefined、’’、NaN、0 都是 true，所以 ![] 是 false 1[] == false Step2: 参考相等操作符比较的第 1 条规则，如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值，故结果如下： 1[] == 0 Step3: 参考相等操作符比较的第 3 条规则，调用对象的 valueOf() 方法得到原始值，并将原始值转换为数字结果如下： 1Number([].valueOf()) == 0]]></content>
      <categories>
        <category>JS 基础</category>
      </categories>
      <tags>
        <tag>隐式转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[触发全选按钮的几种思路]]></title>
    <url>%2F2019%2F05%2F22%2Fselect-all%2F</url>
    <content type="text"><![CDATA[需求：点击全选，选中上面所有的列表项；点击列表项中的每一个水果，如果有未选中则取消全选按钮，如果都选中了则激活全选按钮。 常规操作点击每个列表选项时，遍历所有列表选项并检查是否有未选中的，如果有则可以确定全选按钮的状态为未选中，否则全选按钮置为选中。 1234567891011121314151617181920212223242526272829303132var oAllInput = document.querySelector('#all');var aInput = document.querySelectorAll('ul input');// 点击全选 input 时根据自己的状态来控制其他列表项的 inputoAllInput.onchange = function() &#123; for(var i = 0; i &lt; aInput.length; i ++) &#123; aInput[i].checked = this.checked; &#125;&#125;;// 每次点击每一个列表项的 input 时，判断全选的 input 是否需要被选中for(var i = 0; i &lt; aInput.length; i ++) &#123; aInput[i].onclick = function() &#123; if (!this.checked) &#123; // 如果当前点击的按钮未选中，那就可以直接确定全选按钮的状态了 oAllInput.checked = false; // 也就没有必要进行下去了 return; &#125; var bBar = true; for(var i = 0; i &lt; aInput.length; i ++) &#123; // 发现有一个没选中的 if(!aInput[i].checked) &#123; bBar = false; // 发现有一个没选中的也就可以断定 oAllInput 的状态了，就没有必要再进行下去了 // 当然你不写 break 逻辑上也是对的，只是存在性能浪费 break; &#125; &#125; oAllInput.checked = bBar; &#125;;&#125; 注意细节思路和上面一样，下面的写法也是可以的，但有一点需要注意：点击列表中的每一项进行循环时，碰到未选中的一定要跳出循环，不然前面全选按钮的状态都会被最后一个按钮的状态所覆盖。 12345678910111213141516171819for (var i = 0; i &lt; aInput.length; i++) &#123; aInput[i].onclick = function () &#123; if (!this.checked) &#123; // 如果当前点击的按钮未选中，那就可以直接确定全选按钮的状态了 oAllInput.checked = false; // 也就没有必要进行下去了 return; &#125; for (var i = 0; i &lt; aInput.length; i++) &#123; if (!aInput[i].checked) &#123; oAllInput.checked = false; // 这里的 break 是必须要加的！不然全选按钮的状态永远是以最后一个的选中状态为准，这并不是我们所希望的 break; &#125; else &#123; oAllInput.checked = true; &#125; &#125; &#125;;&#125; 其他方法每次点击列表中的按钮时，获取所有已选中 input 的长度，并判断已选中 input 的 length 是否等于所有 input 的 length，如果相等，就可以激活全选按钮啦，否则则取消全选。 1234567891011for (var i = 0; i &lt; aInput.length; i++) &#123; aInput[i].onclick = function () &#123; var aInputChecked = document.querySelectorAll('ul input:checked'); // 已选中 length 等于所有 length 就证明全选中了，也就可以激活全选按钮啦 if (aInputChecked.length === aInput.length) &#123; oAllInput.checked = true; &#125; else &#123; oAllInput.checked = false; &#125; &#125;;&#125;]]></content>
      <categories>
        <category>Web API</category>
      </categories>
      <tags>
        <tag>全选</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排他思想]]></title>
    <url>%2F2019%2F05%2F21%2Fkill-other%2F</url>
    <content type="text"><![CDATA[上课我们在做点击当前按钮高亮，其他按钮重置为默认颜色的需求时，用到了“排他思想”，思路是：第一步，先干掉所有的；第二步，再操作自己的，简单明了，相信大家都比较清楚了！这里我再给大家做个总结，顺便再拓展一下其他的实现思路 ~ 排完思想需求：有 5 个按钮，点击当前按钮变红，其他按钮恢复默认颜色 123456&lt;!-- HTML 结构 --&gt;&lt;button&gt;1&lt;/button&gt;&lt;button&gt;2&lt;/button&gt;&lt;button&gt;3&lt;/button&gt;&lt;button&gt;4&lt;/button&gt;&lt;button&gt;5&lt;/button&gt; 123456789101112var aBtn = document.querySelectorAll('button');for(var i = 0; i &lt; aBtn.length; i ++) &#123; aBtn[i].onclick = function() &#123; // Step1: 先干掉所有人，“排完” for(var i = 0; i &lt; aBtn.length; i ++) &#123; aBtn[i].style.backgroundColor = ''; &#125; // Step2: 再操作自己的 this.style.backgroundColor = 'red'; &#125;;&#125; 排兄思想1234567&lt;script src="https://cdn.bootcss.com/jquery/3.4.0/jquery.min.js"&gt;&lt;/script&gt;&lt;script&gt;$("button").on("click", function() &#123; // 先操作自己的，再干掉所有的兄弟，“排兄” $(this).css("background", "red").siblings().css("background", "");&#125;);&lt;/script&gt; 排上思想1234567891011121314var aBtn = document.querySelectorAll('button');var prev = 0;for (var i = 0; i &lt; aBtn.length; i++) &#123; aBtn[i].index = i; aBtn[i].onclick = function () &#123; // Step1: 先干掉上一个，“排上” aBtn[prev].style.backgroundColor = ""; // Step2: 再操作自己的 this.style.backgroundColor = 'red'; // Step3: 操作完别忘了把自己也变成“上一个” prev = this.index; &#125;;&#125;]]></content>
      <categories>
        <category>Web API</category>
      </categories>
      <tags>
        <tag>排他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[认清 Node.appendChild()]]></title>
    <url>%2F2019%2F05%2F19%2FappendChild%2F</url>
    <content type="text"><![CDATA[Node.appendChild() 方法用于将一个节点添加到指定父节点的子节点列表的末尾，但在具体使用时还有其他一些需要我们关注的细节，以及对应的应用场景。 常规操作大家都清楚 appendChild 可以把创建好的元素插入到另一个元素内容的最后面，常规操作如下： 123456// 创建元素var oDiv = document.createElement('div');// 给创建好的元素加点内容oDiv.innerHTML = 'hello world';// 添加到 body 里面document.body.appendChild(oDiv); 需要注意上面代码必然没有任何问题，但这里还有一点需要大家注意的是，appendChild 在插入已存在元素的时候其实是做了两件事的： 先把原来已存在的元素删除 再进行后续的添加操作 具体是什么意思呢？大家看下面的例子就清楚了。需求：每次点击按钮把上面 ul 中的第一个元素移动到下面的 ul 中： 1234567891011121314151617181920&lt;ul id="ul1"&gt; &lt;li&gt;aaa&lt;/li&gt; &lt;li&gt;bbb&lt;/li&gt; &lt;li&gt;ccc&lt;/li&gt; &lt;li&gt;ddd&lt;/li&gt;&lt;/ul&gt;&lt;button id="btn"&gt;插入下面&lt;/button&gt;&lt;ul id="ul2"&gt;&lt;/ul&gt;&lt;script&gt;// 选择元素var oUl1 = document.querySelector('#ul1');var oBtn = document.querySelector('#btn');var oUl2 = document.querySelector('#ul2');oBtn.onclick = function() &#123; var oLi = oUl1.children[0]; // 每次点击按钮确实在 oUl2 中添加了一个新的元素，但同时 oUl1 中也相应少了这个元素 // 所以 appendChild 时相当于偷偷帮我们做了这么一步操作：oUl1.removeChild(oLi); oUl2.appendChild(oLi);&#125;;&lt;/script&gt; 实际应用好，现在我们清楚了当用 appendChild 插入已存在元素时会先删除之前再进行插入，那明白这个特性有什么实际的用处吗？答案是肯定的。例如下面一个需求，点击按钮，根据元素中的数字大小对这组元素进行排序： 123456789&lt;!-- HTML 结构 --&gt;&lt;ul id="ul1"&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;4&lt;/li&gt;&lt;/ul&gt;&lt;button id="btn"&gt;点击&lt;/button&gt; 123456789101112131415161718192021222324252627282930313233// 选择元素var oUl1 = document.querySelector('#ul1');var aLi = oUl1.querySelectorAll('li');var oBtn = document.querySelector('#btn');// 把伪数组 aLi 中的每一项都放到数组里面，目的是为了进行排序var arr = [];for(var i = 0; i &lt; aLi.length; i ++) &#123; arr.push(aLi[i]);&#125;oBtn.onclick = function () &#123; // 这就是我们熟悉的冒泡排序，你还记得吗 for (var i = 0; i &lt; arr.length - 1; i++) &#123; // 需要走 arr.length - 1 轮 for (var j = 0; j &lt; arr.length - i - 1; j++) &#123; // 每轮比较 arr.length - i - 1 次 var prevNum = parseFloat(arr[j].innerText); var nextNum = parseFloat(arr[j + 1].innerText); if (prevNum &gt; nextNum) &#123; // 不能对伪数组中其中一些直接赋值，例如：aLi[j] = aLi[j+1]，所以需要把伪数组转换成数组后再进行排序 var temp = null; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125; // 此时 arr 中装的已经是排好序的一堆 li 元素了 for(var i = 0; i &lt; arr.length; i ++) &#123; // 分别把排好序的数组中的每个元素插入到 oUl1 内容的最后 // 注意每次插入的同时也会把 oUl1 中那个相同的元素先给干掉，所以 oUl1 中也就不会存在重复元素的问题 oUl1.appendChild(arr[i]); &#125;&#125;; 优化代码这里优化相关的代码我们并没有学（不建议查看），我这里也提供一种较佳实战，是给你们以后看的（甚至是工作后），优化后的 JS 代码如下： 123456789101112const oUl1 = document.querySelector('#ul1');const aLi = oUl1.querySelectorAll('li');const oBtn = document.querySelector('#btn');oBtn.addEventListener('click', () =&gt; &#123; // Array.from 可以把伪数组转成数组，sort 的原理就是上面写的冒泡排序 Array.from(aLi).sort((li1, li2) =&gt; &#123; return parseFloat(li1.innerText) - parseFloat(li2.innerText); &#125;).forEach(li =&gt; &#123; oUl1.appendChild(li); &#125;)&#125;);]]></content>
      <categories>
        <category>Web API</category>
      </categories>
      <tags>
        <tag>appendChild</tag>
      </tags>
  </entry>
</search>
