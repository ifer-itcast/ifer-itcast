<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[关于移动端布局那点事]]></title>
    <url>%2F2019%2F06%2F07%2Fmobile-layout%2F</url>
    <content type="text"></content>
      <categories>
        <category>移动 Web 开发</category>
      </categories>
      <tags>
        <tag>移动端布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[steps(number[, end | start])]]></title>
    <url>%2F2019%2F05%2F31%2Fsteps%2F</url>
    <content type="text"><![CDATA[缘起CSS3 中用于设置动画的 animation 语法如下： 1animation: name duration timing-function delay iteration-count direction; 其中，timing-function 取值如下： 1timing-function: linear / ease / ease-in / ease-out / ease-in-out / cubic-bezier() / steps() 上面 timing-function 的取值除了 steps() 都代表补间动画（线性动画），steps() 代表帧动画，有时候一些动画效果必须用它才能实现，例如上面图奔跑的动物是我们曾经做过的动画，就是通过 steps() 配合改变雪碧图（1600px宽）的位置实现的，代码如下： 12345678@keyframes aniSelf &#123; 0% &#123; background-position: 0 0; &#125; 100% &#123; background-position: -1600px 0; &#125;&#125; 123.wolf&#123; animation: aniSelf 1s steps(8) infinite;&#125; 上面代码确实能实现预期的效果，但不知道大家有没有这样一个疑问：当背景位置为 background-position: -1600px 0; 时，图片在盒子中应该是看不到的才对（因为图片总共是1600px，这样刚好是图片的最右边卡到盒子的最左边），但为什么动画还能正常跑起来，而没有出现空白的问题呢？ 要解答上面的疑问，我们就要明白关于 steps(number[, end | start]) 参数的含义，第一个参数大家都知道是什么意思，第二个参数是可选的，表示在每个间隔的起点或是终点发生阶跃变化，如果忽略，默认是 end。 看完上面加粗部分的定义，我不知道你作何感想…😣 我的感性认识我的理解：steps() 第二个参数如果是 end 则代表忽略结束帧，如果是 start 则代表忽略开始帧，如何理解这句话呢？ 上面是一张 50 * 200 的图片，作为 50 * 50 盒子的背景图，我想实现在 hover 盒子的时候背景从 A 变化到 A 的逐帧动画。由于我们知道 steps(4, end) 时会忽略最后一帧，动画走完时没有 forwards，又会回到初始状态，故可以用以下方法来实现： 1234567891011121314151617181920.box &#123; border: 1px solid #333; width: 50px; height: 50px; background: url(./images/steps.png) no-repeat;&#125;.box:hover &#123; /* 分为 4 步来完成，会忽略最后一步 background-position: 0 -150px; 到 background-position: 0 -200px; 这个区间！ */ animation: way1 2s steps(4);&#125;@keyframes way1 &#123; 0% &#123; background-position: 0 0; &#125; 100% &#123; background-position: 0 -200px; &#125;&#125; 上面代码其实就是和我们课上实现动物运动的代码是一样的思路，那如果我把上面的代码改为 steps(4, start) 会怎样的，根据我们之前的结论，start 会忽略第一帧，也就是 hover 上的一刹那就会定位到 B，然后也会走 background-position: 0 -150px; 到 background-position: 0 -200px; 最后一帧这个区间，即会出现空白，最后又回到初始状态 A，可见，这并不是我们所需要的。 我就想用 start如果实在想用 start 可以改写代码如下： 1234567891011121314/* Step1: 分为 3 步走 */.box:hover &#123; animation: way1 2s steps(3, start);&#125;/* Step2: 最后一帧的位置改成严丝合缝的最后一样图片 */@keyframes way1 &#123; 0% &#123; background-position: 0 0; &#125; 100% &#123; background-position: 0 -150px; &#125;&#125; 注意：以上代码虽然能实现 hover 时背景从 A、B、C、D 到 A 的变换，但并不推荐这样做，因为 hover 的一刹那 A 到 B 的变换是没有动画的（逐帧动画也是动画） 其他写法注意看我的注释部分！ 123456789101112131415161718192021.box &#123; border: 1px solid #333; width: 50px; height: 50px; /* Step1: 背景重复！ */ background: url(./images/steps.png) repeat-y;&#125;.box:hover &#123; /* Step2: 这时候 steps 第二个参数是 start or end 只是开始时第一帧有没有动画的区别，并不会出现空白了，因为背景平铺了 */ animation: way1 2s steps(4);&#125;@keyframes way1 &#123; 0% &#123; background-position: 0 0; /* A */ &#125; 100% &#123; background-position: 0 -200px; /* A */ &#125;&#125; 123456789/* 设置是这样的写法 */@keyframes way1 &#123; 0% &#123; background-position: 0 200px; /* A */ &#125; 100% &#123; background-position: 0 0px; /* A */ &#125;&#125; 其他属性对 step 的影响当 steps() 第二个参数为 end 时会忽略结束帧，但 animation-fill-mode: forwards; 是会影响 steps() 的表现的，例如我想让一个盒子从 0 运动到 100，可写代码如下： 12345678910111213141516.box&#123; width: 100px; height: 100px; background-color: pink; position: absolute; top: 70px; animation: move 3s steps(5) forwards;&#125;@keyframes move &#123; 0%&#123; left: 0; &#125; 100%&#123; left: 100px; &#125;&#125; 结果如下： 说好的 steps() 第二个参数为 end 时会忽略最后一帧，但最后却停在了 100px 的位置上，说明 animation-fill-mode 为 forwards 时会对 steps() 帧动画造成影响，以 forwards 为准！当然你如果又设置了 infinite，那 forwards 也就“失效”了… 再来个小栗子点我去远方]]></content>
      <categories>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>steps()</tag>
        <tag>帧动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据类型检测的 N 中方式]]></title>
    <url>%2F2019%2F05%2F26%2Fjudge-type%2F</url>
    <content type="text"><![CDATA[从 JS 基础第一天开始，我们就学习了如何使用 typeof 去判断数据类型，学习构造函数时我们又说了 constructor 以及 instanceof 也可以去进行类型检测，到 JS 高级时还讲了 Object.prototype.toString() 方法也可以去判断数据类型，那么问题来了，这么多方法它们之间有什么异同吗？不同场景下该怎样使用才比较合适呢？ 数据类型知多少既然要检测数据类型，首先要明确 JS 中的数据类型有以下 7 种： 简单数据类型：Number、String、Boolean、Null、Undefined、Symbol（ES6） 复杂数据类型：Object（包括函数、数组、对象、正则、日期等） typeoftypeof 它的使用方法有两种： 1234// 可以不带括号，直接跟数据console.log(typeof 36);// 也可以带括号console.log(typeof(36)); typeof 的返回值永远是一个全小写字符串，例如： 1console.log(typeof (typeof (typeof 66))); // string typeof 的返回值除了上面 7 种数据类型外，还多了一个 function，例如： 12function test() &#123;&#125;console.log(typeof test); // function 总结： 除了 Null（返回 object），typeof 对于基本数据类型都能返回正确的结果 除了 Function（返回 function），typeof 对于复杂数据类型都返回 object 缺点： typeof 对于复杂数据类型的处理，只能返回处于原型链最顶端的 Object 类型，不能细分 constructor新建一个（构造）函数 Fn 时，JS 引擎会给自 Fn 添加一个 prototype 属性，prototype 下又有一个 constructor 指向 Fn 函数，可用如下代码表示： 12function Fn() &#123;&#125;console.log(Fn.prototype.constructor === Fn); // true 当我们执行 new Fn 来创建 Fn 的实例后，这个实例的 constructor 也就指向 Fn，如下： 1234function Fn() &#123;&#125;var f1 = new Fn;// f1 下本没有 constructor，自己没有则会通过原型链向上查找到 Fn.prototype 上console.log(f1.constructor === Fn); // true 如此一来我们就可以通过 constructor 来判断某个实例对象具体的类型（来源），例如上面代码从原型链的角度来说 f1 的类型（来源）就是 Fn。 同样的道理，其他数据的也可以通过 constructor 来判断具体的类型，它可以解决 typeof 对应复杂数据类型的判断无能为力的问题，测试如下： 1234567console.log([].constructor === Array); // trueconsole.log(new Date().constructor === Date); // trueconsole.log(new Function().constructor === Function);console.log(''.constructor === String);console.log(true.constructor === Boolean);console.log(new Error().constructor === Error);console.log(document.constructor === HTMLDocument); constructor 的小问题： null 和 undefined 上没有 constructor 这属性，不能通过 constructor 来判断 当 prototype 被不小心重写后，会导致 constructor 判断不准确的问题，例如： 1234567891011function Test() &#123;&#125;var t1 = new Test;console.log(t1.constructor === Test); // true// 重写原型会导致 Test.prototype.constructor 指向不正确// 当然对应的实例对象在用 constructor 去判断类型的时候也就会指向不正确Test.prototype = &#123; showAge: function() &#123;&#125;&#125;;var t2 = new Test();console.log(t2.constructor === Test); // false instanceof它主要用来判断一个对象是否能够通过原型链找到另一个对象的原型，什么意思呢？例如： 12// [] 可以通过 __proto__ 找到 Array.prototype，所以结果是 trueconsole.log([] instanceof Array); 123// [].__proto__.__proto__ === Object.prototype// 说明 [] 也是可以通过原型链找过 Object 的原型，所以下面结果也是 trueconsole.log([] instanceof Object); 所以大家也看到了，instanceof 并不能准确的找到某个实例的类型，但它相对于 constructor 有这样一个特点，即便构造函数的原型被重写后，实例也能通过 instanceof 去判断自己的类型，例如： 1234567function Test() &#123;&#125;Test.prototype = &#123; showAge: function() &#123;&#125;&#125;;var t1 = new Test();console.log(t1 instanceof Test); // trueconsole.log(t1 instanceof Object); // 当然对应顶级对象 Object 也是 true，还是不能准确判断就是 Test 类型 instanceof 还有另外一个问题需要你注意的，当页面中引入 iframe 时，实例化 iframe 窗口下的对象和当前窗口下相对应的构造函数进行 instanceof 判断时也会出现问题。例如： 1234567891011var oFrame = document.createElement('iframe');document.body.appendChild(oFrame);// ifame 窗口下实例化的 arrvar arr = new window.frames[0].Array;console.log(arr instanceof window.frames[0].Array); // trueconsole.log(arr instanceof Array); // false// 针对上面的问题 ES5 提供了 Array.isArray() 这个方法进行判断console.log(Array.isArray(arr)); // true Object.prototype.toString他返回的信息格式是 [object Xxx]（注意第一个 X 是大写），对于 {} 直接调用 toString 既可以返回 [object Object]，其他类型需要借助 call/apply 方法去调用，例如： 12345678910111213// 也可以把 Object.prototype 替换成 &#123;&#125;// 因为调用 &#123;&#125; 下的 toString() 方法，自己没有会通过原型链去 Object.prototype 上面找console.log(Object.prototype.toString.call(233)); // [object Number]console.log(Object.prototype.toString.call('233')); // [object String]console.log(Object.prototype.toString.call(true)); // [object Boolean]console.log(Object.prototype.toString.call(null)); // [object Null]console.log(Object.prototype.toString.call(undefined)); // [object Undefined]console.log(Object.prototype.toString.call(Symbol())); // [object Symbol]console.log(Object.prototype.toString.call([])); // [object Array]console.log(Object.prototype.toString.call(new Function)); // [object Function]console.log(Object.prototype.toString.call(new Date)); // [object Date]console.log(Object.prototype.toString.call(new RegExp)); // [object RegExp] 可见 Object.prototype.toString() 简直太好用啦，推荐使用！]]></content>
      <categories>
        <category>JS 高级</category>
      </categories>
      <tags>
        <tag>判断数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据在内存中的存储形式]]></title>
    <url>%2F2019%2F05%2F25%2Fsnake-question%2F</url>
    <content type="text"><![CDATA[学习贪吃蛇时，往蛇身体增加最后一节，当时代码是直接这样写的 this.body.push({ x: last.x, y: last.y, color: last.color })，有些同学问 last 这个变量保存的数据和 { x: last.x, y: last.y, color: last.color } “长的一样”，为什么不能直接 this.body.push(last) 呢？ 基本数据类型存储要说清楚上面的问题，首先大家要明白不同数据类型在内存中的存储形式是怎样的。我们都知道 JS 中的数据类型分为 2 大类，分别是： 基本数据类型：Number、String、Boolean、Null、Undefined、Symbol(ES6) 复杂数据类型：Object(包括数组、对象、函数、正则) 其中基本数据类型存储在栈内存中，他们是按值存放的，例如： 1234var age1 = 18;var age2 = age1;age2 = 20;console.log(age1, age2); // 18 20 上面代码在内存中的表现形式如下： 复杂数据类型存储复杂数据类型的真实数据是存放在堆内存中的，变量保存的只是在栈内存中的一个地址，这个地址指向堆内存中数据。例如： 1234var obj1 = &#123; age: 18 &#125;;var obj2 = obj1;obj2.age = 20; // obj2 是改变堆内存中的同一份数据console.log(obj1.age); // 所以 obj1 的数据也被影响了，结果是 20 上面代码在内存中的表现形式如下： 解释贪吃蛇的问题讲贪吃蛇时，关于蛇如何吃到食物我们说了这么一段话：在蛇运动时，判断蛇头的坐标是否与食物的坐标吻合，如果吻合，则往蛇身体后增加一节，然后再随机食物的坐标即可，代码如下： 12345678if (headX === food.x &amp;&amp; headY === food.y) &#123; // Step1: 获取蛇的最后一节 var last = this.body[this.body.length - 1]; // Step2: 添加到身体的最后 this.body.push(&#123; x: last.x, y: last.y, color: last.color &#125;); // Step3: 随机随机食物坐标 food.render(map);&#125; 如果直接 this.body.push(last) 的话，相当于每次添加的还是堆内存中的同一个 last，那在下次 move 修改数据的时候就会相互影响，无论你往后面 push 多少项 last，在修改到最前面的 three 时也会把后面的给修改掉（因为都是堆内存中的同一份数据），所以你看到的结果是后面的数据都是重复的，对应到页面上也就是最后一节的元素都是覆盖在一起的。测试代码如下： 12345678910var one = &#123;x: 26, y: 14, color: "red"&#125;;var two = &#123;x: 25, y: 14, color: "blue"&#125;;var three = &#123;x: 24, y: 14, color: "blue"&#125;;var arr = [one, two, three, three];for (var i = arr.length - 1; i &gt; 0; i--) &#123; arr[i].x = arr[i - 1].x; arr[i].y = arr[i - 1].y;&#125;console.log(arr); 该如何解决12345678910111213141516171819var arr = [ &#123;x: 26, y: 14, color: "red"&#125;, &#123;x: 25, y: 14, color: "blue"&#125;, &#123;x: 24, y: 14, color: "blue"&#125;];var last = arr[arr.length - 1];// 每次造一个全新的对象var newObj = &#123; x: last.x, y: last.y, color: last.color &#125;;// 或者拷贝原来的对象// var newObj = JSON.parse(JSON.stringify(last));arr.push(newObj);for (var i = arr.length - 1; i &gt; 0; i--) &#123; arr[i].x = arr[i - 1].x; arr[i].y = arr[i - 1].y;&#125;console.log(arr);]]></content>
      <categories>
        <category>JS 高级</category>
      </categories>
      <tags>
        <tag>贪吃蛇</tag>
        <tag>引用类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS 中的隐式转换]]></title>
    <url>%2F2019%2F05%2F24%2Finvisible-transform%2F</url>
    <content type="text"><![CDATA[JS 中有个“经典”的面试题：请问 [] == ![] 的结果是什么？一眼看上去肯定是 false，但结果却是 true，要清楚为什么是这样，就要了解 JS 在进行数据比较时的隐式转换规则是怎样的？ 注：除了对本问题的解释部分，其他都来自 JavaScript 高级程序设计，建议看书！我这里摘出了其中两点，来作为对常见问题的解释，其实还有其他细节或特殊注意的地方，建议在精力充沛的情况下可以自己去探索！ 相等操作符规则在转换不同的数据类型时，相等和不相等操作符遵循下列基本规则： 1 . 如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值，false 转换为 0，而 true 转换为 12 . 如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值3 . 如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf()方法，用得到的基本类型值按照前面的规则进行比较 这两个操作符在进行比较时又要遵循下列特殊的情况： 1 . null 和 undefined 是相等的2 . 要比较相等性之前，不能将 null 和 undefined 转换成其他任何值3 . 如果有一个操作数是 NaN，则相等操作符返回 false，而不相等操作符返回 true。重要提示：即使两个操作数都是 NaN，相等操作符也返回 false；因为按照规则，NaN 不等于 NaN4 . 如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回 true；否则，返回 false 关系操作符规则当关系操作符的操作数使用了非数值时，也要进行数据转换或完成某些奇怪的操作。以下就是相应的规则： 1 . 如果两个操作数都是数值，则执行数值比较2 . 如果两个操作数都是字符串，则比较两个字符串对应的字符编码值3 . 如果一个操作数是数值，则将另一个操作数转换为一个数值，然后执行数值比较4 . 如果一个操作数是对象，则调用这个对象的 valueOf()方法，用得到的结果按照前面的规则执行比较。如果对象没有 valueOf()方法，则调用 toString()方法，并用得到的结果根据前面的规则执行比较5 . 如果一个操作数是布尔值，则先将其转换为数值，然后再执行比较 解释 [] == ![]1[] == ![] Step1: ! 的优先级比 == 高，先执行 ![]，除了 null、undefined、’’、NaN、0 都是 true，所以 ![] 是 false 1[] == false Step2: 参考相等操作符比较的第 1 条规则，如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值，故结果如下： 1[] == 0 Step3: 参考相等操作符比较的第 3 条规则，调用对象的 valueOf() 方法得到原始值，并将原始值转换为数字结果如下： 1Number([].valueOf()) == 0]]></content>
      <categories>
        <category>JS 基础</category>
      </categories>
      <tags>
        <tag>隐式转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[触发全选按钮的几种思路]]></title>
    <url>%2F2019%2F05%2F22%2Fselect-all%2F</url>
    <content type="text"><![CDATA[需求：点击全选，选中上面所有的列表项；点击列表项中的每一个水果，如果有未选中则取消全选按钮，如果都选中了则激活全选按钮。 常规操作点击每个列表选项时，遍历所有列表选项并检查是否有未选中的，如果有则可以确定全选按钮的状态为未选中，否则全选按钮置为选中。 1234567891011121314151617181920212223242526272829303132var oAllInput = document.querySelector('#all');var aInput = document.querySelectorAll('ul input');// 点击全选 input 时根据自己的状态来控制其他列表项的 inputoAllInput.onchange = function() &#123; for(var i = 0; i &lt; aInput.length; i ++) &#123; aInput[i].checked = this.checked; &#125;&#125;;// 每次点击每一个列表项的 input 时，判断全选的 input 是否需要被选中for(var i = 0; i &lt; aInput.length; i ++) &#123; aInput[i].onclick = function() &#123; if (!this.checked) &#123; // 如果当前点击的按钮未选中，那就可以直接确定全选按钮的状态了 oAllInput.checked = false; // 也就没有必要进行下去了 return; &#125; var bBar = true; for(var i = 0; i &lt; aInput.length; i ++) &#123; // 发现有一个没选中的 if(!aInput[i].checked) &#123; bBar = false; // 发现有一个没选中的也就可以断定 oAllInput 的状态了，就没有必要再进行下去了 // 当然你不写 break 逻辑上也是对的，只是存在性能浪费 break; &#125; &#125; oAllInput.checked = bBar; &#125;;&#125; 注意细节思路和上面一样，下面的写法也是可以的，但有一点需要注意：点击列表中的每一项进行循环时，碰到未选中的一定要跳出循环，不然前面全选按钮的状态都会被最后一个按钮的状态所覆盖。 12345678910111213141516171819for (var i = 0; i &lt; aInput.length; i++) &#123; aInput[i].onclick = function () &#123; if (!this.checked) &#123; // 如果当前点击的按钮未选中，那就可以直接确定全选按钮的状态了 oAllInput.checked = false; // 也就没有必要进行下去了 return; &#125; for (var i = 0; i &lt; aInput.length; i++) &#123; if (!aInput[i].checked) &#123; oAllInput.checked = false; // 这里的 break 是必须要加的！不然全选按钮的状态永远是以最后一个的选中状态为准，这并不是我们所希望的 break; &#125; else &#123; oAllInput.checked = true; &#125; &#125; &#125;;&#125; 其他方法每次点击列表中的按钮时，获取所有已选中 input 的长度，并判断已选中 input 的 length 是否等于所有 input 的 length，如果相等，就可以激活全选按钮啦，否则则取消全选。 1234567891011for (var i = 0; i &lt; aInput.length; i++) &#123; aInput[i].onclick = function () &#123; var aInputChecked = document.querySelectorAll('ul input:checked'); // 已选中 length 等于所有 length 就证明全选中了，也就可以激活全选按钮啦 if (aInputChecked.length === aInput.length) &#123; oAllInput.checked = true; &#125; else &#123; oAllInput.checked = false; &#125; &#125;;&#125;]]></content>
      <categories>
        <category>Web API</category>
      </categories>
      <tags>
        <tag>全选</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排他思想]]></title>
    <url>%2F2019%2F05%2F21%2Fkill-other%2F</url>
    <content type="text"><![CDATA[上课我们在做点击当前按钮高亮，其他按钮重置为默认颜色的需求时，用到了“排他思想”，思路是：第一步，先干掉所有的；第二步，再操作自己的，简单明了，相信大家都比较清楚了！这里我再给大家做个总结，顺便再拓展一下其他的实现思路 ~ 排完思想需求：有 5 个按钮，点击当前按钮变红，其他按钮恢复默认颜色 123456&lt;!-- HTML 结构 --&gt;&lt;button&gt;1&lt;/button&gt;&lt;button&gt;2&lt;/button&gt;&lt;button&gt;3&lt;/button&gt;&lt;button&gt;4&lt;/button&gt;&lt;button&gt;5&lt;/button&gt; 123456789101112var aBtn = document.querySelectorAll('button');for(var i = 0; i &lt; aBtn.length; i ++) &#123; aBtn[i].onclick = function() &#123; // Step1: 先干掉所有人，“排完” for(var i = 0; i &lt; aBtn.length; i ++) &#123; aBtn[i].style.backgroundColor = ''; &#125; // Step2: 再操作自己的 this.style.backgroundColor = 'red'; &#125;;&#125; 排兄思想1234567&lt;script src="https://cdn.bootcss.com/jquery/3.4.0/jquery.min.js"&gt;&lt;/script&gt;&lt;script&gt;$("button").on("click", function() &#123; // 先操作自己的，再干掉所有的兄弟，“排兄” $(this).css("background", "red").siblings().css("background", "");&#125;);&lt;/script&gt; 排上思想1234567891011121314var aBtn = document.querySelectorAll('button');var prev = 0;for (var i = 0; i &lt; aBtn.length; i++) &#123; aBtn[i].index = i; aBtn[i].onclick = function () &#123; // Step1: 先干掉上一个，“排上” aBtn[prev].style.backgroundColor = ""; // Step2: 再操作自己的 this.style.backgroundColor = 'red'; // Step3: 操作完别忘了把自己也变成“上一个” prev = this.index; &#125;;&#125;]]></content>
      <categories>
        <category>Web API</category>
      </categories>
      <tags>
        <tag>排他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[认清 Node.appendChild()]]></title>
    <url>%2F2019%2F05%2F19%2FappendChild%2F</url>
    <content type="text"><![CDATA[Node.appendChild() 方法用于将一个节点添加到指定父节点的子节点列表的末尾，但在具体使用时还有其他一些需要我们关注的细节，以及对应的应用场景。 常规操作大家都清楚 appendChild 可以把创建好的元素插入到另一个元素内容的最后面，常规操作如下： 123456// 创建元素var oDiv = document.createElement('div');// 给创建好的元素加点内容oDiv.innerHTML = 'hello world';// 添加到 body 里面document.body.appendChild(oDiv); 需要注意上面代码必然没有任何问题，但这里还有一点需要大家注意的是，appendChild 在插入已存在元素的时候其实是做了两件事的： 先把原来已存在的元素删除 再进行后续的添加操作 具体是什么意思呢？大家看下面的例子就清楚了。需求：每次点击按钮把上面 ul 中的第一个元素移动到下面的 ul 中： 1234567891011121314151617181920&lt;ul id="ul1"&gt; &lt;li&gt;aaa&lt;/li&gt; &lt;li&gt;bbb&lt;/li&gt; &lt;li&gt;ccc&lt;/li&gt; &lt;li&gt;ddd&lt;/li&gt;&lt;/ul&gt;&lt;button id="btn"&gt;插入下面&lt;/button&gt;&lt;ul id="ul2"&gt;&lt;/ul&gt;&lt;script&gt;// 选择元素var oUl1 = document.querySelector('#ul1');var oBtn = document.querySelector('#btn');var oUl2 = document.querySelector('#ul2');oBtn.onclick = function() &#123; var oLi = oUl1.children[0]; // 每次点击按钮确实在 oUl2 中添加了一个新的元素，但同时 oUl1 中也相应少了这个元素 // 所以 appendChild 时相当于偷偷帮我们做了这么一步操作：oUl1.removeChild(oLi); oUl2.appendChild(oLi);&#125;;&lt;/script&gt; 实际应用好，现在我们清楚了当用 appendChild 插入已存在元素时会先删除之前再进行插入，那明白这个特性有什么实际的用处吗？答案是肯定的。例如下面一个需求，点击按钮，根据元素中的数字大小对这组元素进行排序： 123456789&lt;!-- HTML 结构 --&gt;&lt;ul id="ul1"&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;4&lt;/li&gt;&lt;/ul&gt;&lt;button id="btn"&gt;点击&lt;/button&gt; 123456789101112131415161718192021222324252627282930313233// 选择元素var oUl1 = document.querySelector('#ul1');var aLi = oUl1.querySelectorAll('li');var oBtn = document.querySelector('#btn');// 把伪数组 aLi 中的每一项都放到数组里面，目的是为了进行排序var arr = [];for(var i = 0; i &lt; aLi.length; i ++) &#123; arr.push(aLi[i]);&#125;oBtn.onclick = function () &#123; // 这就是我们熟悉的冒泡排序，你还记得吗 for (var i = 0; i &lt; arr.length - 1; i++) &#123; // 需要走 arr.length - 1 轮 for (var j = 0; j &lt; arr.length - i - 1; j++) &#123; // 每轮比较 arr.length - i - 1 次 var prevNum = parseFloat(arr[j].innerText); var nextNum = parseFloat(arr[j + 1].innerText); if (prevNum &gt; nextNum) &#123; // 不能对伪数组中其中一些直接赋值，例如：aLi[j] = aLi[j+1]，所以需要把伪数组转换成数组后再进行排序 var temp = null; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125; // 此时 arr 中装的已经是排好序的一堆 li 元素了 for(var i = 0; i &lt; arr.length; i ++) &#123; // 分别把排好序的数组中的每个元素插入到 oUl1 内容的最后 // 注意每次插入的同时也会把 oUl1 中那个相同的元素先给干掉，所以 oUl1 中也就不会存在重复元素的问题 oUl1.appendChild(arr[i]); &#125;&#125;; 优化代码这里优化相关的代码我们并没有学（不建议查看），我这里也提供一种较佳实战，是给你们以后看的（甚至是工作后），优化后的 JS 代码如下： 123456789101112const oUl1 = document.querySelector('#ul1');const aLi = oUl1.querySelectorAll('li');const oBtn = document.querySelector('#btn');oBtn.addEventListener('click', () =&gt; &#123; // Array.from 可以把伪数组转成数组，sort 的原理就是上面写的冒泡排序 Array.from(aLi).sort((li1, li2) =&gt; &#123; return parseFloat(li1.innerText) - parseFloat(li2.innerText); &#125;).forEach(li =&gt; &#123; oUl1.appendChild(li); &#125;)&#125;);]]></content>
      <categories>
        <category>Web API</category>
      </categories>
      <tags>
        <tag>appendChild</tag>
      </tags>
  </entry>
</search>
