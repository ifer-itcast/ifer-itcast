<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="今日目标✔ 掌握 TypeScript 的基本使用。">
<meta property="og:type" content="article">
<meta property="og:title" content="13_TS">
<meta property="og:url" content="http://example.com/2021/12/07/react-base-course13/index.html">
<meta property="og:site_name" content="危险">
<meta property="og:description" content="今日目标✔ 掌握 TypeScript 的基本使用。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/resource/images/TS_logo.png">
<meta property="og:image" content="http://example.com/resource/images/TS%E6%98%AFJS%E7%9A%84%E8%B6%85%E9%9B%86.png">
<meta property="og:image" content="http://example.com/resource/images/TSvsJS.png">
<meta property="og:image" content="http://example.com/resource/images/TS%E7%BC%96%E8%AF%91.png">
<meta property="og:image" content="http://example.com/resource/images/image-20211121111454776.png">
<meta property="article:published_time" content="2021-12-07T13:16:55.000Z">
<meta property="article:modified_time" content="2021-12-07T14:30:56.388Z">
<meta property="article:author" content="Ifer">
<meta property="article:tag" content="React,Redux,Mobx,Saga,Dva,Umi,AntD,TS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/resource/images/TS_logo.png">

<link rel="canonical" href="http://example.com/2021/12/07/react-base-course13/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>13_TS | 危险</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">危险</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">为之则易，不为则难</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/07/react-base-course13/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/49337922.png">
      <meta itemprop="name" content="Ifer">
      <meta itemprop="description" content="React 全家桶 <span style='position:relative;top:-2px;'>✍</span>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="危险">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          13_TS
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-12-07 21:16:55 / 修改时间：22:30:56" itemprop="dateCreated datePublished" datetime="2021-12-07T21:16:55+08:00">2021-12-07</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="今日目标"><a href="#今日目标" class="headerlink" title="今日目标"></a>今日目标</h2><p>✔ 掌握 TypeScript 的基本使用。</p>
<span id="more"></span>

<h2 id="TypeScript-是什么"><a href="#TypeScript-是什么" class="headerlink" title="TypeScript 是什么"></a>TypeScript 是什么</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>能够说出什么是 TypeScript。</p>
<h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><ul>
<li><p>  <a target="_blank" rel="noopener" href="https://www.typescriptlang.org/">TS 官方文档</a></p>
</li>
<li><p>  <a target="_blank" rel="noopener" href="https://www.tslang.cn/">TS 中文参考 - 不再维护</a></p>
</li>
</ul>
<p><img src="/resource/images/TS_logo.png" alt="TS Logo"></p>
<ul>
<li>  <strong><code>TypeScript</code> 简称：TS，是 JavaScript 的超集</strong>，简单来说就是：JS 有的 TS 都有</li>
</ul>
<p><img src="/resource/images/TS%E6%98%AFJS%E7%9A%84%E8%B6%85%E9%9B%86.png" alt="TS是JS的超集"></p>
<ul>
<li><p>  TypeScript = <code>Type</code> + JavaScript（在 JS 基础之上，<strong>为 JS 添加了类型支持</strong>）</p>
</li>
<li><p>  TypeScript 是<em>微软</em>开发的开源编程语言，可以在任何运行 JavaScript 的地方运行</p>
</li>
</ul>
<p><img src="/resource/images/TSvsJS.png" alt="TS 和 JS 的对比"></p>
<h2 id="为什么要有-TypeScript"><a href="#为什么要有-TypeScript" class="headerlink" title="为什么要有 TypeScript"></a>为什么要有 TypeScript</h2><h3 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h3><p>能够说出为什么需要有 TypeScript。</p>
<h3 id="内容-1"><a href="#内容-1" class="headerlink" title="内容"></a>内容</h3><ul>
<li><p>  背景：JS 的类型系统存在“先天缺陷”弱类型，JS 代码中绝大部分错误都是类型错误（Uncaught TypeError）</p>
</li>
<li><p>  这些经常出现的错误，导致了在使用 JS 进行项目开发时，增加了找 Bug、改 Bug 的时间，严重影响开发效率</p>
</li>
</ul>
<p>为什么会这样？</p>
<ul>
<li><p>从编程语言的动静来区分，<strong>TypeScript 属于静态类型的编程语言</strong>，<strong>JavaScript 属于动态类型的编程语言</strong></p>
<ul>
<li><p>  静态类型：<strong>编译</strong>期做类型检查</p>
</li>
<li><p>  动态类型：<strong>执行</strong>期做类型检查</p>
</li>
</ul>
</li>
<li><p>  代码编译和代码执行的顺序：1 编译 2 执行</p>
</li>
<li><p>  对于 JS 来说：需要等到代码真正去执行的时候才能发现错误（晚）</p>
</li>
<li><p>  对于 TS 来说：在代码编译的时候（代码执行前）就可以发现错误（早）</p>
</li>
</ul>
<p>并且，配合 VSCode 等开发工具，TS 可以提前到<strong>在编写代码的同时就发现代码中的错误</strong>，减少找 Bug、改 Bug 时间</p>
<p>对比：</p>
<ul>
<li><p>使用 JS：</p>
<ol>
<li><p>在 VSCode 里面写代码</p>
</li>
<li><p>在浏览器中运行代码 –&gt; 运行时，才会发现错误【晚】</p>
</li>
</ol>
</li>
<li><p>使用 TS：</p>
<ol>
<li><p>在 VSCode 里面写代码 –&gt; 写代码的同时，就会发现错误【早】</p>
</li>
<li><p>在浏览器中运行代码</p>
</li>
</ol>
</li>
</ul>
<h2 id="TypeScript-相比-JS-的优势"><a href="#TypeScript-相比-JS-的优势" class="headerlink" title="TypeScript 相比 JS 的优势"></a>TypeScript 相比 JS 的优势</h2><h3 id="目标-2"><a href="#目标-2" class="headerlink" title="目标"></a>目标</h3><p>能够说出 typescript 相比 js 有哪些优势</p>
<h3 id="内容-2"><a href="#内容-2" class="headerlink" title="内容"></a>内容</h3><ol>
<li><p><strong>更早（写代码的同时）发现错误</strong>，减少找 Bug、改 Bug 时间，提升开发效率</p>
</li>
<li><p>程序中任何位置的代码都有<strong>代码提示</strong>，随时随地的安全感，增强了开发体验</p>
</li>
<li><p>强大的类型系统提升了代码的可维护性，使得<strong>重构代码更加容易</strong></p>
</li>
<li><p>支持最新的 ECMAScript 语法，<strong>优先体验最新的语法，让你走在前端技术的最前沿</strong></p>
</li>
<li><p>TS 类型推断机制，不需要在代码中的每个地方都显示标注类型，让你在享受优势的同时，尽量降低了学习负担</p>
</li>
</ol>
<p>除此之外，Vue 3 源码使用 TS 重写、Angular 默认支持 TS、React 与 TS 完美配合，TypeScript 已成为大中型前端 项目的首选编程语言</p>
<p>目前，前端最新的开发技术栈：</p>
<ol>
<li>React： TS + Hooks</li>
<li>Vue： TS + Vue3</li>
</ol>
<ul>
<li>  注意： Vue2 对 TS 的支持不好~</li>
</ul>
<hr>
<h2 id="安装编译-TS-的工具包"><a href="#安装编译-TS-的工具包" class="headerlink" title="安装编译 TS 的工具包"></a>安装编译 TS 的工具包</h2><h3 id="目标-3"><a href="#目标-3" class="headerlink" title="目标"></a>目标</h3><p>能够安装 TS 的工具包来编译 TS。</p>
<h3 id="内容-3"><a href="#内容-3" class="headerlink" title="内容"></a>内容</h3><ul>
<li><p>  问题：为什么要安装编译 TS 的工具包?</p>
</li>
<li><p>  回答：Node.js/浏览器，只认识 JS 代码，不认识 TS 代码。需要先将 TS 代码转化为 JS 代码，然后才能运行</p>
</li>
<li><p>安装命令：<code>npm i -g typescript</code> 或者 <code>yarn global add typescript</code></p>
<ul>
<li><p>  typescript 包：用来编译 TS 代码的包，提供了 <code>tsc</code> 命令，实现了 TS -&gt; JS 的转化</p>
</li>
<li><p>  <em>注意：Mac 电脑安装全局包时，需要添加 <code>sudo</code> 获取权限：<code>sudo npm i -g typescript</code></em> yarn 全局安装：<code>sudo yarn global add typescript</code></p>
</li>
</ul>
</li>
<li><p>  验证是否安装成功：tsc –v(查看 typescript 的版本)</p>
</li>
</ul>
<p><img src="/resource/images/TS%E7%BC%96%E8%AF%91.png" alt="TS 编译"></p>
<h2 id="编译并运行-TS-代码"><a href="#编译并运行-TS-代码" class="headerlink" title="编译并运行 TS 代码"></a>编译并运行 TS 代码</h2><h3 id="目标-4"><a href="#目标-4" class="headerlink" title="目标"></a>目标</h3><p>能够理解 TypeScript 的运行步骤</p>
<h3 id="内容-4"><a href="#内容-4" class="headerlink" title="内容"></a>内容</h3><ol>
<li><p>创建 hello.ts 文件（注意：**TS 文件的后缀名为 <code>.ts</code>**）</p>
</li>
<li><p>将 TS 编译为 JS：在终端中输入命令，<code>tsc hello.ts</code>（此时，在同级目录中会出现一个同名的 JS 文件）</p>
</li>
<li><p>执行 JS 代码：在终端中输入命令，<code>node hello.js</code></p>
</li>
</ol>
<p>1 创建 ts 文件 ===&gt; 2 编译 TS ===&gt; 3 执行 JS</p>
<ul>
<li><p>  说明：所有合法的 JS 代码都是 TS 代码，有 JS 基础只需要学习 TS 的类型即可</p>
</li>
<li><p>  注意：由 TS 编译生成的 JS 文件，代码中就没有类型信息了</p>
</li>
</ul>
<h2 id="简化运行-TS-的步骤"><a href="#简化运行-TS-的步骤" class="headerlink" title="简化运行 TS 的步骤"></a>简化运行 TS 的步骤</h2><h3 id="目标-5"><a href="#目标-5" class="headerlink" title="目标"></a>目标</h3><p>能够通过 ts-node 包来简化 ts 的运行</p>
<h3 id="内容-5"><a href="#内容-5" class="headerlink" title="内容"></a>内容</h3><ul>
<li><p>  问题描述：每次修改代码后，都要重复执行两个命令，才能运行 TS 代码，太繁琐</p>
</li>
<li><p>  简化方式：使用 <code>ts-node</code> 包，直接在 Node.js 中执行 TS 代码</p>
</li>
<li><p>安装命令：<code>npm i -g ts-node</code></p>
<ul>
<li><p>  ts-node 包提供了 <code>ts-node</code> 命令</p>
</li>
<li><p>  使用方式：<code>ts-node hello.ts</code> 相当于：1 tsc 命令 2 node（注意：ts-node 不会生成 js 文件）</p>
</li>
</ul>
</li>
</ul>
<p>解释：ts-node 命令在内部偷偷的将 TS -&gt; JS，然后，再运行 JS 代码</p>
<h2 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h2><h3 id="目标-6"><a href="#目标-6" class="headerlink" title="目标"></a>目标</h3><p>能够理解什么是 typescript 的类型注解</p>
<h3 id="内容-6"><a href="#内容-6" class="headerlink" title="内容"></a>内容</h3><ul>
<li><p>TypeScript 是 JS 的超集，TS 提供了 JS 的所有功能，并且额外的增加了：<strong>类型系统</strong></p>
<ul>
<li><p>  所有的 JS 代码都是 TS 代码</p>
</li>
<li><p>  <strong>JS 有类型</strong>（比如，number/string 等），但是 <strong>JS 不会检查变量的类型是否发生变化</strong>，而 TS 会检查</p>
</li>
</ul>
</li>
<li><p>  TypeScript 类型系统的主要优势：<strong>可以显示标记出代码中的意外行为，从而降低了发生错误的可能性</strong></p>
</li>
</ul>
<p><strong>示例代码</strong>:</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">18</span></span><br><span class="line"><span class="keyword">let</span> age: <span class="built_in">number</span> = <span class="number">18</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>  说明：代码中的 <code>: number</code> 就是<strong>类型注解</strong></p>
</li>
<li><p>  作用：<strong>为变量添加类型约束</strong>。比如，上述代码中，约定变量 age 的类型为 number 类型</p>
</li>
<li><p>  解释：<strong>约定了什么类型，就只能给变量赋值该类型的值，否则，就会报错</strong></p>
</li>
<li><p>  约定了类型之后，代码的提示就会非常的清晰</p>
</li>
<li><p>  错误演示：</p>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误代码：</span></span><br><span class="line"><span class="comment">// 错误原因：将 string 类型的值赋值给了 number 类型的变量，类型不一致</span></span><br><span class="line"><span class="keyword">let</span> age: <span class="built_in">number</span> = <span class="string">&#x27;18&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="原始类型"><a href="#原始类型" class="headerlink" title="原始类型"></a>原始类型</h2><h3 id="目标-7"><a href="#目标-7" class="headerlink" title="目标"></a>目标</h3><p>能够理解 ts 中原始类型的使用</p>
<h3 id="内容-7"><a href="#内容-7" class="headerlink" title="内容"></a>内容</h3><p>可以将 TS 中的常用基础类型细分为两类：1 JS 已有类型 2 TS 新增类型</p>
<ol>
<li>JS 已有类型</li>
</ol>
<ul>
<li><p>  原始类型：<code>number/string/boolean/null/undefined</code></p>
</li>
<li><p>  对象类型：<code>object</code>（包括，数组、对象、函数等对象）</p>
</li>
</ul>
<ol start="2">
<li>TS 新增类型</li>
</ol>
<ul>
<li><p>  联合类型、自定义类型(类型别名)、接口、元组、字面量类型、枚举、void、any 等</p>
</li>
<li><p>注意：</p>
<ol>
<li><em>原始类型</em>在 TS 和 JS 中写法一致</li>
<li><em>对象类型</em>在 TS 中更加细化，每个具体的对象（比如，数组、对象、函数）都有自己的类型语法</li>
</ol>
</li>
<li><p>  原始类型：number/string/boolean/null/undefined</p>
</li>
<li><p>  特点：简单，这些类型，完全按照 JS 中类型的名称来书写</p>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age: <span class="built_in">number</span> = <span class="number">18</span></span><br><span class="line"><span class="keyword">let</span> myName: <span class="built_in">string</span> = <span class="string">&#x27;老师&#x27;</span></span><br><span class="line"><span class="keyword">let</span> isLoading: <span class="built_in">boolean</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等等...</span></span><br></pre></td></tr></table></figure>

<h2 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h2><h3 id="目标-8"><a href="#目标-8" class="headerlink" title="目标"></a>目标</h3><p>掌握 ts 中数组类型的两种写法</p>
<h3 id="内容-8"><a href="#内容-8" class="headerlink" title="内容"></a>内容</h3><ul>
<li><p>数组类型的两种写法：</p>
<ul>
<li>  推荐使用 <code>number[]</code> 写法</li>
</ul>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一：</span></span><br><span class="line"><span class="keyword">let</span> numbers: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line"><span class="comment">// 写法二：</span></span><br><span class="line"><span class="keyword">let</span> strings: <span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt; = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h2 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h2><h3 id="目标-9"><a href="#目标-9" class="headerlink" title="目标"></a>目标</h3><p>能够通过联合类型将多个类型组合成一个类型</p>
<h3 id="内容-9"><a href="#内容-9" class="headerlink" title="内容"></a>内容</h3><p>需求：数组中既有 number 类型，又有 string 类型，这个数组的类型应该如何写?</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr: (<span class="built_in">number</span> | <span class="built_in">string</span>)[] = [<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>, <span class="number">3</span>, <span class="string">&#x27;b&#x27;</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>  解释：<code>|</code>（竖线）在 TS 中叫做<strong>联合类型</strong>，即：由两个或多个其他类型组成的类型，表示可以是这些类型中的任意一种</p>
</li>
<li><p>  注意：这是 TS 中联合类型的语法，只有一根竖线，不要与 JS 中的或（|| 或）混淆了</p>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> timer: number | <span class="literal">null</span> = <span class="literal">null</span></span><br><span class="line">timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;&#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个数组，数组中可以有数字或者字符串, 需要注意 | 的优先级</span></span><br><span class="line"><span class="keyword">let</span> arr: (number | string)[] = [<span class="number">1</span>, <span class="string">&#x27;abc&#x27;</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><h3 id="目标-10"><a href="#目标-10" class="headerlink" title="目标"></a>目标</h3><p>能够使用类型别名给类型起别名</p>
<h3 id="内容-10"><a href="#内容-10" class="headerlink" title="内容"></a>内容</h3><ul>
<li><p>  <code>类型别名（自定义类型）</code>：为任意类型起别名</p>
</li>
<li><p>  使用场景：当同一类型（复杂）被多次使用时，可以通过类型别名，<strong>简化该类型的使用</strong></p>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CustomArray = (<span class="built_in">number</span> | <span class="built_in">string</span>)[]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr1: CustomArray = [<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>, <span class="number">3</span>, <span class="string">&#x27;b&#x27;</span>]</span><br><span class="line"><span class="keyword">let</span> arr2: CustomArray = [<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>解释:</p>
<ol>
<li><p>使用 <code>type</code> 关键字来创建自定义类型</p>
</li>
<li><p>类型别名（比如，此处的 _CustomArray_）可以是任意合法的变量名称</p>
</li>
<li><p>推荐使用大写字母开头</p>
</li>
<li><p>创建类型别名后，直接使用该类型别名作为变量的类型注解即可</p>
</li>
</ol>
</li>
</ul>
<h2 id="ts-node-命令报错问题"><a href="#ts-node-命令报错问题" class="headerlink" title="ts-node 命令报错问题"></a>ts-node 命令报错问题</h2><ul>
<li>  运行 ts-node 命令，可以会报错</li>
</ul>
<p><img src="/resource/images/image-20211121111454776.png" alt="image-20211121111454776"></p>
<ul>
<li>  解决方案：生成 ts 的配置文件</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc --init</span><br></pre></td></tr></table></figure>

<ul>
<li>  带来的问题</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ts的配置文件，默认是全局的模块化环境，所以定义的变量会冲突，，</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">const</span> num = <span class="number">11</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数类型-基本使用"><a href="#函数类型-基本使用" class="headerlink" title="函数类型-基本使用"></a>函数类型-基本使用</h2><h3 id="目标-11"><a href="#目标-11" class="headerlink" title="目标"></a>目标</h3><p>能够给函数指定类型</p>
<h3 id="内容-11"><a href="#内容-11" class="headerlink" title="内容"></a>内容</h3><ul>
<li><p>  函数的类型实际上指的是：<code>函数参数</code>和<code>返回值</code>的类型</p>
</li>
<li><p>为函数指定类型的两种方式：</p>
<ol>
<li><p>单独指定参数、返回值的类型</p>
</li>
<li><p>同时指定参数、返回值的类型</p>
</li>
</ol>
</li>
</ul>
<ol>
<li>单独指定参数、返回值的类型：</li>
</ol>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1: <span class="built_in">number</span>, num2: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">const</span> add = (num1: <span class="built_in">number</span>, <span class="attr">num2</span>: <span class="built_in">number</span>): <span class="function"><span class="params">number</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>同时指定参数、返回值的类型:</li>
</ol>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> AddFn = <span class="function">(<span class="params">num1: <span class="built_in">number</span>, num2: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> add: AddFn = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  解释：当函数作为表达式时，可以通过类似箭头函数形式的语法来为函数添加类型</li>
<li>  注意：这种形式只适用于函数表达式</li>
</ul>
<h2 id="函数类型-void-类型"><a href="#函数类型-void-类型" class="headerlink" title="函数类型-void 类型"></a>函数类型-void 类型</h2><h3 id="目标-12"><a href="#目标-12" class="headerlink" title="目标"></a>目标</h3><p>能够了解 void 类型的使用</p>
<h3 id="内容-12"><a href="#内容-12" class="headerlink" title="内容"></a>内容</h3><ul>
<li>  如果函数没有返回值，那么，函数返回值类型为：<code>void</code></li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">name: <span class="built_in">string</span></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hello&#x27;</span>, name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意：<ul>
<li>  如果一个函数没有返回值，此时，在 TS 的类型中，应该使用 <code>void</code> 类型</li>
</ul>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果什么都不写，此时，add 函数的返回值类型为： void</span></span><br><span class="line"><span class="keyword">const</span> add = <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line"><span class="comment">// 这种写法是明确指定函数返回值类型为 void，与上面不指定返回值类型相同</span></span><br><span class="line"><span class="keyword">const</span> add = (): <span class="function"><span class="params">void</span> =&gt;</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 但，如果指定 返回值类型为 undefined，此时，函数体中必须显示的 return undefined 才可以</span></span><br><span class="line"><span class="keyword">const</span> add = (): <span class="function"><span class="params">undefined</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 此处，返回的 undefined 是 JS 中的一个值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数类型-可选参数"><a href="#函数类型-可选参数" class="headerlink" title="函数类型-可选参数"></a>函数类型-可选参数</h2><h3 id="目标-13"><a href="#目标-13" class="headerlink" title="目标"></a>目标</h3><p>能够使用?给函数指令可选参数类型</p>
<h3 id="内容-13"><a href="#内容-13" class="headerlink" title="内容"></a>内容</h3><ul>
<li><p>  使用函数实现某个功能时，参数可以传也可以不传。这种情况下，在给函数参数指定类型时，就用到<strong>可选参数</strong>了</p>
</li>
<li><p>  比如，数组的 slice 方法，可以 <code>slice()</code> 也可以 <code>slice(1)</code> 还可以 <code>slice(1, 3)</code></p>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mySlice</span>(<span class="params">start?: <span class="built_in">number</span>, end?: <span class="built_in">number</span></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;起始索引：&#x27;</span>, start, <span class="string">&#x27;结束索引：&#x27;</span>, end)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  可选参数：在可传可不传的参数名称后面添加 <code>?</code>（问号）</li>
<li>  注意：<strong>可选参数只能出现在参数列表的最后</strong>，也就是说可选参数后面不能再出现必选参数</li>
</ul>
<h2 id="函数类型-参数默认值"><a href="#函数类型-参数默认值" class="headerlink" title="函数类型-参数默认值"></a>函数类型-参数默认值</h2><h3 id="目标-14"><a href="#目标-14" class="headerlink" title="目标"></a>目标</h3><p>能够给函数指定默认值</p>
<h3 id="内容-14"><a href="#内容-14" class="headerlink" title="内容"></a>内容</h3><ul>
<li>  参数默认值和可选参数互斥的，一般只需要指定一种即可。</li>
</ul>
<h2 id="对象类型-基本使用"><a href="#对象类型-基本使用" class="headerlink" title="对象类型-基本使用"></a>对象类型-基本使用</h2><h3 id="目标-15"><a href="#目标-15" class="headerlink" title="目标"></a>目标</h3><p>掌握对象类型的基本使用</p>
<h3 id="内容-15"><a href="#内容-15" class="headerlink" title="内容"></a>内容</h3><ul>
<li>  JS 中的对象是由属性和方法构成的，而 <strong>TS 对象的类型就是在描述对象的结构</strong>（有什么类型的属性和方法）</li>
<li>  对象类型的写法:</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空对象</span></span><br><span class="line"><span class="keyword">let</span> person: &#123;&#125; = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有属性的对象</span></span><br><span class="line"><span class="keyword">let</span> person: &#123; <span class="attr">name</span>: <span class="built_in">string</span> &#125; = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;同学&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 既有属性又有方法的对象</span></span><br><span class="line"><span class="comment">// 在一行代码中指定对象的多个属性类型时，使用 `;`（分号）来分隔</span></span><br><span class="line"><span class="keyword">let</span> person: &#123; <span class="attr">name</span>: <span class="built_in">string</span>; sayHi(): <span class="built_in">void</span> &#125; = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;jack&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象中如果有多个类型，可以换行写：</span></span><br><span class="line"><span class="comment">// 通过换行来分隔多个属性类型，可以去掉 `;`</span></span><br><span class="line"><span class="keyword">let</span> person: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">    sayHi(): <span class="built_in">void</span></span><br><span class="line">&#125; = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;jack&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123;&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>解释:<ol>
<li>使用 <code>&#123;&#125;</code> 来描述对象结构</li>
<li>属性采用<code>属性名: 类型</code>的形式</li>
<li>方法采用<code>方法名(): 返回值类型</code>的形式</li>
</ol>
</li>
</ul>
<h2 id="对象类型-带有参数的方法类型"><a href="#对象类型-带有参数的方法类型" class="headerlink" title="对象类型-带有参数的方法类型"></a>对象类型-带有参数的方法类型</h2><ul>
<li>  如果方法有参数，就在方法名后面的小括号中指定参数类型</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">    greet(name: <span class="built_in">string</span>): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person: Person = &#123;</span><br><span class="line">    <span class="function"><span class="title">greet</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(name)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对象类型-箭头函数形式的方法类型"><a href="#对象类型-箭头函数形式的方法类型" class="headerlink" title="对象类型-箭头函数形式的方法类型"></a>对象类型-箭头函数形式的方法类型</h2><ul>
<li>  方法的类型也可以使用箭头函数形式</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">    <span class="attr">greet</span>: <span class="function">(<span class="params">name: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person: Person = &#123;</span><br><span class="line">    <span class="function"><span class="title">greet</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(name)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对象类型-对象可选属性"><a href="#对象类型-对象可选属性" class="headerlink" title="对象类型-对象可选属性"></a>对象类型-对象可选属性</h2><ul>
<li><p>  对象的属性或方法，也可以是可选的，此时就用到<strong>可选属性</strong>了</p>
</li>
<li><p>  比如，我们在使用 <code>axios(&#123; ... &#125;)</code> 时，如果发送 GET 请求，method 属性就可以省略</p>
</li>
<li><p>  可选属性的语法与函数可选参数的语法一致，都使用 <code>?</code> 来表示</p>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Config = &#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="built_in">string</span></span><br><span class="line">    method?: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myAxios</span>(<span class="params">config: Config</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(config)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对象类型-使用类型别名"><a href="#对象类型-使用类型别名" class="headerlink" title="对象类型-使用类型别名"></a>对象类型-使用类型别名</h2><ul>
<li>  注意：直接使用 <code>&#123;&#125;</code> 形式为对象添加类型，会降低代码的可读性（不好辨识类型和值）</li>
<li>  推荐：<strong>使用类型别名为对象添加类型</strong></li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建类型别名</span></span><br><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">    sayHi(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类型别名作为对象的类型：</span></span><br><span class="line"><span class="keyword">let</span> person: Person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;jack&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123;&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对象类型-练习"><a href="#对象类型-练习" class="headerlink" title="对象类型-练习"></a>对象类型-练习</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">创建两个对象：</span><br><span class="line">学生对象</span><br><span class="line"></span><br><span class="line">指定对象的类型</span><br><span class="line">姓名</span><br><span class="line">性别</span><br><span class="line">成绩</span><br><span class="line">身高</span><br><span class="line"></span><br><span class="line">学习</span><br><span class="line">打游戏</span><br></pre></td></tr></table></figure>

<h2 id="对象类型-接口"><a href="#对象类型-接口" class="headerlink" title="对象类型-接口"></a>对象类型-接口</h2><p>当一个对象类型被多次使用时，一般会使用接口（<code>interface</code>）来描述对象的类型，达到复用的目的</p>
<ul>
<li>解释：<ol>
<li>使用 <code>interface</code> 关键字来声明接口</li>
<li>接口名称(比如，此处的 IPerson)，可以是任意合法的变量名称，推荐以 <code>I</code> 开头</li>
<li>声明接口后，直接使用接口名称作为变量的类型</li>
<li>因为每一行只有一个属性类型，因此，属性类型后没有 ;(分号)</li>
</ol>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IPerson &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">    sayHi(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person: IPerson = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;jack&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">19</span>,</span><br><span class="line">    <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123;&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对象类型-interface-vs-type"><a href="#对象类型-interface-vs-type" class="headerlink" title="对象类型-interface vs type"></a>对象类型-interface vs type</h2><ul>
<li><p>  interface（接口）和 type（类型别名）的对比：</p>
</li>
<li><p>  相同点：都可以给对象指定类型</p>
</li>
<li><p>不同点:</p>
<ul>
<li><p>  接口，只能为对象指定类型</p>
</li>
<li><p>  类型别名，不仅可以为对象指定类型，实际上可以为任意类型指定别名</p>
</li>
</ul>
</li>
<li><p>  推荐：<strong>能使用 type 就是用 type</strong></p>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IPerson &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">    sayHi(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为对象类型创建类型别名</span></span><br><span class="line"><span class="keyword">type</span> IPerson = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">    sayHi(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为联合类型创建类型别名</span></span><br><span class="line"><span class="keyword">type</span> NumStr = <span class="built_in">number</span> | <span class="built_in">string</span></span><br></pre></td></tr></table></figure>

<h2 id="对象类型-接口继承"><a href="#对象类型-接口继承" class="headerlink" title="对象类型-接口继承"></a>对象类型-接口继承</h2><ul>
<li><p>  如果两个接口之间有相同的属性或方法，可以将<strong>公共的属性或方法抽离出来，通过继承来实现复用</strong></p>
</li>
<li><p>  比如，这两个接口都有 x、y 两个属性，重复写两次，可以，但很繁琐</p>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Point2D &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span></span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Point3D &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span></span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span></span><br><span class="line">    <span class="attr">z</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  更好的方式:</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Point2D &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span></span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承 Point2D</span></span><br><span class="line"><span class="keyword">interface</span> Point3D <span class="keyword">extends</span> Point2D &#123;</span><br><span class="line">    <span class="attr">z</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>解释：</p>
<ol>
<li><p>使用 <code>extends</code>(继承)关键字实现了接口 Point3D 继承 Point2D</p>
</li>
<li><p>继承后，Point3D 就有了 Point2D 的所有属性和方法(此时，Point3D 同时有 x、y、z 三个属性)</p>
</li>
</ol>
</li>
</ul>
<h2 id="元组类型"><a href="#元组类型" class="headerlink" title="元组类型"></a>元组类型</h2><ul>
<li>  场景：在地图中，使用经纬度坐标来标记位置信息</li>
<li>  可以使用数组来记录坐标，那么，该数组中只有两个元素，并且这两个元素都是数值类型</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> position: <span class="built_in">number</span>[] = [<span class="number">116.2317</span>, <span class="number">39.5427</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>  使用 number[] 的缺点：不严谨，因为该类型的数组中可以出现任意多个数字</li>
<li>  更好的方式：<code>元组 Tuple</code></li>
<li>  元组类型是另一种类型的数组，它确切地知道包含多少个元素，<strong>以及特定索引对应的类型</strong></li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> position: [<span class="built_in">number</span>, <span class="built_in">number</span>] = [<span class="number">39.5427</span>, <span class="number">116.2317</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>解释：</p>
<ol>
<li><p>元组类型可以确切地标记出有多少个元素，以及每个元素的类型</p>
</li>
<li><p>该示例中，元素有两个元素，每个元素的类型都是 number</p>
</li>
</ol>
</li>
</ul>
<hr>
<h2 id="类型推论"><a href="#类型推论" class="headerlink" title="类型推论"></a>类型推论</h2><ul>
<li><p>  在 TS 中，某些没有明确指出类型的地方，<strong>TS 的类型推论机制会帮助提供类型</strong></p>
</li>
<li><p>  换句话说：由于类型推论的存在，这些地方，类型注解可以省略不写</p>
</li>
<li><p>发生类型推论的 2 种常见场景:</p>
<ol>
<li><p>声明变量并初始化时</p>
</li>
<li><p>决定函数返回值时</p>
</li>
</ol>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量 age 的类型被自动推断为：number</span></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">18</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数返回值的类型被自动推断为：number</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1: <span class="built_in">number</span>, num2: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  推荐：<strong>能省略类型注解的地方就省略</strong>（<del>偷懒</del>，充分利用 TS 类型推论的能力，提升开发效率）</li>
<li>  技巧：如果不知道类型，可以通过鼠标放在变量名称上，利用 VSCode 的提示来查看类型</li>
<li>  推荐：在 VSCode 中写代码的时候，多看方法、属性的类型，养成写代码看类型的习惯</li>
</ul>
<h2 id="字面量类型-基本使用"><a href="#字面量类型-基本使用" class="headerlink" title="字面量类型-基本使用"></a>字面量类型-基本使用</h2><ul>
<li>  思考以下代码，两个变量的类型分别是什么?</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str1 = <span class="string">&#x27;Hello TS&#x27;</span></span><br><span class="line"><span class="keyword">const</span> str2 = <span class="string">&#x27;Hello TS&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>通过 TS 类型推论机制，可以得到答案：</p>
<ol>
<li>变量 str1 的类型为：string</li>
<li>变量 str2 的类型为：’Hello TS’</li>
</ol>
</li>
<li><p>  解释:</p>
</li>
</ul>
<ol>
<li><p>str1 是一个变量(let)，它的值可以是任意字符串，所以类型为:string</p>
</li>
<li><p>str2 是一个常量(const)，它的值不能变化只能是 ‘Hello TS’，所以，它的类型为:’Hello TS’</p>
</li>
</ol>
<ul>
<li><p>  注意：此处的 ‘Hello TS’，就是一个<strong>字面量类型</strong>，也就是说某个特定的字符串也可以作为 TS 中的类型</p>
</li>
<li><p>任意的 JS 字面量（比如，对象、数字等）都可以作为类型使用</p>
<ul>
<li>  字面量：<code>&#123; name: &#39;jack&#39; &#125;</code> <code>[]</code> <code>18</code> <code>20</code> <code>&#39;abc&#39;</code> <code>false</code> <code>function() &#123;&#125;</code></li>
</ul>
</li>
</ul>
<h2 id="字面量类型-使用模式和场景"><a href="#字面量类型-使用模式和场景" class="headerlink" title="字面量类型-使用模式和场景"></a>字面量类型-使用模式和场景</h2><ul>
<li><p>  使用模式：<strong>字面量类型配合联合类型一起使用</strong></p>
</li>
<li><p>  使用场景：用来表示一组明确的可选值列表</p>
</li>
<li><p>  比如，在贪吃蛇游戏中，游戏的方向的可选值只能是上、下、左、右中的任意一个</p>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用自定义类型:</span></span><br><span class="line"><span class="keyword">type</span> Direction = <span class="string">&#x27;up&#x27;</span> | <span class="string">&#x27;down&#x27;</span> | <span class="string">&#x27;left&#x27;</span> | <span class="string">&#x27;right&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeDirection</span>(<span class="params">direction: Direction</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(direction)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数时，会有类型提示：</span></span><br><span class="line">changeDirection(<span class="string">&#x27;up&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>  解释：参数 direction 的值只能是 up/down/left/right 中的任意一个</p>
</li>
<li><p>  优势：相比于 string 类型，使用字面量类型更加精确、严谨</p>
</li>
</ul>
<h2 id="枚举类型-基本使用（了解）"><a href="#枚举类型-基本使用（了解）" class="headerlink" title="枚举类型-基本使用（了解）"></a>枚举类型-基本使用（了解）</h2><ul>
<li><p>  枚举的功能类似于<strong>字面量类型+联合类型组合</strong>的功能，也可以表示一组明确的可选值</p>
</li>
<li><p>  枚举：定义一组命名常量。它描述一个值，该值可以是这些命名常量中的一个</p>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建枚举</span></span><br><span class="line"><span class="built_in">enum</span> Direction &#123;</span><br><span class="line">    Up,</span><br><span class="line">    Down,</span><br><span class="line">    Left,</span><br><span class="line">    Right,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用枚举类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeDirection</span>(<span class="params">direction: Direction</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(direction)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数时，需要应该传入：枚举 Direction 成员的任意一个</span></span><br><span class="line"><span class="comment">// 类似于 JS 中的对象，直接通过 点（.）语法 访问枚举的成员</span></span><br><span class="line">changeDirection(Direction.Up)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>解释:</p>
<ol>
<li><p>使用 <code>enum</code> 关键字定义枚举</p>
</li>
<li><p>约定枚举名称以大写字母开头</p>
</li>
<li><p>枚举中的多个值之间通过 <code>,</code>（逗号）分隔</p>
</li>
<li><p>定义好枚举后，直接使用枚举名称作为类型注解</p>
</li>
</ol>
</li>
</ul>
<h2 id="枚举类型-数字枚举"><a href="#枚举类型-数字枚举" class="headerlink" title="枚举类型-数字枚举"></a>枚举类型-数字枚举</h2><ul>
<li><p>  问题：我们把枚举成员作为了函数的实参，它的值是什么呢?</p>
</li>
<li><p>  解释：通过将鼠标移入 Direction.Up，可以看到枚举成员 Up 的值为 0</p>
</li>
<li><p>  注意：枚举成员是有值的，默认为：从 0 开始自增的数值</p>
</li>
<li><p>  我们把，枚举成员的值为数字的枚举，称为：<code>数字枚举</code></p>
</li>
<li><p>  当然，也可以给枚举中的成员初始化值</p>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Down -&gt; 11、Left -&gt; 12、Right -&gt; 13</span></span><br><span class="line"><span class="built_in">enum</span> Direction &#123;</span><br><span class="line">    Up = <span class="number">10</span>,</span><br><span class="line">    Down,</span><br><span class="line">    Left,</span><br><span class="line">    Right,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">enum</span> Direction &#123;</span><br><span class="line">    Up = <span class="number">2</span>,</span><br><span class="line">    Down = <span class="number">4</span>,</span><br><span class="line">    Left = <span class="number">8</span>,</span><br><span class="line">    Right = <span class="number">16</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="枚举类型-字符串枚举"><a href="#枚举类型-字符串枚举" class="headerlink" title="枚举类型-字符串枚举"></a>枚举类型-字符串枚举</h2><ul>
<li><p>  字符串枚举：枚举成员的值是字符串</p>
</li>
<li><p>  注意：字符串枚举没有自增长行为，因此，<strong>字符串枚举的每个成员必须有初始值</strong></p>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Direction &#123;</span><br><span class="line">    Up = <span class="string">&#x27;UP&#x27;</span>,</span><br><span class="line">    Down = <span class="string">&#x27;DOWN&#x27;</span>,</span><br><span class="line">    Left = <span class="string">&#x27;LEFT&#x27;</span>,</span><br><span class="line">    Right = <span class="string">&#x27;RIGHT&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="枚举类型-枚举实现原理"><a href="#枚举类型-枚举实现原理" class="headerlink" title="枚举类型-枚举实现原理"></a>枚举类型-枚举实现原理</h2><ul>
<li><p>  枚举是 TS 为数不多的非 JavaScript 类型级扩展(不仅仅是类型)的特性之一</p>
</li>
<li><p>  因为：其他类型仅仅被当做类型，而枚举不仅用作类型，还提供值(枚举成员都是有值的)</p>
</li>
<li><p>  也就是说，其他的类型会在编译为 JS 代码时自动移除。但是，<strong>枚举类型会被编译为 JS 代码</strong></p>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Direction &#123;</span><br><span class="line">  Up = <span class="string">&#x27;UP&#x27;</span>,</span><br><span class="line">  Down = <span class="string">&#x27;DOWN&#x27;</span>,</span><br><span class="line">  Left = <span class="string">&#x27;LEFT&#x27;</span>,</span><br><span class="line">  Right = <span class="string">&#x27;RIGHT&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会被编译为以下 JS 代码：</span></span><br><span class="line"><span class="keyword">var</span> Direction;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">Direction</span>) </span>&#123;</span><br><span class="line">  Direction[<span class="string">&#x27;Up&#x27;</span>] = <span class="string">&#x27;UP&#x27;</span></span><br><span class="line">  Direction[<span class="string">&#x27;Down&#x27;</span>] = <span class="string">&#x27;DOWN&#x27;</span></span><br><span class="line">  Direction[<span class="string">&#x27;Left&#x27;</span>] = <span class="string">&#x27;LEFT&#x27;</span></span><br><span class="line">  Direction[<span class="string">&#x27;Right&#x27;</span>] = <span class="string">&#x27;RIGHT&#x27;</span></span><br><span class="line">&#125;)(Direction || Direction = &#123;&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>  说明：枚举与前面讲到的字面量类型+联合类型组合的功能类似，都用来表示一组明确的可选值列表</p>
</li>
<li><p>  一般情况下，<strong>推荐使用字面量类型+联合类型组合的方式</strong>，因为相比枚举，这种方式更加直观、简洁、高效</p>
</li>
</ul>
<h2 id="any-类型"><a href="#any-类型" class="headerlink" title="any 类型"></a>any 类型</h2><ul>
<li><p>  <strong>原则:不推荐使用 any</strong>!这会让 TypeScript 变为 “AnyScript”(失去 TS 类型保护的优势)</p>
</li>
<li><p>  因为当值的类型为 any 时，可以对该值进行任意操作，并且不会有代码提示</p>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj: <span class="built_in">any</span> = &#123; <span class="attr">x</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">obj.bar = <span class="number">100</span></span><br><span class="line">obj()</span><br><span class="line"><span class="keyword">const</span> n: <span class="built_in">number</span> = obj</span><br></pre></td></tr></table></figure>

<ul>
<li><p>  解释:以上操作都不会有任何类型错误提示，即使可能存在错误</p>
</li>
<li><p>  尽可能的避免使用 any 类型，除非临时使用 any 来“避免”书写很长、很复杂的类型</p>
</li>
<li><p>其他隐式具有 any 类型的情况</p>
<ol>
<li><p>声明变量不提供类型也不提供默认值</p>
</li>
<li><p>函数参数不加类型</p>
</li>
</ol>
</li>
<li><p>  注意：因为不推荐使用 any，所以，这两种情况下都应该提供类型</p>
</li>
</ul>
<hr>
<h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p>有时候你会比 TS 更加明确一个值的类型，此时，可以使用类型断言来指定更具体的类型。 比如，</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> aLink = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;link&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>  注意：该方法返回值的类型是 HTMLElement，该类型只包含所有标签公共的属性或方法，不包含 a 标签特有的 href 等属性</p>
</li>
<li><p>  因此，这个**类型太宽泛(不具体)**，无法操作 href 等 a 标签特有的属性或方法</p>
</li>
<li><p>  解决方式：这种情况下就需要<strong>使用类型断言指定更加具体的类型</strong></p>
</li>
<li><p>  使用类型断言：</p>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> aLink = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;link&#x27;</span>) <span class="keyword">as</span> HTMLAnchorElement</span><br></pre></td></tr></table></figure>

<ul>
<li><p>解释:</p>
<ol>
<li><p>使用 <code>as</code> 关键字实现类型断言</p>
</li>
<li><p>关键字 as 后面的类型是一个更加具体的类型（HTMLAnchorElement 是 HTMLElement 的子类型）</p>
</li>
<li><p>通过类型断言，aLink 的类型变得更加具体，这样就可以访问 a 标签特有的属性或方法了</p>
</li>
</ol>
</li>
<li><p>  另一种语法，使用 <code>&lt;&gt;</code> 语法，这种语法形式不常用知道即可:</p>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该语法，知道即可：</span></span><br><span class="line"><span class="keyword">const</span> aLink = &lt;HTMLAnchorElement&gt;<span class="built_in">document</span>.getElementById(<span class="string">&#x27;link&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><em>技巧：在浏览器控制台，通过 <code>__proto__</code> 获取 DOM 元素的类型</em></p>
<h2 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h2><ul>
<li>  众所周知，JS 中提供了 typeof 操作符，用来在 JS 中获取数据的类型</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">&#x27;Hello world&#x27;</span>) <span class="comment">// ?</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>  实际上，TS 也提供了 typeof 操作符：可以在<em>类型上下文</em>中引用变量或属性的类型（类型查询）</p>
</li>
<li><p>  使用场景:根据已有变量的值，获取该值的类型，来简化类型书写</p>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatPoint</span>(<span class="params">point: &#123; x: <span class="built_in">number</span>; y: <span class="built_in">number</span> &#125;</span>) </span>&#123;&#125;</span><br><span class="line">formatPoint(p)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatPoint</span>(<span class="params">point: <span class="keyword">typeof</span> p</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>解释:</p>
<ol>
<li><p>使用 <code>typeof</code> 操作符来获取变量 p 的类型，结果与第一种（对象字面量形式的类型）相同</p>
</li>
<li><p>typeof 出现在<strong>类型注解的位置（参数名称的冒号后面）所处的环境就在类型上下文</strong>(区别于 JS 代码)</p>
</li>
<li><p>注意：typeof 只能用来查询变量或属性的类型，无法查询其他形式的类型（比如，函数调用的类型）</p>
</li>
</ol>
</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/11/25/react-base-course12/" rel="prev" title="12_极客园">
      <i class="fa fa-chevron-left"></i> 12_极客园
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8A%E6%97%A5%E7%9B%AE%E6%A0%87"><span class="nav-number">1.</span> <span class="nav-text">今日目标</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TypeScript-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">2.</span> <span class="nav-text">TypeScript 是什么</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%AE%E6%A0%87"><span class="nav-number">2.1.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AE%B9"><span class="nav-number">2.2.</span> <span class="nav-text">内容</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89-TypeScript"><span class="nav-number">3.</span> <span class="nav-text">为什么要有 TypeScript</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%AE%E6%A0%87-1"><span class="nav-number">3.1.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AE%B9-1"><span class="nav-number">3.2.</span> <span class="nav-text">内容</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TypeScript-%E7%9B%B8%E6%AF%94-JS-%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="nav-number">4.</span> <span class="nav-text">TypeScript 相比 JS 的优势</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%AE%E6%A0%87-2"><span class="nav-number">4.1.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AE%B9-2"><span class="nav-number">4.2.</span> <span class="nav-text">内容</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%89%E8%A3%85%E7%BC%96%E8%AF%91-TS-%E7%9A%84%E5%B7%A5%E5%85%B7%E5%8C%85"><span class="nav-number">5.</span> <span class="nav-text">安装编译 TS 的工具包</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%AE%E6%A0%87-3"><span class="nav-number">5.1.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AE%B9-3"><span class="nav-number">5.2.</span> <span class="nav-text">内容</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E5%B9%B6%E8%BF%90%E8%A1%8C-TS-%E4%BB%A3%E7%A0%81"><span class="nav-number">6.</span> <span class="nav-text">编译并运行 TS 代码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%AE%E6%A0%87-4"><span class="nav-number">6.1.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AE%B9-4"><span class="nav-number">6.2.</span> <span class="nav-text">内容</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E5%8C%96%E8%BF%90%E8%A1%8C-TS-%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="nav-number">7.</span> <span class="nav-text">简化运行 TS 的步骤</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%AE%E6%A0%87-5"><span class="nav-number">7.1.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AE%B9-5"><span class="nav-number">7.2.</span> <span class="nav-text">内容</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3"><span class="nav-number">8.</span> <span class="nav-text">类型注解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%AE%E6%A0%87-6"><span class="nav-number">8.1.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AE%B9-6"><span class="nav-number">8.2.</span> <span class="nav-text">内容</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B"><span class="nav-number">9.</span> <span class="nav-text">原始类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%AE%E6%A0%87-7"><span class="nav-number">9.1.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AE%B9-7"><span class="nav-number">9.2.</span> <span class="nav-text">内容</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">10.</span> <span class="nav-text">数组类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%AE%E6%A0%87-8"><span class="nav-number">10.1.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AE%B9-8"><span class="nav-number">10.2.</span> <span class="nav-text">内容</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="nav-number">11.</span> <span class="nav-text">联合类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%AE%E6%A0%87-9"><span class="nav-number">11.1.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AE%B9-9"><span class="nav-number">11.2.</span> <span class="nav-text">内容</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="nav-number">12.</span> <span class="nav-text">类型别名</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%AE%E6%A0%87-10"><span class="nav-number">12.1.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AE%B9-10"><span class="nav-number">12.2.</span> <span class="nav-text">内容</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ts-node-%E5%91%BD%E4%BB%A4%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98"><span class="nav-number">13.</span> <span class="nav-text">ts-node 命令报错问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="nav-number">14.</span> <span class="nav-text">函数类型-基本使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%AE%E6%A0%87-11"><span class="nav-number">14.1.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AE%B9-11"><span class="nav-number">14.2.</span> <span class="nav-text">内容</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B-void-%E7%B1%BB%E5%9E%8B"><span class="nav-number">15.</span> <span class="nav-text">函数类型-void 类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%AE%E6%A0%87-12"><span class="nav-number">15.1.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AE%B9-12"><span class="nav-number">15.2.</span> <span class="nav-text">内容</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B-%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0"><span class="nav-number">16.</span> <span class="nav-text">函数类型-可选参数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%AE%E6%A0%87-13"><span class="nav-number">16.1.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AE%B9-13"><span class="nav-number">16.2.</span> <span class="nav-text">内容</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B-%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="nav-number">17.</span> <span class="nav-text">函数类型-参数默认值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%AE%E6%A0%87-14"><span class="nav-number">17.1.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AE%B9-14"><span class="nav-number">17.2.</span> <span class="nav-text">内容</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="nav-number">18.</span> <span class="nav-text">对象类型-基本使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%AE%E6%A0%87-15"><span class="nav-number">18.1.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AE%B9-15"><span class="nav-number">18.2.</span> <span class="nav-text">内容</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B-%E5%B8%A6%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95%E7%B1%BB%E5%9E%8B"><span class="nav-number">19.</span> <span class="nav-text">对象类型-带有参数的方法类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%BD%A2%E5%BC%8F%E7%9A%84%E6%96%B9%E6%B3%95%E7%B1%BB%E5%9E%8B"><span class="nav-number">20.</span> <span class="nav-text">对象类型-箭头函数形式的方法类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B-%E5%AF%B9%E8%B1%A1%E5%8F%AF%E9%80%89%E5%B1%9E%E6%80%A7"><span class="nav-number">21.</span> <span class="nav-text">对象类型-对象可选属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B-%E4%BD%BF%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="nav-number">22.</span> <span class="nav-text">对象类型-使用类型别名</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B-%E7%BB%83%E4%B9%A0"><span class="nav-number">23.</span> <span class="nav-text">对象类型-练习</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B-%E6%8E%A5%E5%8F%A3"><span class="nav-number">24.</span> <span class="nav-text">对象类型-接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B-interface-vs-type"><span class="nav-number">25.</span> <span class="nav-text">对象类型-interface vs type</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B-%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF"><span class="nav-number">26.</span> <span class="nav-text">对象类型-接口继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%83%E7%BB%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">27.</span> <span class="nav-text">元组类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E6%8E%A8%E8%AE%BA"><span class="nav-number">28.</span> <span class="nav-text">类型推论</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E9%9D%A2%E9%87%8F%E7%B1%BB%E5%9E%8B-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="nav-number">29.</span> <span class="nav-text">字面量类型-基本使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E9%9D%A2%E9%87%8F%E7%B1%BB%E5%9E%8B-%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%9C%BA%E6%99%AF"><span class="nav-number">30.</span> <span class="nav-text">字面量类型-使用模式和场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="nav-number">31.</span> <span class="nav-text">枚举类型-基本使用（了解）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B-%E6%95%B0%E5%AD%97%E6%9E%9A%E4%B8%BE"><span class="nav-number">32.</span> <span class="nav-text">枚举类型-数字枚举</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9E%9A%E4%B8%BE"><span class="nav-number">33.</span> <span class="nav-text">枚举类型-字符串枚举</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B-%E6%9E%9A%E4%B8%BE%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">34.</span> <span class="nav-text">枚举类型-枚举实现原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#any-%E7%B1%BB%E5%9E%8B"><span class="nav-number">35.</span> <span class="nav-text">any 类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80"><span class="nav-number">36.</span> <span class="nav-text">类型断言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#typeof"><span class="nav-number">37.</span> <span class="nav-text">typeof</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Ifer"
      src="/images/49337922.png">
  <p class="site-author-name" itemprop="name">Ifer</p>
  <div class="site-description" itemprop="description">React 全家桶 <span style='position:relative;top:-2px;'>✍</span></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ifer</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
